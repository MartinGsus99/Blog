# 字节 搜索 面经

## 一面

### 1.ES6的新特性你知道哪些？

#### let const

> var声明变量存在变量提升，let和const 不存在变量提升；
>
> let const 只能在块级作用域访问；
>
> 同一作用于下let和const 不能声明同名变量，var可以；

#### symbol

> ES6引入的新的原始数据类型，主要作用是为对象属性提供唯一的标识符；

- 创建Symbol

```js
const s1=Symbol("Description")
const s2=Symbol("Description")
console.log(s1===s2) //false

const obj={
    [s1]:'s1Value'
}
console.log(obj[s1]);
```

- 唯一性：每个Symbol值都是唯一的，这就很适合作为对象的属性键，避免属性名冲突；
- 隐私：作为属性键可以创建一些私有属性，外部代码无法直接访问；
- ES6内置Symbol

> 1. Symbole.iterator:用于定义对象的迭代器，使得对象可以for of循环；
> 2. Symbol.toString:用于自定义对象的toString方法的输出；

- 遍历Symbol属性

> 由于Symbol属性不会被for in或Object.keys遍历，通常需要使用Object.getOwnPropertySymbols（）方法来获取对象所有的Symbol属性；

```js
const symbols = Object.getOwnPropertySymbols(obj);
console.log(symbols); // [Symbol(description)]

```

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0e43c654baf0d0d607c047faecd4a79b.png)

#### 模板字符串

> ES6之前通过“\”和“+”来构建模板
>
> ES6后：
>
> - 使用`${}`来界定；
> - 反引号``直接搞定；

```html
<script>
      url="xxxxxx"
       // es6之前
       let html="<div>"+
                  " <a>"+url+"</a>"+
               "</div>";
		//es6
       let eshtml=`<div>
                   <a>${url}</a>
               </div>`
</script>

```

- 字符串方法

```js
let str = 'blue,red,orange,white';
//includes（）判断是否包含参数字符串；
str.includes('blue');//true

//startsWith（）/endsWith（）判断字符串是否以参数字符串开头或结尾；
str.startsWith('blue');//true
str.endsWith('blue');//false

//repeat()方法按指定次数返回一个新的字符串；
console.log('hello'.repeat(2));   //'hellohello'

//padStart()/padEnd（）
let arr = 'hell';
console.log(arr.padEnd(5,'o'));  //'hello'
console.log(arr.padEnd(6,'o'));  //'helloo'
console.log(arr.padEnd(6));  //'hell  ',如果没有指定将用空格代替
console.log(arr.padStart(5,'o'));  //'ohell'




```

#### 解构表达式

> 针对数组或对象进行模式匹配，对变量进行赋值；

#### 数组解构

```js
let [a,b,c] = [1,2,3];
console.log(a,b,c);    //1,2,3
 
let [a,b,c] = [1,,3];
console.log(a,b,c);    //1,undefined,3
 
let [a,,b] = [1,2,3];
console.log(a,b);//1,3
 
let [a,..b] = [1,2,3];  //...是剩余运算符，表示赋值运算符右边除第一个值外剩余的都赋值给b
console.log(a,b);//1,[2,3]

```

#### 对象解构

```
let obj = { 
	name: "ren", 
	age: 12, 
	sex: "male" 
};

let { name, age, sex } = obj;
console.log(name, age, sex); //'ren' 12 'male'

let { name: myName, age: myAge, sex: mySex } = obj; //自定义变量名
console.log(myName, myAge, mySex); //'ren' 12 'male'


```

### Map和Set

#### Map

> Map对象用于保存键值对，任何JS支持的值都可以作为键值；
>
> - 对象键只能是字符串或者Symbol，Map可以是任意值；
> - Map对象有size属性，存储对数；

```js
myMap.get('name');  //'ren'
myMap.has('age');  //true
myMap.delete('age');  //true
myMap.has('age');  //false
myMap.get('age');  //undefined
```

#### Set

> set对象和Map对象类似，但它存储不是键值对。类似数组，但它的**每个元素都是唯一的**。

```js
//数组去重
let arr = [1,1,2,3,4,4];

let mySet = new Set(arr);

let newArr = Array.from(mySet);
console.log(newArr);  //[1,2,3,4]

```

### 新增数组方法

- Array.from() 

```js
//arg1：可迭代对象
//arg2：对元素的回调函数
//arg3：this指向
```

```js
let arr = [1, 2, 3];
let obj = {
    double(n) {
        return n * 2;
    }
}
console.log(Array.from(arr, function (n){
    return this.double(n);
}, obj)); // [2, 4, 6]

```

- includes（）
- map（）、filter（）返回数组；
- forEach（）返回undefined；
- find（）返回第一个符合的元素
- some（）、every（）返回Boolean

#### 对象新增方法

- Object.is（）：用来判断值是否为同一个值，返回一个布尔类型的值；
- Object.assign（）：将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象。
- Object.keys（）：返回对象所有属性；
- Object.values（）：返回对象所有属性值；
- Object.entries() 返回多个数组，每个数组是 key–value

```js

	let person = {
		name: "admin",
		age: 12,
		language: ["java", "js", "css"],
	};
	console.log(Object.keys(person)); //[ 'name', 'age', 'language' ]
	
	console.log(Object.values(person)); //[ 'admin', 12, [ 'java', 'js', 'css' ] ]
	
	console.log(Object.entries(person));    /* [
	                                                     ["name", "admin"],
	                                                     ["age", 12],
	                                                     ["language", ["java", "js", "css"]],
	                                                 ]; */


```

#### 拓展运算符

```js

	const obj1 = { a: 1 };
	const obj2 = { b: 2 };
	const obj3 = { a: 5, c: 3 };
	
    let newObj ={...obj1,...obj2,...obj3}
	console.log(newObj); // { a: 5, b: 2 , c:3}


```

### 默认参数

#### 箭头函数

> 箭头函数和普通函数最大的区别在于其内部this永远指向其父级对象的this。



#### class

- 创建
- 继承

```js
<script>
	class Person {
		constructor(name, age) {
			this.name = name;
			this.age = age;
		}
		say() {
			console.log(this.name + ":" + this.age);
		}
	}
	class Student extends Person {
		constructor(name, age, sex) {
			super(name, age);
			this.sex = sex;
		}
	}
	var student = new Student("admin", 12, "male");
	student.name;   //'admin'
	student.sex;    //'male'
	student.say(); //'ren:12'
</script>

```

#### Proxy、Reflect

> `Proxy` 和 `Reflect` 是 ES6 中引入的两个强大的工具，通常用于拦截和修改对象的行为，帮助开发者进行底层操作和控制对象的交互方式。

##### Ptoxy

> `Proxy` 是用来创建一个对象的代理，它可以拦截并自定义对象的基本操作（如读取、写入、函数调用等）。
>
> 通过 `Proxy`，你可以在对象执行某些操作时，动态地添加自定义的行为。

```js
const target = {
    message: "Hello",
};

const handler = {
    get: function (obj, prop) {
        return prop in obj ? obj[prop] : 'Property does not exist';
    }
};

const proxy = new Proxy(target, handler);

console.log(proxy.message); // Hello
console.log(proxy.nonExistent); // Property does not exist

```

###### 常用的 `Proxy` 陷阱

- **`get`**：拦截属性的读取。
- **`set`**：拦截属性的写入。
- **`has`**：拦截 `in` 操作符。
- **`deleteProperty`**：拦截 `delete` 操作。
- **`apply`**：拦截函数调用。

#### Reflect

> `Reflect` 是一个内置对象，提供了和 `Proxy` 一一对应的静态方法，目的主要是规范化并简化对象的低级操作。`Reflect` 的方法与对象操作保持一致，并且它的作用类似于 `Proxy` 处理器中的默认行为。

###### 使用 `Reflect` 的好处

- **将默认行为显式化**：在 `Proxy` 的陷阱中，可以通过 `Reflect` 执行默认操作，避免显式地操作目标对象。
- **提供一致的 API**：`Reflect` 规范化了 JavaScript 中的底层对象操作，使得这些操作具备函数化风格。

###### 常用的 Reflect 方法

- **`Reflect.get(target, propertyKey)`**：返回指定对象的属性值。
- **`Reflect.set(target, propertyKey, value)`**：设置指定对象的属性值。
- **`Reflect.has(target, propertyKey)`**：与 `in` 操作符相同，检查属性是否存在。
- **`Reflect.deleteProperty(target, propertyKey)`**：删除指定对象的属性。

> 通常在 `Proxy` 的陷阱方法中，使用 `Reflect` 来执行默认行为。例如，拦截属性的读取后，仍然希望保留默认的行为。

```js
const handler = {
    get: function (obj, prop) {
        if (prop === 'secret') {
            return 'Access Denied';
        }
        return Reflect.get(...arguments); // 调用 Reflect.get 执行默认行为
    }
};

const proxy = new Proxy(target, handler);
console.log(proxy.name); // 正常返回属性值
console.log(proxy.secret); // Access Denied

```

#### Export、import模块化





### 2.异步编程解决方案Promise，详细说一下？



### 3.Promise为什么可以在状态变化之后再获取结果？



### 4.事件循环机制说一下



### 5.了解浏览器的缓存策略吗？



### 6.自己做项目的时候遇到的最有挑战的事情？



### 7.算法题。一个匹配模式和一个字符串，检验字符串是否符合匹配模式。比如模式abba，字符串dog cat cat dog就返回true；但是如果是dog dog dog dog这种就返回false。



### 8.代码题

```js
var a = function(){this.b = 3}
var c = new a()
a.prototype.b = 9
var b = 7
a()

//分别输出什么？为什么？
console.log(b)
console.log(c.b)
```

上面这段代码放到一个立即执行函数里面执行，会有什么不同吗？为什么？

## 二面

### 1.webpack从0到1构建一个项目，说一下思路。

- 初始化项目

```shell
mkdir project
cd project
npm init-y
```



### 2.webpack的优化手段，除了持久化缓存、多线程打包、splitChunk还有哪些？

#### 缩小打包体积

- TreeShaking：基于ES6的import export，通过分析代码依赖关系，只保留实际使用的部分，减小打包体积；
- 代码压缩：使用TerserPlugin来压缩JS文件，从而减少打包后的体积。
- CSS压缩：css-minimizer-webpack-plugin；
- 移除未使用的css：purgecss-webpack-plugin；

#### 优化构建速度

- Babel-loader缓存：避免编译相同文件；
- 硬件加速和多进程打包：thread-loader和parallel-webpack；

#### 代码分割

- 按需加载：使用import（）实现按需加载，减少首屏加载时间；
- 异步代码分割：使用splitChunks来分割异步代码；

#### 缓存优化

- cache-loader：缓存打包结果，使后续构建中可以直接使用缓存，提升构建速度；
- 文件名哈希化：配合浏览器缓存，减少不必要的资源重新加载；



### 3.TreeShaking为什么需要基于ES Module才能实现？

#### ESModule是静态的

- ESM的import和export是静态的，即模块的导入到处必须在编译时就能确定，且解构不会在运行时发生变化；
- ESM的模块解构关系在编译时确定，Webpack和其他打包工具可以在打包过程中确定哪些代码被使用；

#### CommonJS是动态的

- 相比于 ES Module，CommonJS（`require`/`module.exports`）模块是**动态的**。这意味着模块的导入和导出行为可以在运行时动态变化，编译工具无法在编译阶段静态确定模块的依赖关系。

### ⭐4.webpack5的Module Federation了解吗？他跟npm包有什么不一样吗？





### 5.场景题：CSS实现两个子元素2:1比例分割父元素。



### 6.flex-grow flex--shrink flex-basis具体都有什么用？



### 7.Promise实现一个超时请求控制。（race）

> 用一个定时器和请求race

```js
// 模拟的请求函数
function fetchData() {
  return new Promise((resolve) => {
    // 模拟网络请求延迟
    setTimeout(() => {
      resolve('数据加载成功！');
    }, 3000); // 模拟请求时间为3秒
  });
}

// 创建一个超时 Promise
function timeoutPromise(ms) {
  return new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error('请求超时！'));
    }, ms);
  });
}

// 超时请求控制函数
function fetchWithTimeout(url, timeoutMs) {
  return Promise.race([
    fetchData(), // 实际的请求
    timeoutPromise(timeoutMs) // 超时 Promise
  ]);
}

// 调用函数示例
fetchWithTimeout('https://api.example.com/data', 2000) // 设置超时为2秒
  .then((data) => {
    console.log(data); // 成功返回数据
  })
  .catch((error) => {
    console.error(error.message); // 捕获并处理超时错误
  });

```

### 8.Promise.all Promise.race手写一下。

```js
function myPromiseAll(promises) {
  return new Promise((resolve, reject) => {
    // 用来存储所有 Promise 的结果
    const results = [];
    let completedCount = 0;

    // 处理每一个 Promise
    promises.forEach((promise, index) => {
      Promise.resolve(promise) // 确保每个输入都被转换为 Promise
        .then((result) => {
          results[index] = result; // 保存结果
          completedCount++;

          // 当所有 Promise 都完成时，解析结果
          if (completedCount === promises.length) {
            resolve(results);
          }
        })
        .catch((error) => {
          // 如果任何一个 Promise 失败，立即拒绝
          reject(error);
        });
    });
  });
}

```

```js
function myPromiseRace(promises) {
  return new Promise((resolve, reject) => {
    promises.forEach((promise) => {
      Promise.resolve(promise) // 确保每个输入都被转换为 Promise
        .then(resolve) // 一旦某个 Promise 解析，立即解析
        .catch(reject); // 一旦某个 Promise 被拒绝，立即拒绝
    });
  });
}

```



### 9.http和websocket协议的不同点？项目里面用过吗？



### 10.输入url到显示页面的过程。



### 11.重绘重排。



### 12.怎么样利用合成来减少重绘重排？



### 13.Vue双向绑定的原理说一下。



### 14.响应式原理详细说一下，Vue2的响应式有什么问题？



### 15.Vue3为什么采用了Proxy？这里好像要我说一下Proxy如何polyfill



### 16.算法题。给定一个字符串，要求处理之后字符串中不含有b以及连续的ac。（栈）



### 17.设计一个图片懒加载方案。



### 18.原生实现轮播图，说一说实现的思路。

```js
const carouselInner = document.querySelector('.carousel-inner');
const carouselItems = document.querySelectorAll('.carousel-item');
const prevButton = document.querySelector('.prev');
const nextButton = document.querySelector('.next');
let currentIndex = 0;

function updateCarousel() {
  const totalItems = carouselItems.length;
  // 计算轮播图平移的距离
  const offset = -currentIndex * 100; // 每个项占据100%的宽度
  carouselInner.style.transform = `translateX(${offset}%)`;
}

// 前进按钮事件
nextButton.addEventListener('click', () => {
  currentIndex = (currentIndex + 1) % carouselItems.length; // 循环到第一个
  updateCarousel();
});

// 后退按钮事件
prevButton.addEventListener('click', () => {
  currentIndex = (currentIndex - 1 + carouselItems.length) % carouselItems.length; // 循环到最后一个
  updateCarousel();
});

// 自动轮播（可选）
setInterval(() => {
  currentIndex = (currentIndex + 1) % carouselItems.length;
  updateCarousel();
}, 3000); // 每3秒切换一次

```



### 19.还有其他的offer吗？



### 20.每周能实习多久？



## 三面

### 1.项目是自己想的吗？



### 2.做项目学到了什么？



### 3.如果没有后端接口，前端怎么提前模拟数据请求？



### 4.axios的拦截器知道吗？拦截器有什么用？



### 5.自己封装过组件吗？一个好的组件的标准应该是什么？



### 6.吸顶的效果是怎么实现的？如果需要你原生实现呢？



### 7.怎么从前端的角度减少首页的白屏时间？



### 8.Vue2有哪些钩子？网络请求应该放在哪里？如果是使用骨架屏或者加载动画的话，请求又应该放在哪里？



### 9.如果减少请求的数据之后，首页渲染时间还是不达标？应该怎么办？



### 10.怎样加快网页二次渲染速度？（除了缓存、懒加载之外的方法）



### 11.Vue2和Vue3的响应式对于数组而言有什么不同？



### 12.webpack怎么学的？如果一个项目有成百上千个入口文件怎么办？



### 13.Promise.all和Promise.race说一下，应用场景有哪些？



### 14.从你自己的角度看，TypeScript有用吗？



### 15.合作开发项目的时候遇到过项目成员意见有冲突的情况吗？怎么解决的？



### 16.想从实习里面学到什么？倾向于业务还是工程化？



### 17.如果开发过程中遇到了一个问题？你倾向于使用什么方式解决？


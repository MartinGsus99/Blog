---
title: 阿里前端面经
date: 2023-12-12 21:13:45
categories:
  - 前端
tags:
  - JS
  - 笔记
  - TS
mp3:
cover: img/bg3.jpg
---

# 阿里前端面经

### 1.为什么选前端？

- 不如后端枯燥
- 兴趣高
- 涉及的方向很多：游戏开发，网页设计等等；

### 2.怎么学前端？

- 做项目
- 看文档
- 查知乎
- 看代码

### 3.结合项目，用过哪些类库？

- Echarts

- Axios

- ElementUI

- AcroDesign

- G6

- DataV

### 4.Webpack 和 Vite 的区别？

- 开发模式不同

> *Webpack在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而Vite则采用了基于ES Module的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。*

- 打包效率不同

> *Webpack在打包时，会把所有的模块打包成一个bundle，这会导致初次加载速度较慢；而Vite则利用了浏览器对ES Module的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。*

- 插件生态不同

> *Webpack的插件生态非常丰富，有大量社区和官方插件可以选择，覆盖了前端开发的各个方面；而Vite的插件生态尽管在不断发展，但相比Webpack来说还显得较为稀少。*

- 配置复杂度不同

> *Webpack的配置相对复杂，对新手不够友好；而Vite在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。*

- 热更新机制不同

> *Webpack的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite的热更新则只会针对改动的模块进行更新，提高了更新速度。*



### 5.本地和线上不一致怎么调试？



### 6.输入 URL 到渲染的整个流程？

https://blog.csdn.net/weixin_45811256/article/details/130316442

> 1. 浏览器接收 url 并开启一个新进程（这一部分可以展开浏览器的进程与线程的关系）
> 2. 浏览器解析输入的 URL，提取出其中的协议、域名和路径等信息。（这部分涉及 URL 组成部分）
> 3. 浏览器向 DNS 服务器发送请求，DNS 服务器通过 多层查询 将该 域名 解析为对应的 IP 地址 ，然后将请求发送到该 IP 地址上，与 服务器 建立连接和交换数据。（这部分涉及 DNS 查询）
> 4. 浏览器与服务器建立 TCP 连接。（这部分涉及 TCP 三次握手/四次挥手/5 层网络协议）
> 5. 浏览器向服务器发送 HTTP 请求，包含请求头和请求体。（4,5,6,7 包含 http 头部、响应码、报文结构、cookie 等知识）
> 6. 服务器接收并处理请求，并返回响应数据，包含状态码、响应头和响应体。
> 7. 浏览器接收到响应数据，解析响应头和响应体，并根据状态码判断是否成功。
> 8. 如果响应成功，浏览器接收到 http 数据包后的解析流程（这部分涉及到 html - 词法分析，解析成 DOM 树，解析 CSS 生成 CSSOM 树（样式树），合并生成 render 渲染树（样式计算）。然后 layout 布局，分层，调用 GPU 绘制等，再显示在屏幕上。这个过程会发生回流和重绘）。
> 9. 连接结束 -> 断开 TCP 连接 四次挥手

### 7.浏览器缓存

> 缓存的好处：
>
> 1. 使网页加载和呈现速度更快
> 2. 减少不必要的数据传输，节省流量和宽带，减少服务器负担

> 缓存位置分类：
>
> 1. 内存缓存
> 2. 硬盘缓存
> 3. service worker

> 缓存策略分类：
>
> 1. 强缓存
> 2. 协商缓存

![img](https://upload-images.jianshu.io/upload_images/15528678-04ce67084f2e9d1e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1163/format/webp)

![在这里插入图片描述](https://img-blog.csdnimg.cn/74230e82554a4388afcd19571806b3ef.png)

#### 缓存过程

- 第一次请求数据时，浏览器缓存没有对应的缓存数据，因此需要请求服务器，浏览器把响应的数据存储在缓存数据库中；
- 如果浏览器中存在缓存数据，则可以根据是否需要向服务器发送请求，将缓存类型分为：强制缓存和协商缓存；

##### 强制缓存

> 如果命中强缓存，则不向服务器请求，直接从本地获取资源，返回 200 状态码，提示`from disk cache`或者`from memory cache`

> 强制缓存的`response header`中会有两个字段：`Expires/Cache-control`
>
> `Expires`为服务器返回的到期时间，下一次请求之前，请求时间小于过期时间则直接使用缓存数据；适用于 http1.0，现在基本是 1.1；1.1 版本使用`cache-control`替代
>
> `cache-control` 常见的值有`private`,`public`,`no-cache`,`max-age`
>
> 因为 Expires 过期时间采用绝对时间，容易造成差错；cache-control 采用相对时间，不会出错

##### 协商缓存

> 用户请求资源时，浏览器向服务器发送请求，协商对比服务端和本地资源，验证本地资源是否失效；

> 一般使用`if-modifired-since`,`Last-Modifird`,`if-none-match/Etag`由服务器决定浏览器缓存是否可用；
>
> Last-Modified：服务器响应请求时，告诉浏览器资源最后的修改时间。
>
> If-Modified-Since：浏览器再次请求资源时，浏览器通知服务器，上次请求时，返回的资源最后修改时间。
>
> 若最后修改时间小于等于 If-Modified-Since，则 response header 返回 304，告知浏览器继续使用所保存的 cache。若大于 If-Modified-Since，则说明资源被改动过，返回状态码 200；
>
> Etag：服务器响应请求时，告诉浏览器当前资源在浏览器的唯一标识（生成规则由服务器确定）
>
> If-None-Match：再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。服务器收到请求后发现有 If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码 200；相同，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用所保存的 cache。

1.在精确度上，Etag 优于 Last-Modified。Last-Modified 精确到 s，如果 1s 内，资源多次改变，Etag 是可以判断出来并返回最新的资源。

2.在性能上，Last-Modified 优于 Etag，因为 Last-Modified 只需要记录时间，而 Etag 需要服务器重新生成 hash 值，所以性能上略差。

3.在优先级上，Etag 优于 Last-Modified，Etag 和 Last-Modified 可同时存在。

#### 浏览器缓存废弃更新策略

服务器下发资源以后，就对其失去了控制权。

- HTML：缓存有效时间 0s，页面加载时强制每次向服务器确认数据
- CSS：改动频率较低，允许使用本地缓存，且存在强制缓存时间；失效进行协商缓存
- JS：运行本地缓存，且存在强制缓存时间，各个 JS 文件不同；失效进行协商缓存
- Image：图片更改率低，允许使用本地缓存，且存在强制缓存时间；失效进行协商缓存
- Gif：gif 主要存在于 banner 轮播，因此确保时效性，使用 no-cache，不允许缓存，强制每次向源服务器确认数据。

### 8. DOM 树怎么构建？

https://blog.csdn.net/userkang/article/details/80851153

#### DOM树

> DOM 结构构成的基本要素是 “节点“，而文档的结构就是由层次化的节点组成。在 DOM 模型中，节点的概念很宽泛，整个文档 （Document） 就是一个节点，称为文档节点。除此之外还有元素（Element）节点、属性节点、Entity节点、注释（Comment）节点等。

![HTML 网页和它的 DOM 树表示](https://i-blog.csdnimg.cn/blog_migrate/e066998b60116317cd72b619efd3a070.png)

#### HTML解释器

##### 解释过程

> 将网络或本地磁盘获取的HTML网页和资源从字节流解释成DOM树结构；

![从资源的字节流到 DOM 树](https://i-blog.csdnimg.cn/blog_migrate/a75f118bf2877716326b9ed8b955264c.png)
$$
字节流->字符流->词语Tokens->节点->DOM树
$$
这个过程会调用对应的处理类去处理：

- 词法分析：HTML Tokenizer类；
- 词语验证：XSSAuditor类；
- 词法到节点：HTML Doucument Parser类、HTML TreeBuilder类；
- 节点到DOM树：HTMLConstructionSite类；

> 对于线程化的解释器，字符流后的整个解释、布局和渲染过程基本会交给一个单独的渲染线程来管理（不是绝对的）。由于 DOM 树只能在渲染线程上创建和访问，所以构建 DOM 树的过程只能在渲染线程中进行。但是，从字符串到词语这个阶段可以交给单独的线程来做，Chromium 浏览器使用的就是这个思想。在解释成词语之后，Webkit 会分批次将结果词语传递回渲染线程。

##### JS执行

> 在HTML解释器工作过程中，可能会有JS代码需要执行，它发生在将字符解释称词语之后，创建各种节点的时候。
>
> 这也是为什么全局执行的 JavaScript 代码不能访问 DOM 的原因——因为 DOM 树还没有被创建完呢。

> WebKit将DOM树创建过程中需要执行的JS代码交由HTMLScriptRunner类来负责，利用JS引擎执行Node节点中包含的代码；
>
> 因为JS可能会修改文档结构，所以代码的执行会妨碍后面节点的创建，同时也会阻碍后面资源下载，这就导致资源不能并发下载，一般建议：
>
> - script标签加上"async"或“defer”属性；
> - 将script标签放到body元素后面；

具体过程就是当需要执行 JavaScript 代码的时候，WebKit 先暂停代码的执行，使用预扫描器 HTMLPreloadScanner 类来扫描后面的词语， 如果发现需要使用其他资源，那么就会使用与资源加载器 HTMLResourcePreloader 类来发送请求，在这之后，才执行 JavaScript 代码。由于预扫描器本身并不创建节点对象，也不会构建 DOM 树，所以速度比较快。就算如此，还是推荐不要在头部写入大量 JavaScript 代码，毕竟不是所有渲染引擎都做了这样的优化。

在 DOM 树构建完成后，WebKit 会触发 “DOMContentLoaded” 事件，当所有资源都被加载完成后，会触发 “onload” 事件。




### 9. pc 端和移动端可以用一套代码吗？如果做成跨平台怎么做？

可以

##### 方案一：使用 CSS 媒体查询

```scss
@media screen and (max-width:992px){...}
@media screen and (max-width:1400px){...}
```

弊端：

- pc端和移动端界面交互体验不同，页面布局也不同，远远达不到原生移动端的效果；

##### 方案二：写两套代码，分别应用于PC端和移动端





### 10. React 原理对实际写代码有哪些帮助？

https://blog.csdn.net/m0_62554628/article/details/134265917

React的整个流程可以分成三个阶段：创建元素、描述元素、渲染元素。具体如下图所示：

- 创建元素：元素是React应用的最小单位。例如，一个按钮可以作为一个React元素；

- 描述元素：React允许我们用jsx语法描述元素。jsx可以在HTML中嵌入JavaScript表达式，还可以使用标签来定义元素；
- 渲染元素：当React应用中需要渲染某个元素时，它会把元素转换成真实DOM节点并放置到浏览器上显示。

> React中的组件就是一个函数或类，它接受输入参数（props）并返回一个React元素。这样，我们就可以通过组合不同的组件来构建复杂的应用界面。组件的最大优点之一是封装性。我们只需要关注当前组件的业务逻辑，而不是关注其内部的实现细节。

> React的另一个特性就是它的状态管理机制。不同于其他框架，React没有依赖Flux或者Redux这样的数据流管理工具。它自身提供了自己的可靠的状态管理方案——useState。useState可以帮助我们在一个函数组件中维护状态变量，并且可以触发重新渲染。useState的第二个优点是函数式更新，它可以避免某些情况下导致的组件之间状态共享问题。
>

#### JSX

> JSX (JavaScript eXtension) 是一种类似 XML 的语法扩展，用来定义 React 组件的结构及行为。JSX 是一个 JavaScript 的语法扩展，意味着 JSX 在执行的时候并不会直接转译为 JavaScript 代码。相反，编译器会将 JSX 代码转换为 React.createElement() 函数调用形式的代码。在 JSX 中，我们可以用花括号包裹 JavaScript 代码，然后使用 JSX 标签来创建元素。
>

- JSX 可以用来定义组件的结构和行为，非常直观易懂；
- JSX 将组件的结构和行为集成到了一起，使得代码更容易阅读、维护和修改；
- JSX 具有很强的可读性，因为它让代码和 UI 界面一目了然；
- JSX 和 JavaScript 在语法层面上是同构的。

#### state

State 用于记录组件内部数据的变化，也就是动态数据。它可以与 Props 一起被组件使用，也可以由组件自己修改。它主要用于在组件中存储和修改本地数据。State 的改变会触发组件的重新渲染。



#### Component

组件是 React 中的基础组成单元。它是一个拥有自身状态和 UI 输出的函数或类。组件可以嵌套、复用和扩展。组件的组合也称为组件树。



#### VDOM

Virtual DOM (虚拟 DOM) 是内存中的一个纯 JavaScript 对象，用来描述 DOM 节点及其属性。React 通过 Virtual DOM 把浏览器的 Document Object Model（DOM）与组件的状态关联起来，当状态发生变化时，React 会重新构造 Virtual DOM，并对比两棵 Virtual DOM 树的不同，计算出仅包含必要变化的最小更新集合，然后批量更新浏览器的 DOM，从而尽可能地减少实际 DOM 操作次数，提高性能。

#### Fiber

Fiber （纤程） 是 React 16 版本引入的一项新技术。它是一种可替代栈的运算模型，可以让 React 更好地利用多核 CPU。Fiber 是将组件树变换成链表的结构，每个节点包含指向其子节点的指针。React 可以从头开始遍历这个链表，并根据需要进行调度，使得不同类型的任务可以交给不同的线程去执行。这种模型能更好的利用内存缓存等资源，有效降低延迟。


#### Hooks

Hooks 是 React 16.8 版本新增的特性。它允许我们在不编写 class 的情况下使用 state 和 lifecycle 方法。我们可以通过 useState、useEffect、useContext、useReducer、useCallback、useMemo、useRef、useImperativeHandle、customHooks 等 hooks 来替换以前生命周期方法的使用。




### 11. diff 算法

https://juejin.cn/post/6994959998283907102

> 虚拟 DOM 是一个对象，用来表示真实 DOM 的对象。

```html
<ul id="list">
  <li class="item">哈哈</li>
  <li class="item">呵呵</li>
  <li class="item">嘿嘿</li>
</ul>
```

对应虚拟 DOM 为：

```js
let oldVDom = {
  tagName: 'ul',
  props: {
    id: 'list',
  },
  children: [
    {
      tagName: 'li',
      props: {
        class: 'item',
      },
      children: ['哈哈'],
    },
    {
      tagName: 'li',
      props: {
        class: 'item',
      },
      children: ['嘿嘿'],
    },
    {
      tagName: 'li',
      props: {
        class: 'item',
      },
      children: ['嘻嘻'],
    },
  ],
}
```

此时，修改 li 标签文本：

```html
<ul id="list">
  <li class="item">哈哈</li>
  <li class="item">呵呵</li>
  <li class="item">哈哈哈哈哈</li>
  // 修改
</ul>
```

新的 xuniDOM：

```js
let newVDom = {
  tagName: 'ul',
  props: {
    id: 'list',
  },
  children: [
    {
      tagName: 'li',
      props: {
        class: 'item',
      },
      children: ['哈哈'],
    },
    {
      tagName: 'li',
      props: {
        class: 'item',
      },
      children: ['嘿嘿'],
    },
    {
      tagName: 'li',
      props: {
        class: 'item',
      },
      children: ['嘻嘻哈哈~'],
    },
  ],
}
```

#### DIFF 算法

> 新旧虚拟 DOM 进行比较时，Diff 算法只会在同级进行比较，不会跨层级比较，所以 Diff 算法是：深度优先算法，时间复杂度：O(N)

当数据发生改变时，会触发 setter，并且通过 Dep.notify 去通知所有订阅者 watcher，订阅者会调用 patch 方法给真实 DOM 打补丁，更新相应的视图

![image-20220318160744010](https://img-blog.csdnimg.cn/img_convert/494dc2d0bedeb029215132ae48c5129e.png)

##### patch 方法

> 对比当前同层节点是否为同一类型标签，如果是，进行深层比较；否则直接替换成新的虚拟节点；

```js
function sameVnode(oldVnode, newVnode) {
  return (
    oldVnode.key === newVnode.key && // key值是否一样
    oldVnode.tagName === newVnode.tagName && // 标签名是否一样
    oldVnode.isComment === newVnode.isComment && // 是否都为注释节点
    isDef(oldVnode.data) === isDef(newVnode.data) && // 是否都定义了data
    sameInputType(oldVnode, newVnode) // 当标签为input时，type必须是否相同
  )
}

function patchVNode(oldVNode, newVNode) {
  const el = (newVNode.el = oldVDom.el)
  const oldCh = oldVNode.children,
    newCh = newVnode.children
  if (oldVNode === newVnode) return
  if (
    oldVNode.text !== null &&
    newVnode.text !== null &&
    oldVNode.text !== newVnode.text
  ) {
    // 则直接将真实DOM中文本更新为新虚拟节点的文本
    api.setTextContent(el, newVnode.text)
  } else {
    // 否则

    if (oldCh && newCh && oldCh !== newCh) {
      // 新旧虚拟节点都有子节点，且子节点不一样

      // 对比子节点，并更新
      updateChildren(el, oldCh, newCh)
    } else if (newCh) {
      // 新虚拟节点有子节点，旧虚拟节点没有

      // 创建新虚拟节点的子节点，并更新到真实DOM上去
      createEle(newVnode)
    } else if (oldCh) {
      // 旧虚拟节点有子节点，新虚拟节点没有

      //直接删除真实DOM里对应的子节点
      api.removeChild(el)
    }
  }
}

function patch(oldVnode, newVnode) {
  // 比较是否为一个类型的节点
  if (sameVnode(oldVnode, newVnode)) {
    // 是：继续进行深层比较
    patchVnode(oldVnode, newVnode)
  } else {
    // 否
    const oldEl = oldVnode.el // 旧虚拟节点的真实DOM节点
    const parentEle = api.parentNode(oldEl) // 获取父节点
    createEle(newVnode) // 创建新虚拟节点对应的真实DOM节点
    if (parentEle !== null) {
      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素
      api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点
      // 设置null，释放内存
      oldVnode = null
    }
  }

  return newVnode
}
```

##### patchVnode 方法

> 当为同一结点时，会调用 patchVnode 方法进行逐层对比：
>
> - 找到对应的 oldVnode，真实 DOM ，称为 el
>
> - 判断 newVnode 和 oldVnode 是否指向同一个对象，如果是，那么直接返回 return
>
> - 如果他们都有文本节点并且不相等，那么将 el 的文本节点设置为 newVnode 的文本节点。
>
> - 如果 oldVnode 有子节点而 newVnode 没有，则删除 el 的子节点
>
> - 如果 oldVnode 没有子节点而 newVnode 有，则将 newVnode 的子节点真实化之后添加到 el
>
> - 如果两者都有子节点，则执行 updateChildren 函数比较子节点，这一步很重要

##### updateChildren 方法

> 首位指针法比较

1、oldS 和 newS 使用 sameVnode 方法进行比较，sameVnode(oldS, newS)

2、oldS 和 newE 使用 sameVnode 方法进行比较，sameVnode(oldS, newE)

3、oldE 和 newS 使用 sameVnode 方法进行比较，sameVnode(oldE, newS)

4、oldE 和 newE 使用 sameVnode 方法进行比较，sameVnode(oldE, newE)

5、如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -> index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置。
![image-20220318162852509](https://img-blog.csdnimg.cn/img_convert/340ff40976f85af351c7e92a7a09fc95.png)![image-20220318163243338](https://img-blog.csdnimg.cn/img_convert/3162e2fc5f40ea0ce98c119eed883362.png)![image-20220318163404090](https://img-blog.csdnimg.cn/img_convert/c39aea1e485f5b8debade420c571c056.png)![image-20220318163630388](https://img-blog.csdnimg.cn/img_convert/65e85686584ddca1c45c7c7cd40ce232.png)![image-20220318163738285](https://img-blog.csdnimg.cn/img_convert/d6996558d8e59f215cc1a2d21fd68f48.png)

```js
function updateChildren(parentElm, oldCh, newCh) {
  let oldStartIdx = 0,
    newStartIdx = 0
  let oldEndIdx = oldCh.length - 1
  let oldStartVnode = oldCh[0]
  let oldEndVnode = oldCh[oldEndIdx]
  let newEndIdx = newCh.length - 1
  let newStartVnode = newCh[0]
  let newEndVnode = newCh[newEndIdx]
  let oldKeyToIdx
  let idxInOld
  let elmToMove
  let before
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx]
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx]
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx]
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode)
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode)
      api.insertBefore(
        parentElm,
        oldStartVnode.el,
        api.nextSibling(oldEndVnode.el)
      )
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode)
      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    } else {
      // 使用key时的比较
      if (oldKeyToIdx === undefined) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表
      }
      idxInOld = oldKeyToIdx[newStartVnode.key]
      if (!idxInOld) {
        api.insertBefore(
          parentElm,
          createEle(newStartVnode).el,
          oldStartVnode.el
        )
        newStartVnode = newCh[++newStartIdx]
      } else {
        elmToMove = oldCh[idxInOld]
        if (elmToMove.sel !== newStartVnode.sel) {
          api.insertBefore(
            parentElm,
            createEle(newStartVnode).el,
            oldStartVnode.el
          )
        } else {
          patchVnode(elmToMove, newStartVnode)
          oldCh[idxInOld] = null
          api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)
        }
        newStartVnode = newCh[++newStartIdx]
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el
    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
  }
}
```

### 12. Vue 和 React、angular 的差别？

https://baijiahao.baidu.com/s?id=1775305233746843754&wfr=spider&for=pc

##### React

- 优点：
  - 虚拟DOM和高效的更新机制，提升性能。
  - 大量的开源组件和生态系统，加速开发进程。
  - 社区庞大，有丰富的教程和文档资源。
- 缺点：
  - React本身只关注视图层，其他功能需要借助第三方库或框架。

##### vue

- 优点：
  - 渐进式框架，易于学习和集成。
  - 响应式数据绑定，使状态管理更加便捷。
  - 文档清晰，社区活跃，有详细的指南和教程。
- 缺点：
  - 生态系统相对React略小。



### 13.进程、线程

##### 进程

> 程序=算法+数据结构
>
> 进程作为一种抽象概念，可以将其视为一种容器，聚集了相关资源，包括地址空间，线程，文件，保护许可等；可以通过PCB这种数据结构来表示它；

![image](https://developer.qcloudimg.com/http-save/10671860/180375f56ee0e99dba2e0df116fae46d.png)

进程的切换：为了保证每个进程都能获得公平的CPU时间片来执行自己的程序，也叫上下文切换，涉及内容如下：

- 存储进程的相关信息，计数器、寄存器等；
- 更新进程的状态；
- 将当前进程放入就绪队列或阻塞队列；
- 调度算法将另一个进程加载并运行；
- 更新内存；

进程切换的场景：

- 时间片用完；
- 内存不足；
- sleep函数；
- 高优先级任务；
- 硬件中断；

##### 线程

> 更小的能独立运行的基本单位；
>
> 线程是进程的一条执行流程，多个线程共享代码段，数据段，文件资源等；但是每个线程都有自己的一套独立寄存器和栈，确保线程的控制流是相对独立的。可以将线程视为CPU调度的基本单位。

![image](https://developer.qcloudimg.com/http-save/10671860/12659d0c43ed0c7aa2af9a344b4b4f9c.png)

由于线程是调度的基本单位， 而进程是资源分配的基本单位；

线程的上下文切换是指在切换线程时，需要保存和恢复线程的执行上下文。与进程相比，线程上下文切换的代价要小得多。

如果一个进程只有主线程，那么线程的切换流程与进程切换相同。

如果是进程内的某个线程进行切换，代价会更小。只需要保存线程的相关寄存器和计数器等信息，因为其他资源和虚拟内存是进程内共享的，无需切换。因此，线程的上下文切换开销较进程小很多。





### 14.数组和链表

- 数组

> 相同类型的数据集合，js 支持不同类型数据存在一个数组；
>
> 随机读取，通过下标访问；
>
> 查找速度快，从栈上分配内存使用方便，缺点是插入删除效率低内存要连续；

- 链表

> 插入删除快
>
> 不支持随机存储，内存利用率高，但是需要额外空间存储指针；查找效率低；





### 15.变量提升

> ES6 中新增 let 和 const 关键字，解决了变量提升的问题

> 变量提升指 js 代码执行过程中，JS 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为，变量提升后，会设置默认值 undefined

```js
console.log(num)
var num = 1
```

等同于

```js
var num
console.log(num)
num = 1
```

在函数作用域中也会存在变量提升，除了变量，函数实际上也存在提升。

> 变量提升和 JS 的编译过程有关，JS 在编译阶段，会搜集所有的变量声明，并且让声明生效，而剩下的语句需要等到执行阶段才能生效。

#### 变量覆盖

```js
var name = 'JavaScript'
function showName() {
  console.log(name)
  if (0) {
    var name = 'CSS'
  }
}
showName()
```

> 当执行 showName 函数调用的时候，会创建 showName 函数的执行上下文，之后 js 便开始执行 showName 函数内的代码，首先 showName 内部的代码。首先执行的是

```js
console.log(name)
```

> 一个 name 在全局上下文值为“JavaScript”
>
> 另一个在 showName，因为 if（0）永远不执行，所以 name 为 undefined

```js
function getNum() {
  var num 
  console.log(num) 
  num = 1  
}
getNum() //undefined
```

#### 变量没有被销毁

```js
function foo() {
  for (var i = 0; i < 5; i++) {}
  console.log(i)
}
foo() //5
```

#### 函数的声明

```js
//变量式声明
fn()
var fn = function () {
 console.log(1)  
}
// 输出结果：Uncaught TypeError: fn is not a function

//函数式声明
foo()
function foo () {
 console.log(2)
}
// 输出结果：2
```

#### 为什么会有变量提升？

ES6以前，作用域分为两种：

- **全局作用域**中的对象在代码中的任何地方都可以访问，其生命周期伴随着页面的生命周期。
- **函数作用域**是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

ES6以前不支持块级作用域；

#### 变量提升的好处

- 提高性能：JS执行前会进行语法检查和预编译，并且只执行一次。预编译时会统计声明了那些变量、创建了那些函数，并对函数代码进行压缩，去除注释和空白。每次执行函数都可以直接为该函数分配栈空间；
- 容错性更好：如果没有变量提升，以下代码会报错；

```js
a = 1;
var a;
console.log(a); // 1
```

#### 禁用变量提升

为了解决上述问题，**ES6 引入了 let 和 const 关键字**，从而使 JavaScript 也能像其他语言一样拥有块级作用域。let 和 const 是不存在变量提升的。

```js
console.log(num) 
let num = 1

// 输出结果：Uncaught ReferenceError: num is not defined
```

####  ES6是如何做到既要支持变量提升的特性，又要支持块级作用域？

```js
function fn(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
      console.log(d)
    }
    console.log(b) 
    console.log(c)
}   
fn()
```

- 创建执行上下文

![img](https://pic2.zhimg.com/80/v2-d0c52b3ffaf9f5068bf670437e78302d_720w.webp)

> 1. 通过var声明的变量，在编译阶段会被存放到变量环境中；
> 2. 通过let声明的变量，在编译阶段会被存放到词法环境中；
> 3. 函数作用域内部，通过let声明的变量并没有被放到词法环境中；

块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎就同时支持了变量提升和块级作用域。

#### 暂时性死区

```js
var name = 'JavaScript';
{
 name = 'CSS';
 let name;
}

// 输出结果：Uncaught ReferenceError: Cannot access 'name' before initialization
```

ES6 规定：如果区块中存在 let 和 const，这个区块对这两个关键字声明的变量，从一开始就形成了封闭作用域。假如尝试在声明前去使用这类变量，就会报错。这一段会报错的区域就是暂时性死区。

暂时性死区的本质：当程序的控制流程在新的作用域进行实例化时，在此作用域中用 let 或者 const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这段时间，就称之为暂时死区。

在 let 和 const关键字出现之前，typeof运算符是百分之百安全的，现在也会引发暂时性死区的发生，像import关键字引入公共模块、使用new class创建类的方式，也会引发暂时性死区，究其原因还是变量的声明先与使用。



### 16. tcp 协议等

> 传输控制协议（TCP）是 Internet 一个重要的传输层协议.TCP 提供面向连接、可靠、有序、字节流传输服务。应用程序在使用 TCP 之前，必须先建立 TCP 连接；TCP 通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。

https://zhuanlan.zhihu.com/p/471415273









### 17.`setInterval`的间隔时间是准确的吗? 如何做到间隔时间绝对准确

https://www.zhihu.com/question/301356245

> 不是准确的，因为`setInterval`的回调函数并不是时间到了就立即执行，而是系统资源空闲之后才会执行。因为 JS 是单线程语言。而下一次触发时间则是在 setInterval 回调函数执行完毕之后才开始计时。所以如果 setInterval 内执行的计算过于耗时，或者有其他任务在执行，那么其计时会越来越不准。
>
> setInerval()，setTimeout()是宏任务

解决方法：

- 使用动态时间纠正

- 使用 Web Worker 为 JS 创造多线程环境

> 允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在[后台运行](https://www.zhihu.com/search?q=后台运行&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2363760138})，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。

```js
// index.js
let count = 0
//耗时任务
setInterval(function () {
  let i = 0
  while (i++ < 100000000);
}, 0)

// worker
let worker = new Worker('./worker.js')

// worker.js
let startTime = new Date().getTime()
let count = 0
setInterval(function () {
  count++
  console.log(
    count + ' --- ' + (new Date().getTime() - (startTime + count * 1000))
  )
}, 1000)
```

- requestAnimationFrame()

> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行，理想状态下回调函数执行次数通常是每秒 60 次（也就是我们所说的[60fsp](https://www.zhihu.com/search?q=60fsp&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2363760138})），也就是每 16.7ms 执行一次，但是并不一定保证为 16.7 ms。

```js
const t = Date.now()
function mySetTimeout(cb, delay) {
  let startTime = Date.now()
  loop()
  function loop() {
    if (Date.now() - startTime >= delay) {
      cb()
      return
    }
    requestAnimationFrame(loop)
  }
}
mySetTimeout(() => console.log('mySetTimeout', Date.now() - t), 2000) //2005
setTimeout(() => console.log('SetTimeout', Date.now() - t), 2000) // 2002
```



### 18.浏览器缓存



### 19.什么场合适合用强缓存, 什么场合适合用协商缓存？

> 对于基本不常变化的资源，采用强制缓存的处理，设置 Cache-Control: max-age=xxx 一个比较大的数，让其从客户端缓存中获取.
>
> 对于变动更改频繁的文件，采取协议缓存的处理设置 Cache-Control: no-cache,通过 Etag 的值来判断当前缓存是否可用.



### 20.现已知 https 对前端性能影响很大, 如何提升其性能以减少 tls 层耗时？

HTTPS=HTTP over SSL (Http +SSL/TLS)

产生性能损耗的两个环节：

- TLS协议握手过程；
- 握手后的对称加密报文传输；

如何提升：

- 升级TLS：TLS1.3握手只需要1 RTT

- 硬件优化

- 协议优化：RSA的密钥交换算法不仅慢，安全性也不高，尽量选择ECDHE密钥交换；

- 对称加密算法优化：选用ARS-128-GCM密钥更短

  

### 21. HTTP 1.0 2.0 3.0

![img](https://img-blog.csdnimg.cn/cefbded175644c95b861c66bb0eb6d18.png)

#### HTTP 0.9

> 只有 GET 命令，TCP 建立链接后请求资源，协议规定只能返回 HTML 格式的字符串

#### HTTP 1.0

> - 可以发送任何格式的内容，包括图像，视频，二进制；
> - 引入 POST，HEAD 命令，丰富了 C/S 交互的手段；
> - HTTP 请求和响应的格式变了，除了数据部分，每次通信都必须包括头信息，用来描述元数据

> 缺点：每一个 TCP 请求只能发送一次请求，发送完数据就断开连接，需要获得其他数据必须新建 TCP 链接；

![img](https://img-blog.csdnimg.cn/f0cca5fab08e43d5a68a6876fd0cd413.png)

```http
GET /index.html

User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)

Accept: */*

响应：

HTTP/1.0 200 OK

Content-Type: text/plain

Content-Length: 137582

Expires: Thu, 05 Dec 1997 16:00:00 GMT

Last-Modified: Wed, 5 August 1996 15:55:28 GMT

Server: Apache 0.84

<html>   <body>Hello World</body> </html>

```

#### HTTP 1.1

> - 持久连接
> - 管道机制：同一个 TCP 连接里，客户端可以发送多个请求，进一步改进了 HTTP 协议的效率。
>
> 举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。

> 缺点：服务器处理响应是一个个处理的，容易发生队头堵塞的情况；
>
> 解决方案：
>
> 1. 减少请求数：合并 JS，CSS，雪碧图
> 2. 同时多开持久连接，资源放在多个域名下面；

#### HTTP 2.0

> 主要解决 1.1 版本对头阻塞的问题；
>
> - 二进制协议：http2 采用二进制传输数据，而非 1 版本的文本格式；请求响应数据被分割为二进制编码的帧；
>
>   将数据包切开成一片一片的，然后每一片可以乱序传输；浏览器接受到所有的片后，按照片所带的序号，整合为一个完整的数据包
>
>   ![img](https://img-blog.csdnimg.cn/40fd0ca5568d4a3a9e6eaf02342c036b.png)
>
> - 多路复用：所有的请求，都复用一个 tcp 连接
>
> - 头压缩：在同一个 HTTP 页面中，许多资源的 Header 是高度相似的，但是在 HTTP2 之前都是不会对其进行压缩的，这使得在多次传输中白白浪费了资源来进行重复无谓的操作
>
> - 服务器推送：
>
> - HTTP2 还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）

> 缺点：
>
> 1. 虽然解决了应用层的对头阻塞，但是没有解决传输层的对头组设；
> 2. 因为是基于 tcp，所以建立连接会经过三次握手四次挥手

#### HTTP 3.0

![img](https://img-blog.csdnimg.cn/0d1496da681c4828806f5e56a6e41ade.png)

> 基于 UDP 协议的“QUIC”协议。
>
> 通常来说 QUIC 是一种通用传输协议，与 TCP 非常相似。为什么要打造一套新的协议呢？这是因为现有的 TCP 协议扩展起来非常困难，因为已经有太多太多的设备使用了各种不同的 TCP 协议的版本，如果想直接在现有的 TCP 协议上进行扩展非常困难，因为需要给这么多台设备进行升级几乎是不可能完成的任务。
>
> 所以 QUIC 在选择在 UDP 协议之上进行构建。QUIC 使用 UDP，主要是因为希望能让 HTTP/3 更容易部署，因为它已经被互联网上的所有设备所知并已实现.
>
> QUIC 实际上就是在 UDP 的基础上重写了 TCP 功能，但是又比 TCP 更加智能；
>
> - 无需三次握手，四次挥手
> - 队头阻塞：UDP 是无序的，无需等待；

> 1. 使用 UDP 如何保证可靠性？
>
>    http 数据包中加入 packet header，实现了可靠连接。通过 packet number 来实现报文重传；
>
> 2. 没有了三次握手，四次挥手？
>
>    使用 1RTT 或者 0RTT，使用 DH 密钥交换算法；

![img](https://img-blog.csdnimg.cn/0a5f5340d6194e78b38bf09f11c73d27.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamF2YeiQjOaWsOWHjA==,size_20,color_FFFFFF,t_70,g_se,x_16)

https://blog.csdn.net/weixin_47667221/article/details/127861656?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-127861656-blog-123592573.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-127861656-blog-123592573.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=5

### 22.跨域问题

> 前后端分离的开发模式逐渐成为主流，这种模式下，前端和后端分别独立开发，前后端通信多为使用 Ajax 发送 HTTP 请求，然而，由于浏览器的安全策略限制，可能会出现跨域问题，导致请求失败；
>
> 跨域问题是指在 web 程序中，由于同源策略的限制导致浏览器无法发送跨域请求，也无法获取跨域响应的问题。同源策略是一种安全策略（会导致 CSRF），要求 web 应用程序只能访问与当前页面具有相同协议、主机名、端口号的资源；
>
> 如果需要访问不同源的资源，就会出现跨域问题；

#### 解决方案

- 浏览器插件
- web 服务器软件

Nginx 代理

```shell
location / {
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';

    if ($request_method = 'OPTIONS') {
        return 204;
    }
}

```

- 后端框架操作：通过 CORS 解决跨域，在响应头中添加

```
Access-Control-Allow-Origin:<origin>
```

前端即可通过 axios 跨域访问该 API

- 前端框架操作：proxy

```js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
      },
    },
  },
}
```

这样前端请求 '/api' 会被代理到 '[http://localhost:8080](http://localhost:8080/)',实现跨域。

### 23. Tree Shaking

> 当引入一个模块的时候，不引入这个模块的所有代码，只引入需要的代码。
>
> 这需要借助 webpack 的 Tree Shaking 功能实现；
>
> 本质就是消除无用的 JS 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）

在 Production 模式下不用在 webpack.config.js 中配置

```js
mode:"production",
optimization:{
usedExports:true,
}
```

在 Development 模式下配置时：

```js
//HtmlWebpackPlugin
//当我们整个打包过程结束的时候，自动生成一个html文件，
//并把打包生成的自动引入到html这个文件中；

var HtmlWebpackPlugin = require('html-webpack-plugin')
const path = require('path')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const webpack = require('webpack')
module.exports = {
  //打包模式，当为‘production’，打包后的文件会被压缩，
  //当为‘development’时打包后的文件不会被压缩,按照开发环境进行打包
  mode: 'development', //在开发者模式中SourceMap默认已经被配置在项目里了。
  // devtool: 'none', //关闭SourceMap
  //cheap：在生成SourceMap的时候，可以不带列信息，只带行信息,不要包含loader里面的SourceMap的生成，
  //只对业务代码进行SourceMap的生成
  //module:对loader里面的代码也进行一个SourceMap的生成
  //eval：eval是一种执行方式
  devtool: 'cheap-module-eval-source-map', //打开SourceMap
  // devtool: 'cheap-module-source-map', //要线上的代码可以映射
  // 打包的入口文件
  entry: './src/index2.js',
  // entry: {
  //     main: './src/index2.js'
  // },
  devServer: {
    contentBase: './dist', //我们要在哪一个目录下去启动这个服务器
    open: true, //会自动的打开一个浏览器，然后自动访问服务器的地址（localhost:8080）
    hot: true, //指是否支持热更新（hmr）
    hotOnly: true, //即使不支持hmr或者hmr有问题,也不刷新浏览器
    proxy: {
      '/api': {
        //当访问localhost:8080/api的时，它会直接帮你转发到http://localhost:3000
        target: 'http://localhost:3000',
        pathRewrite: { '^/api': '' },
      },
    },
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
      },
      {
        test: /\.(png|jpg|gif)$/,
        use: {
          loader: 'url-loader',
          options: {
            //url-loader会把图片转化成一个base64的字符串，
            //然后直接放到bundle.js里，而不是单独生成一个图片文件，
            //好处：不用再额外的请求图片的地址，省了一次http请求；
            //缺点：如果图片特别大过大，打包生成的js文件就会很大，
            //那么加载js文件的时间就会很长，所以在一开始很长的时间里，页面上什么都显示不出来；
            //所以，url-loader最佳的使用方式：加一个limit
            //如果图片小于limit的值就把图片变为一个base64的字符串放到打包好的js中，
            //若大于limit的值，就以file-loader的生成一个图片放到dist目录下。
            limit: 8192, //好处是可以对小图片的http请求数减少，提升网页加载数度
            name: 'images/[name].[hash].[ext]',
          },
        },
      },
      {
        test: /\.(css|scss|less)$/,

        //"css-loader":会帮我们分析出几个css文件之间的关系，最终把这些css文件合并成一段css;
        //"style-loader":会把‘css-loader’生成的内容挂在到页面的head部分
        //在webpack的配置中，loader是有先后执行顺序的，
        //loader的执行顺序是从下到上，从右到左；
        //“sass-loader”会先对sass代码进行翻译，翻译为css代码后给到css-loader,
        //都处理好了之后再交给‘style-loader’挂在到页面上
        //postcss-loader会自动添加css3的厂商前缀；比如：  transform: translate(100px, 100px)
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              importLoaders: 2,
              modules: true, //使得css模块化，
            },
          },
          'postcss-loader',
          'sass-loader',
        ],
      },
      {
        // 可以打包字体文件
        test: /\.(eot|ttf|svg)$/,
        use: {
          loader: 'file-loader',
        },
      },
    ],
  },

  // 打包的出口文件
  output: {
    // 打包后的文件名
    // filename: 'bundle.js',
    filename: '[name].js', //name就是entry值的key:'main','sub'
    // 打包后的文件目录为'dist'
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/', //表示的是我所有的打包生成的文件之间的引用前面都加一个根路径
  },
  //plugin可以在webpack运行到某个时刻的时候，帮你做一些事情(类似生命周期函数)
  plugins: [
    // CleanWebpackPlugin可以在每次打包的时候帮我们对dist目录做一个清空
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      //HtmlWebpackPlugin帮我们自动的生成一个dist目录下的html文件
      template: './src/index.html',
    }),
    //HotModuleReplacementPlugin帮我们实现HMR
    new webpack.HotModuleReplacementPlugin(),
  ],
  //在开发模式下配置 tree shakeing
  optimization: {
    usedExports: true,
  },
}
```

package.json

```json
{
  "name": "webpack-demo",
  //@babel/polyfill和css文件不使用tree shaking
  "sideEffects": ["@babel/polyfill", "*.css"],
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "bundle": "webpack",
    "watch": "webpack --watch",
    "start": "webpack-dev-server",
    "server": "node server.js"
  },
  "author": "susie",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.5.4",
    "@babel/plugin-transform-runtime": "^7.5.0",
    "@babel/preset-env": "^7.5.4",
    "@babel/preset-react": "^7.0.0",
    "autoprefixer": "^9.6.1",
    "babel-loader": "^8.0.6",
    "clean-webpack-plugin": "^3.0.0",
    "css-loader": "^3.0.0",
    "file-loader": "^4.0.0",
    "html-webpack-plugin": "^3.2.0",
    "node-sass": "^4.12.0",
    "postcss-loader": "^3.0.0",
    "sass-loader": "^7.1.0",
    "style-loader": "^0.23.1",
    "url-loader": "^2.0.1",
    "webpack": "^4.35.3",
    "webpack-cli": "^3.3.5",
    "webpack-dev-server": "^3.7.2"
  },
  "dependencies": {
    "@babel/polyfill": "^7.4.4",
    "@babel/runtime": "^7.5.4",
    "@babel/runtime-corejs2": "^7.5.4",
    "react": "^16.8.6",
    "react-dom": "^16.8.6"
  }
}
```

为什么某些引入模块不希望进行 Tree Shaking？

> 因为 css 模块如果使用 tree shaking，但是没有导出任何模块，就有可能被打包的时候 shake 掉。
>
> Tree shaking 只支持 ES Module

```json
{
  "sideEffects": ["*.css"]
}
```

### 24. 路由守卫

> 项目开发中，每一次页面的跳转或者刷新，都需要判断用户是否登录，后端会进行判断，前端最好也有判断。
>
> vue-router 提供了导航钩子，全局前置导航钩子 beforeEach 和全局后置导航钩子 afterEach，他们会判断路由即将改变前后及进行触发。判断用户登录与否要在 beforeEach 导航钩子判断

#### 参数

- to:即将进入的目标路由对象
- from：当前导航即将离开的路由对象
- next：调用该方法才能进入下一个钩子函数（afterEach）
  - next() //直接进入 to 路由
  - next（false) //中断当前路由
  - next('route') //跳转指定路由
  - next（‘error’） //跳转错误路由

#### 路由配置文件

```js
import Vue from 'vue'
import Router from 'vue-router'
import HelloWorld from '@/components/HelloWorld'
import HomePage from '@/pages/home.vue'
Vue.use(Router)
const router = new Router({
  routes: [
    {
      path: '/',
      name: 'HelloWorld',
      component: HelloWorld,
    },
    {
      path: '/home',
      name: 'home',
      component: HomePage,
    },
    {
      path: '*',
      redirect: '/home',
    },
  ],
})
router.beforeEach((to, from, next) => {
  console.log(to)
  console.log(from)
  next()
})
export default router
```

#### 开发实际应用

- 清除当前组件定时器

> 当一个组件中有一个定时器时, 在路由进行切换的时候, 可使用 beforeRouteLeave 将定时器进行清楚, 以免占用内存

```js
beforeRouteLeave (to, from, next) {
  window.clearInterval(this.timer) //清楚定时器
  next()
}

```

- **当页面中有未关闭的窗口, 或未保存的内容时, 阻止页面跳转**

```js
beforeRouteLeave (to, from, next) {
 //判断是否弹出框的状态和保存信息与否
 if (this.dialogVisibility === true) {
    this.dialogVisibility = false //关闭弹出框
    next(false) //回到当前页面, 阻止页面跳转
  }else if(this.saveMessage === false) {
    alert('请保存信息后退出!') //弹出警告
    next(false) //回到当前页面, 阻止页面跳转
  }else {
    next() //否则允许跳转
  }
}

```

- 保存相关内容到 Vuex 或 Session 中

```js
beforeRouteLeave (to, from, next) {
    localStorage.setItem(name, content); //保存到localStorage中
    next()
}

```

### 25. px,rpx,em,rem

- px

> 表示屏幕实际的像素点，不同设备上，px 会根据屏幕的分辨率进行换算，因此不同设备上的显示效果会有差异

- rpx

> 响应式像素：是微信小程序中引入的最小单位，用于适配不同尺寸的手机屏幕，换算规则：750rpx 等于屏幕宽度

- em

> 相对于父元素的字体大小的单位，如果父元素的字体大小为 16px，子元素设置 2em，则子元素字体大小将会是 32px

- rem

> 相对根元素的字体大小，与 em 类似，但是相对的是根元素即 html 字体大小。通常情况下开发者将根元素的字体大小设置为一个基准值，然后使用 rem 单位来表示其他元素的尺寸；

- vh、vw

> 相对于视口的高度和宽度

- pt

> 设备像素/设备独立像素

- ppi

> m 每英寸像素



### 26.如何判断一个变量是数组？各自原理讲一下，原型链讲一下

- Array.isArray
- Object.prototype.toString.call()



### 27.引用类型和基本类型的区别

#### 基本类型

1、基本类型有：`undefined / null / number / string / boolean / bigint / symbol`
2、基本类型数据放在栈内存中
3、基本类型数据是不可变的

#### 引用类型

1、引用类型有：`Object / Array / Function` 等，本质上都是属于 Object
2、引用类型以：`地址: 数据` 的映射关系来进行存储，其中地址放在`栈内存`，数据放在`堆内存`，若两个或 N 个变量指向同一个地址，则共用一份数据。
3、引用类型数据是可变的



### 28.原生js如何获取dom元素？如何监听dom元素全部加载出来？如何监听图片css也加载出来？

##### 获取DOM元素

- getElementById() 该方法返回一个DOM对象。
- getElementByClassName（）该方法返回一个集合。不能直接给集合绑定事件，需要获取到集合中的某一个元素，然后再为元素绑定事件。
- getElementByTagName() 该方法返回的也是一个集合。
- getElementByName() 只有含有name属性的元素(表单元素)才能通过name属性获取
- querySelector() 

注意：querySelector()和querySelectorAll()方法括号中的取值都是选择器，但从图中我们可以看出，两个方法是有区别的。当有多个class相同的元素时，使用querySelector()方法只能获取到第一个class为box的元素，而querySelectorAll()获取到了所有class为box的元素集合。


> - 所有获取DOM对象的方法中，只有getElementById()和querySelector()这两个方法直接返回的DOM对象本身，可直接为其绑定事件。
>
> - getElementXXX类型的方法，除了通过Id获取元素，其他都返回一个集合，如果需要取到具体的DOM元素，需要加索引，如：document.getElementsByClassName(“box”)[0] =>获取class为box的所有元素中的第一个DOM元素。
> - querySelector()与querySelectorAll()两者的联系与区别：
> - 联系： 两者括号中的取值都是选择器
> - 区别： 当有多个class相同的元素时，使用querySelector()方法只能获取到第一个class为box的元素，而querySelectorAll()获取到了所有class为box的元素集合。
> - 

### 29.元素垂直居中



### 30.设计模式

https://zhuanlan.zhihu.com/p/575645658

#### 创建模式（5种）

工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

##### 简单工厂





##### 工厂方法模式





### 31.v8垃圾回收



### 32.原生JS和vue的区别



### 33.虚拟DOM



### 34.如何更新虚拟DOM？



### 35.vuex介绍一下



### 36.怎么使用vuex？



### 37.项目用了什么缓存？



### 38.XSS、CSRF



### 39.文件上传实现



### 40.盒子的宽高



### 41. position属性



### 42. absolute relative相对于谁



### 43. flex



### 44.绘图功能做过嘛？画曲线的库有俩结果嘛？

#### 贝塞尔曲线

- 控制点

1. **控制点不总是在曲线上**这是非常正常的，稍后我们将看到曲线是如何构建的。
2. **曲线的阶次等于控制点的数量减一**。 对于两个点我们能得到一条线性曲线（直线），三个点 — 一条二阶曲线，四个点 — 一条三阶曲线。
3. **曲线总是在控制点的[凸包](https://en.wikipedia.org/wiki/Convex_hull)内部：*

![](https://s3.bmp.ovh/imgs/2024/03/12/e4c46e8b8a7c0b14.png)

- 数学：贝塞尔曲线可以使用数学方程式来描述

​	给定控制点 `Pi` 的坐标：第一个控制点的坐标为 `P1 = (x1, y1)`，第二个控制点的坐标为 `P2 = (x2, y2)`，以此类推，曲线坐标由方程式描述，这个方程式依赖属于区间 `[0,1]` 的参数 `t`。

![](https://s3.bmp.ovh/imgs/2024/03/12/233c01b12cd02d65.png)

1. 使用数学方程式。
2. 使用绘图过程：德卡斯特里奥算法

用途：

- 在计算机图形学，建模，矢量图形编辑器中。字体由贝塞尔曲线描述。
- 在 Web 开发中 — 用于 Canvas 上的图形和 SVG 格式。顺便说一下，上面的“实时”示例是用 SVG 编写的。它们实际上是一个 SVG 文档，被赋予不同的控制点做参数。你可以在单独的窗口中打开它并查源码：[demo.svg](https://zh.javascript.info/article/bezier-curve/demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1)。
- 在 CSS 动画中描述动画的路径和速度。





### 45.路由怎么做的？什么守卫？



## 算法

### 1.判断镜像二叉树



### 2.根据 vdom 实现渲染函数，有 tag，props，children 三属性，props 有 id，class 等；



### 3.三数之和(LeetCode 15)



### 4.单链表反转



### 5. 手写一个 EventEmitter class







# 阿里云

### 1.给出建议

> 1.学习React官网体系；
>
> 2.TS基础必备，提高可维护性，明确字段含义，便于维护；其他特性的使用；
>
> 3.工程化：webpack插件的使用，其他能力：sourceMap, treeShaking
>
> 4.开发技术广度；

### 2.算法题

> **//写一个方法，传入一个对象，输出对象的所有属性，以字典的顺序排序；**
>
> **//写一个函数，将一个深度嵌套的对象，将其扁平化，指定一个深度，扁平化到指定深度；**
>
> **//柯里化（我说我忘了换了下一题）**
>
> **//翻转链表：反转单向链表；**

- 数据拍平

```js
let obj = {
    Company: "xyz",
    Address: "aaa",
    contact: 0987654,
    mentor: {
        HTML: "A",
        CSS: "B",
        JavaScript: "C",
        Frame: {
            React: "D",
            Angular: "E",
            Vue: "F"
        }
    },
    abc: [1, 2, 3]
}
const flatten1 = (ob) => {
    let result = {}
    for (const key in ob) {
        if ((typeof ob[key]) === 'object' && !Array.isArray(ob[key])) {
            const temp = flatten1(ob[key])
            for (const subKey in temp) {
                result[subKey] = temp[subKey]
            }
        }
        else {
            result[key] = ob[key]
        }
    }
    return result
}

console.log("3", flatten1(obj))
```

- 柯里化

柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数的技术。这种技术通常用于创建一个参数接收器，或者用于提前确定某些参数。

```js
function curry (fn) {
    return function curried (...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args)
        } else {
            return function (...moreArgs) {
                return curried.apply(this, args.concat(moreArgs))
            }
        }
    }
}

// 使用 curry 函数的示例
function add (a, b) {
    return a + b
}

const curriedAdd = curry(add)
const add5 = curriedAdd(5)
console.log(add5(3))
console.log(curriedAdd(5, 3))
console.log(curriedAdd(5)(3))
```



### 3. webpack性能优化

#### Tree shaking

对代码中无用的代码进行去除。（限于function，class不行）
无用的代码有三种：

1. 无法到达的代码
2. 代码的执行结果用不到
3. 代码只会影响死变量（只写不读）

webpack处于生产模式的时候就会自动开启。

#### 优化loader编译范围

通过设置loader的对于哪些文件进行编译或者不对哪些文件进行编译（include，exclude）。
如：babel-loader处理js的ES6语法转换时比较耗时，如果减少文件的编译也会因此减少时间。

#### 压缩JS

webpack内置UglifyJS插件、ParallelUglifyPlugin插件

```js
const UgilyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');

module.exports = {
    plugins: [
        new UglifyJsPlugin({
            compress: {
                warnings: false, // 删除无用代码时不输出警告
                drop_console: true, // 删除所有console语句
                collapse_vars: true, // 内嵌已定义但只使用一次的变量
                reduce_vars: true // 提取使用多次但没定义的静态值到变量
            },
            output: {
                beautify: false, // 最紧凑的输出
                comments: false // 删除所有注释
            }
        })
    ]
}

```

#### 压缩css

css-loader?minimize、PurifyCSSPlugin插件

`css-loader`内置了`cssnano`，只需要使用`css-loader?minimize`就可以开启`cssnano`压缩。
另外一种压缩`CSS`的方式是使用`PurifyCSSPlugin`，需要配合`extract-text-webpack-plugin`使用，它主要的作用是可以去除没有用到的`CSS`代码。

#### 优化网络加速请求

`CDN`通过将资源部署到世界各地，使得用户可以就近访问资源，加快访问速度。要接入`CDN`，需要把网页的静态资源上传到`CDN`服务上，在访问这些资源时，使用`CDN`服务提供的`URL`。

#### 依赖公共代码提取



### 4. React性能优化有哪些方法？

https://blog.csdn.net/weixin_43484007/article/details/124366452

https://zhuanlan.zhihu.com/p/425635864?utm_id=0

> 父子组件重新渲染情况：
>
> - 从同一组件或父组件中调用setState时；
> - 从父级收到的prop的值发生变化；
> - 调用组件中的forceUpdate

#### 性能优化的三个方面

- 前端通用优化
- 减少不必要的组件更新：这类优化是在组件状态发生变更后，通过减少不必要的组件更新来实现，对应到 React 中就是：**减少渲染的节点 、降低组件渲染的复杂度、充分利用缓存避免重新渲染**（利用缓存可以考虑使用PureComponent、React.memo、hook函数useCallback、useMemo等方法）

> PureComponent 是对**类组件**的 Props 和 State 进行浅比较；React.memo 是对**函数组件**的 Props 进行浅比较

- 提交阶段优化：减少提交阶段耗时；

#### 前端通用优化

##### 组件按需加载

- 懒加载

从一个路由跳转到另一个路由，可用于用户操作后才展示的复杂组件；

主要是通过 Webpack 的动态导入和 `React.lazy` 方法。注意，实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。

```react
import { lazy, Suspense, Component } from "react"
import "./styles.css"

// 对加载失败进行容错处理
class ErrorBoundary extends Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    return { hasError: true }
  }

  render() {
    if (this.state.hasError) {
      return <h1>这里处理出错场景</h1>
    }

    return this.props.children
  }
}

const Comp = lazy(() => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        reject(new Error("模拟网络出错"))
      } else {
        resolve(import("./Component"))
      }
    }, 2000)
  })
})

export default function App() {
  return (
    <div className="App">
      <div style={{ marginBottom: 20 }}>
        实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。
      </div>
      <ErrorBoundary>
        <Suspense fallback="Loading...">
          <Comp />
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}
```



- 懒渲染

懒渲染指当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal/Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。

适用于：

1. 页面中多次出现的组件，且组件渲染费时、或者组件中含有接口请求。
2. 需要用户操作后才展示的组件。但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单。

- 虚拟列表

#### 批量更新

在React18中会有并发模式，在并发模式中，将默认以批量更新方式执行 setState。到那时候，或许就不需要这个优化了。



#### 利用debounce、throttle避免重复回调

在搜索组件中，当 input 中内容修改时就触发搜索回调。当组件能很快处理搜索结果时，用户不会感觉到输入延迟。但实际场景中，中后台应用的列表页非常复杂，组件对搜索结果的 Render 会造成页面卡顿，明显影响到用户的输入体验。

```react
import { useState, useEffect } from "react"
import { useDebounce } from "use-debounce"

export default function App() {
  const [text, setText] = useState("Hello")
  const [debouncedValue] = useDebounce(text, 300)

  useEffect(() => {
    // 根据 debouncedValue 进行搜索
  }, [debouncedValue])

  return (
    <div>
      <input
        defaultValue={"Hello"}
        onChange={e => {
          setText(e.target.value)
        }}
      />
      <p>Actual value: {text}</p>
      <p>Debounce value: {debouncedValue}</p>
    </div>
  )
}
```

##### 为什么搜索场景中使用debounce而不是throttle呢？

> **在搜索场景中，只需响应用户最后一次输入，无需响应用户的中间输入值，debounce 更适合使用在该场景中。而 throttle 更适合需要实时响应用户的场景中更适合，如通过拖拽调整尺寸或通过拖拽进行放大缩小（如：window 的 resize 事件）。实时响应用户操作场景中，如果回调耗时小，甚至可以用 requestAnimationFrame 代替 throttle。**

#### 缓存优化

缓存优化往往是最简单有效的优化方式，在 React 组件中常用 useMemo 缓存上次计算的结果。当 useMemo 的依赖未发生改变时，就不会触发重新计算。一般用在「计算派生状态的代码」非常耗时的场景中，如：遍历大列表做统计信息。



#### 跳过不必要的组件更新

##### PureComponent、React.memo

在React工作流中，如果只有父组件发生状态更新，即使父组件传给子组件的所有props都没有修改，也会引起子组件的Render过程。从 React 的声明式设计理念来看，如果子组件的 Props 和 State 都没有改变，那么其生成的 DOM 结构和副作用也不应该发生改变。当子组件符合声明式设计理念时，就可以忽略子组件本次的 Render 过程。

**PureComponent 是对类组件的 Props 和 State 进行浅比较，React.memo 是对函数组件的 Props 进行浅比较**。

##### ShouldComponentUpdate

##### useMemo、useCallback实现稳定的props值

如果传给子组件的派生状态或函数，每次都是新的引用，那么 PureComponent 和 React.memo 优化就会失效。所以需要使用 useMemo 和 useCallback 来生成稳定值，并结合 PureComponent 或 React.memo 避免子组件重新 Render。

> **拓展知识**
> useCallback 是「useMemo 的返回值为函数」时的特殊情况，是 React 提供的便捷方式。在 [React Server Hooks 代码](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fee432635724d5a50301448016caa137ac3c0a7a2%2Fpackages%2Freact-dom%2Fsrc%2Fserver%2FReactPartialRendererHooks.js%23L452) 中，useCallback 就是基于 useMemo 实现的。尽管 React Client Hooks 没有使用同一份代码，但 [useCallback](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fee432635724d5a50301448016caa137ac3c0a7a2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactFiberHooks.new.js%23L1590) 的代码逻辑和 [useMemo](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fee432635724d5a50301448016caa137ac3c0a7a2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactFiberHooks.new.js%23L1613) 的代码逻辑仍是一样的。

##### 使用发布者订阅者模式跳过中间组件Render过程

每次状态的更新都会涉及中间组件的 Render 过程，但中间组件并不关心该状态，它的 Render 过程只负责将该状态再传给子组件。在这种场景下可以将状态用发布者订阅者模式维护，只有关心该状态的组件才去订阅该状态，不再需要中间组件传递该状态。当状态更新时，发布者发布数据更新消息，只有订阅者组件才会触发 Render 过程，中间组件不再执行 Render 过程。

##### 列表项使用key属性

```jsx
<!-- 前一次 Render 结果 -->
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

<!-- 新的 Render 结果 -->
<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

使用key：

```jsx
<!-- 前一次 Render 结果 -->
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<!-- 新的 Render 结果 -->
<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

React Diff 算法会把 key 值为 2015 的虚拟 DOM 进行比较，发现 key 为 2015 的虚拟 DOM 没有发生修改，不用更新。同样，key 值为 2016 的虚拟 DOM 也不需要更新。结果就只需要创建 key 值为 2014 的虚拟 DOM。相比于不使用 key 的代码，使用 key 节省了两次 DOM 更新操作。

[React 官方推荐](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Freactjs.org%2Fdocs%2Flists-and-keys.html%23keys)将每项数据的 ID 作为组件的 key，以达到上述的优化目的。并且不推荐使用*每项的索引*作为 key，因为传索引作为 key 时，就会退化为不使用 key 时的代码。

> 是否在所有列表渲染的场景下，使用 ID 都优于使用索引呢？？
>
> 答案是否定的，在常见的分页列表中，第一页和第二页的列表项 ID 都是不同，假设每页展示三条数据，那么切换页面前后组件 Render 结果如下。
>
> ```jsx
> <!-- 第一页的列表项虚拟 DOM -->
> <li key="a">dataA</li>
> <li key="b">dataB</li>
> <li key="c">dataC</li>
> 
> <!-- 切换到第二页后的虚拟 DOM -->
> <li key="d">dataD</li>
> <li key="e">dataE</li>
> <li key="f">dataF</li>
> ```
>
> 切换到第二页后，由于所有 `<li>` 的 key 值不同，所以 Diff 算法会将第一页的所有 DOM 节点标记为删除，然后将第二页的所有 DOM 节点标记为新增。整个更新过程需要三次 DOM 删除、三次 DOM 创建。如果不使用 key，Diff 算法只会将三个 `<li>` 节点标记为更新，执行三次 DOM 更新。

##### useMemo返回虚拟DOM

利用 useMemo 可以缓存计算结果的特点，如果 useMemo 返回的是组件的虚拟 DOM，则将在 useMemo 依赖不变时，跳过组件的 Render 阶段。



该方式与 React.memo 类似，但与 React.memo 相比有以下优势：

1. 更方便。React.memo 需要对组件进行一次包装，生成新的组件。而 useMemo 只需在存在性能瓶颈的地方使用，不用修改组件。
2. 更灵活。useMemo 不用考虑组件的所有 Props，而只需考虑当前场景中用到的值，也可使用 [useDeepCompareMemo](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Fsandiiarov%2Fuse-deep-compare%23usedeepcomparememo) 对用到的值进行深比较。

```jsx
import { useEffect, useMemo, useState } from "react"
import "./styles.css"

const renderCntMap = {}

function Comp({ name }) {
  renderCntMap[name] = (renderCntMap[name] || 0) + 1
  return (
    <div>
      组件「{name}」 Render 次数：{renderCntMap[name]}
    </div>
  )
}

export default function App() {
  const setCnt = useState(0)[1]
  useEffect(() => {
    const timer = window.setInterval(() => {
      setCnt(v => v + 1)
    }, 1000)
    return () => clearInterval(timer)
  }, [setCnt])

  const comp = useMemo(() => {
    return <Comp name="使用 useMemo 作为 children" />
  }, [])

  return (
    <div className="App">
      <Comp name="直接作为 children" />
      {comp}
    </div>
  )
}
```

##### 避免创建不必要的外层元素标签

解决方式：使用 `<></>` 代替 `<div></div>`充当组件最外层元素标签



#### 提交阶段优化

React 工作流提交阶段的第二步就是执行提交阶段钩子，它们的执行会阻塞浏览器更新页面。如果在提交阶段钩子函数中更新组件 State，会再次触发组件的更新流程，造成两倍耗时。

##### 避免在didMount,didUpdate中更新组件state





### 5. 切片文件上传

- 监听输入框文件变化。
- 文件切片

> 1. 文件大小 1024 *1024 *5
> 2. chunkCount=Math.ceil(file.size/size)
> 3. 循环创建chunk
> 4. 切片信息：index、start、end、hash
>
> 问题：切片时间过长

- 创建chunk

![](https://s3.bmp.ovh/imgs/2024/03/25/6c81450091224d2e.png)

- 优化

计算MD5导致卡顿，效率低

开启多线程会存在结果顺序不对的问题，使用循环推入数组；返回；



### 6. SourceMap

https://blog.csdn.net/m0_67403076/article/details/124346503

https://zhuanlan.zhihu.com/p/475964893

Sourcemap（源代码映射）用于将生产环境中的压缩代码映射回原始的源代码。在前端开发过程中，JavaScript、CSS 和其他文件通常会被压缩和混淆，以减小文件大小和提高网站加载速度。然而，这会让调试和错误定位变得困难，因为生产环境中的代码难以阅读和理解。

简单来说，Sourcemap 就是一个信息文件，它里面存储着代码转换前后的对应位置信息，也就是转换压缩后的代码所对应的转换前的源代码位置，是源代码和生产代码的映射， Sourcemap 解决了在打包过程中，代码经过压缩，去空格以及 babel 编译转化后，由于代码之间差异性过大，debug 困难的问题

大家的项目在开发完进行build后，在打包文件夹里除了有js，css，图片等资源，一定还见过 .js.map文件，这种就是sourcemap文件.



### 7. Tree shaking

> 在前端的性能优化中，es6 推出了tree shaking机制，tree shaking就是当我们在项目中引入其他模块时，他会自动将我们用不到的代码，或者永远不会执行的代码摇掉，在Uglify阶段查出，不打包到bundle中。
>
> 只支持ES6 Module代码。在production 环境默认开启

#### 只支持ES Module的引入方式，不支持CommonJS

- ESM: export + import
- Common JS: module.exports + require

提示：如果想要做到tree shaking，在引入模块时就应该避免将全部引入，应该引入局部才可以触发tree shaking机制

```js
// Import everything (not tree-shaking)
import lodash from 'lodash';

// Import named export (can be tree-shaking)
import { debounce } from 'lodash';

// Import the item directly (can be tree-shaking)
import debounce from 'lodash/lib/debounce';
```



1. 项目描述具体说说
2. 先讲架构，更希望听到差距；维度：网状结构，项目体量，服务端了解；手动细节；css比较不熟悉，多学习；



# 淘天一面

### 1.介绍一下项目



### 2.项目有哪些难点？



### 3.项目相比于其他项目有哪些亮点？



### 4.怎样清除浮动？



### 5.元素垂直居中的方法，说出具体的数值

https://blog.csdn.net/qq_62799214/article/details/136385971

#### 定位+Margin

```css

.father{
            width: 400px;
            height: 400px;
            border: 1px solid;
            position: relative;
        }
.son{
            position: absolute;
            width: 200px;
            height: 200px;
            background-color: red;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            margin: auto;
        }

```

#### 定位+Transform

> 首先通过 top: 50%; left: 50%; 将元素的左上角移到其容器的中心，然后再通过 translate(-50%, -50%) 向左和向上移动元素的一半宽度和一半高度，以此达到完全居中的效果。

```css

.father{
            width: 400px;
            height: 400px;
            border: 1px solid;
            position: relative;
        }
.son{
            position: absolute;
            width: 200px;
            height: 200px;
            background-color: blue;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
        }
```

#### flex布局

```css

.father{
            display: flex;
            justify-content: center;
            align-items: center;
            width: 400px;
            height: 400px;
            border: 1px solid;
        }
.son{
            width: 200px;
            height: 200px;
            background-color: green;
        }
```

#### 其他

```css
      .parent {
            width: 400px;
            height: 400px;
            background-color: pink;
            display: flex;
            align-items: center;
        }

        .son {
            width: 100px;
            height: 100px;
            background-color: red;
            margin: 0 auto;
            text-align: center;
            line-height: 100px;
        }
```





### 6.盒模型



### 7.怎样实现一个两边栏固定宽度，中间自动填满的三分布局？

```css
    .parent {
            width: 100%;
            height: 100%;
            display: flex;
        }

        .son1 {
            width: 100px;
            background-color: aqua;
        }

        .son2 {
            width: 100%;
            background-color: red;
        }

        .son3 {
            width: 100px;
            background-color: blue;
        }
```



### 8.如何判断一个变量的类型？

type of、instance of、 constructor、 prototype(最好用)

#### type of

对一个值使用 typeof 操作符可能返回下列某个字符串，返回的类型都是字符串形式。

(1) undefined：如果这个值未定义

(2) boolean：如果这个值是布尔值

(3) string：如果这个值是字符串

(4) number：如果这个值是数值

(5) object：如果这个值是对象或null

(6) function：如果这个值是函数

> 需要注意：用typeof检测构造函数创建的Number，String，Boolean都返回object
> 基本数据类型中：null 。[引用数据类型](https://so.csdn.net/so/search?q=引用数据类型&spm=1001.2101.3001.7020)中的：Array，Object，Date，RegExp。不可以用typeof检测。都会返回小写的object

#### instance of

instanceof 运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的[原型链](https://so.csdn.net/so/search?q=原型链&spm=1001.2101.3001.7020)上。需要区分大小写。

用于判断一个变量是否某个对象的实例。

> 需要注意，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等。
>
> 判断它是否为字符串和数字时，只会返回false。
> null和undefined都返回了false，这是因为它们的类型就是自己本身，并不是Object创建出来它们，所以返回了false。

```js
function getTypeUsingInstanceof(variable) {
  if (variable instanceof Array) {
    return "array";
  } else if (variable instanceof Date) {
    return "date";
  } else if (variable instanceof RegExp) {
    return "regexp";
  } else if (variable instanceof Map) {
    return "map";
  } else if (variable instanceof Set) {
    return "set";
  } else {
    return typeof variable;
  }
}
```

#### constructor

constructor 属性返回对创建此对象的数组函数的引用。

在JavaScript中，每个具有原型的对象都会自动获得constructor属性。

```js
// String
var str = "字符串";
console.log(str.constructor); // function String() { [native code] }
console.log(str.constructor === String); // true
 
// Array
var arr = [1, 2, 3];
console.log(arr.constructor); // function Array() { [native code] }
console.log(arr.constructor === Array); // true
 
// Number
var num = 5;
console.log(num.constructor); // function Number() { [native code] }
console.log(num.constructor === Number); // true
```

#### prototype(最准确)

```js
function getTypeUsingObjectToString(variable) {
  return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
}

console.log(getTypeUsingObjectToString(42)); // "number"
console.log(getTypeUsingObjectToString("Hello")); // "string"
console.log(getTypeUsingObjectToString(true)); // "boolean"
console.log(getTypeUsingObjectToString([])); // "array"
console.log(getTypeUsingObjectToString({})); // "object"
console.log(getTypeUsingObjectToString(null)); // "null"
console.log(getTypeUsingObjectToString(undefined)); // "undefined"
console.log(getTypeUsingObjectToString(function() {})); // "function"
```

### 9. session,webStorage说一下有啥区别



### 10.介绍一下Promise



### 11.闭包有什么用？

> 函数嵌套函数，内部函数可以引用外部函数的参数和变量。参数和变量不会被[垃圾回收机制](https://so.csdn.net/so/search?q=垃圾回收机制&spm=1001.2101.3001.7020)收回。
>
> **闭包 （closure）是一个函数以及其捆绑的周边环境状态的引用的组合。简单说，闭包让开发者可以从内部函数访问外部函数的作用域。**

#### 作用

- 解决变量污染的问题，让变量被函数保护起来
- 可以延长变量的生命周期，让变量长期保存在内存中不被释放

> 垃圾回收机制：
>
> 1. 标记清除：js会对变量做一个标记yes or no的标签以供js引擎来处理，当变量在某个环境下被使用则标记为yes，当超出改环境（可以理解为超出作用域）则标记为no，然后对有no的标签进行释放
> 2. 引用计数：对于js中引用类型的变量, 采用引用计数的内存回收机制,当一个引用类型的变量赋值给另一个变量时, 引用计数会+1, 而当其中有一个变量不再等于值时,引用计数会-1, 如果引用计数为0, 则js引擎会将其释放掉。

- 作为私有成员，模拟Class的功能，只能在内部调用，不能被外部调用。

#### 应用

- 防抖

```js
//防抖 避免函数的重复调用 只会调用一次
        function Antishake(fn,wait){ //第一个参数是函数 第二个参数是毫秒值
            let timer = null //声明一个变量来接收延时器 初始值为null
            return function(){
                clearTimeout(timer)
                timer = setTimeout(() => {
                    fn() //调用这函数
                }, wait);
            }
        }
        let an = Antishake(function(){ //用一个变量接收
            console.log('555');
        },2000)
        document.querySelector('div').onmouseenter = ()=>{
            an() //调用一次
        }
```

- 节流

```js
function throttle(fn,wait){
            let timer = null //节点闸
            return function(){
                if(timer) return //null false 不是null结果减少true 如果上传没有我就直接跳过 没有人我就上去
                timer = setTimeout(() => { //上车了
                    fn()
                    timer = null //做完之后重新关闭节点闸
                }, wait);
            }
        }
        let throttle1 = throttle(()=>{
            console.log('我上车了');
        },2000)
        document.querySelector('div').onclick = ()=>{
            throttle1()
        }
```

- 函数柯里化





### 12.输入url到渲染的整个流程？

https://blog.csdn.net/loveX001/article/details/127158657?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-127158657-blog-78164238.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-127158657-blog-78164238.235%5Ev43%5Epc_blog_bottom_relevance_base6&utm_relevant_index=2

1. 解析URL：当用户在浏览器的地址栏输入URL后，浏览器会首先解析这个URL，判断其是否合法。

2. 查找缓存：浏览器会查看自己的缓存，判断是否有之前访问过的这个URL的缓存页面。如果有，那么浏览器会直接显示这个缓存页面，而不会再去服务器请求。这个过程非常快，所以用户会感觉到页面加载速度很快。(迭代递归)![img](https://img-blog.csdnimg.cn/img_convert/7e63b64e0f433042e9fa4cdca6eb9174.webp?x-oss-process=image/format,png)
3. DNS解析：如果浏览器缓存中没有找到对应的页面，那么浏览器会开始DNS解析过程，将URL中的域名解析成对应的IP地址。这个过程涉及到多个缓存层次，包括浏览器缓存、操作系统缓存、路由缓存、ISP的DNS服务器和根服务器。
4. 建立连接：当浏览器得到服务器IP地址后，会尝试与服务器建立TCP连接。这个过程涉及到三次握手，确保浏览器和服务器之间的连接是可靠的。
5. 发送HTTP请求：当TCP连接建立成功后，浏览器会向服务器发送HTTP请求，请求获取对应的网页内容。这个请求中会包含很多信息，比如请求头、请求体等。
6. 服务器处理请求：服务器收到浏览器的请求后，会处理这个请求，生成对应的HTML代码，并通过HTTP响应返回给浏览器。这个HTML代码可能还包含了一些嵌入的对象，比如CSS、JS、图片等。
7. 浏览器解析HTML：浏览器收到服务器的HTTP响应后，会开始解析这个HTML代码，将其转换成浏览器可以理解的页面结构。
8. 渲染页面：当浏览器解析完HTML代码后，会开始渲染页面。这个过程包括解析HTML中的标签，生成DOM树，解析CSS样式，生成CSSOM树，将DOM树和CSSOM树合并生成渲染树，然后遍历渲染树进行布局和绘制等。
9. 发送异步请求：在渲染页面的过程中，浏览器可能会发现页面中还包含一些异步请求，比如AJAX请求、图片加载等。这些请求会由浏览器单独发送，并在收到响应后更新页面的部分内容。

#### 浏览器缓存

- Service 
- （HTTP/2中的）

注意：输入网址之后，会查找内存缓存，没有再找硬盘，都没有就发生网络请求。

- 普通刷新（F5）：因为TAB没有关闭，所以内存缓存可用，如果匹配上会被优先使用，其次是磁盘缓存
- 强制刷新（Ctrl+F5）：浏览器不使用缓存，因此发送的请求头均带有Cache-control：no-cache,服务器直接返回200和最新内容。



### 13.浏览器怎么解析HTML文件生成DOM树的？



### 14.线上环境出错怎么解决？无法获取用户的报错信息。



### 15.设计一个数据库，大学生选课，老师也可以选择自己想上的课，怎么设计数据库的表？



### 16.XSS攻击如何防御？



### 17.重排和重绘

> 重排（回流）：
> 布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小
> 对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排
> 重绘：
> 计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制
> 对DOM的样式进行修改，如color等，浏览器不需要重新计算几何属性时，直接修改绘制元素的新样式，就是重绘

#### 重排

1 改变窗口大小：

        当用户调整浏览器窗口大小时，浏览器需要重新计算和调整页面布局，因此会触发重排。

2 改变字体大小：

        修改页面中文本的字体大小可能导致所有相关元素的重排。

3 改变元素的位置：

        通过修改元素的位置属性（例如position、top、left等）来移动元素会触发重排。

4 改变元素的尺寸：

        修改元素的宽度和高度，包括边距、填充和边框大小，都可能导致重排。

5 改变元素的内容：

        如果通过JavaScript动态添加或删除文档的内容，可能导致包含该内容的元素重排。

6 计算元素的尺寸或位置：

        当通过JavaScript访问offsetTop、offsetLeft、offsetWidth、offsetHeight等属性时，浏览器可能需要重新计算元素的位置和尺寸，从而触发重排。

7 更改字体：

        修改页面上的字体或字体相关属性可能导致浏览器重新计算文本的大小和布局，触发重排。

8 改变浏览器默认字体大小：

        在某些情况下，浏览器默认字体大小的改变可能会导致所有文本的重排。

9 激活CSS伪类：

        例如:hover、:active等伪类样式的激活可能会导致元素的重排。

10 修改表格布局：

        改变表格的列宽或行高会导致表格重新布局，从而触发重排。

11 更改浏览器窗口滚动位置：

        当用户滚动页面时，浏览器需要重新计算可视区域内元素的布局，可能触发重排。

12 改变浏览器的默认缩放级别：

        在某些情况下，浏览器的默认缩放级别的改变可能会导致重排。
#### 重绘

color、background 相关属性：background-color、background-image 等
outline 相关属性：outline-color、outline-width 、text-decoration
border-radius、visibility、box-shadow

# 咸鱼

### 1.async和await

#### async/await

> 为了解决Promise的问题，async，await在ES7被提出来了

```js
const fs=require('fs')
async function(){
    try{
        var f1=await readFileWithPromise('/etc/passwd')
         var f2=await readFileWithPromise('/etc/profile')
        
    }
    catch(err){
        console.log(err)
    }
}
```

特点：

- 异步async函数的调用，跟普通函数使用方式一样
- async的用法，作为一个关键字放在函数前面，变成了异步函数；
- 异步async函数返回一个promise对象
- async函数配合await使用可以阻塞代码，异步方法；

优点：

- 多个参数传递：promise使用then函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，频繁的解析又重新组合比较麻烦；而利用async和await可以没有这个限制，可以当做普通变量的局部变量来处理，也没有冗余工作；
- 同步和异步一起编写：使用promise的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰；async和await整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个promise对象放在await关键字后面；

- 对promise的优化：async和await是基于promise的，是进一步的一种优化。



### 2.讲讲对前端打包构建的理解



### 3.ES6语法、vue语法是怎么转换成JS文件的

https://blog.csdn.net/laplacepoisson/article/details/120984743

#### Vue-loader

##### vue-loader 是如何工作的?

vue-loader 的工作原理是

它会将 .vue 文件中的每个部分（template、script、style）提取出来，然后分别交给相应的 webpack loader 处理，例如 vue-template-loader、babel-loader、style-loader 等。

这样，每个部分都可以使用不同的语言或工具，例如在 template 中使用 Pug，在 script 中使用 TypeScript，在 style 中使用 Sass 等。

最后，vue-loader 会将这些处理后的部分重新组合成一个可以在浏览器中运行的 js 文件，其中包含了 Vue 组件的定义和渲染函数。

#### Babel-loader

##### 解析

当 Babel 接收到源代码时，将会调用一个叫做解析器的工具，用于将源代码转换为抽象语法树（AST）。在这个过程中，解析器会识别代码中的语法结构，并将其转换为对应的节点类型。
例如，当解析器遇到一个变量声明语句时，它将会创建一个 “VariableDeclaration” 节点，并将该节点的信息存储在 AST 中。AST 是一个以节点为基础组成的树形结构，每个节点都有相应的类型、属性和子节点等信息。

##### 转换

一旦 AST 被创建，Babel 将遍历整个树形结构，对每个节点进行转换。这些转换可以是插件、预设或手动创建的。转换器会检查 AST 中的每个节点，然后对其进行相应的修改或替换，以将新语法转换为旧语法。
例如，如果 Babel 遇到一个包含箭头函数的节点，而你已经启用了转换插件，该插件将会将箭头函数转换为其等效的体函数。代码转换后，Babel 将会生成一个新的 AST。

##### 生产

最后，Babel 将基于转换后的 AST 生成代码文本。在这个步骤中，Babel 将遍历转换后的 AST，并创建对应的代码字符串，并将这些字符串组合成一个完整的 JavaScript 文件。如果启用了代码压缩，Babel 还可以将生成的代码进行压缩。

总结来说，Babel 的原理就是将 JavaScript 源代码转换为抽象语法树（AST），然后对 AST 进行转换，生成与源代码功能相同但向后兼容的代码。Babel 提供了一个强大的生态系统，使得开发者可以轻松扩展并自定义转换器，实现自己的功能需求。

https://blog.csdn.net/formylovetm/article/details/126126060

### 4.防抖节流的实现和应用，解决了什么问题



### 5.算法：分组排序（见图）

![img](https://uploadfiles.nowcoder.com/images/20240328/91129783_1711628351297/750A124D2E86DD2E71CDF8B31774DCC8)

### 6.算法：区间覆盖

> 一次输入多个闭区间。例如输入【1，3】【2，5】【8，9】，输出【6，7】：一个闭区间使前面三个闭区间覆盖范围完整


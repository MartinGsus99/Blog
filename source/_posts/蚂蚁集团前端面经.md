# 蚂蚁集团前端面经

### 1.自我介绍



### 2. React



### 3. Webpack和Vite有什么区别？

- 开发模式不同

> *Webpack在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而Vite则采用了基于ES Module的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。*

- 打包效率不同

> *Webpack在打包时，会把所有的模块打包成一个bundle，这会导致初次加载速度较慢；而Vite则利用了浏览器对ES Module的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。*

- 插件生态不同

> *Webpack的插件生态非常丰富，有大量社区和官方插件可以选择，覆盖了前端开发的各个方面；而Vite的插件生态尽管在不断发展，但相比Webpack来说还显得较为稀少。*

- 配置复杂度不同

> *Webpack的配置相对复杂，对新手不够友好；而Vite在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。*

- 热更新机制不同

> *Webpack的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite的热更新则只会针对改动的模块进行更新，提高了更新速度。*



### 4. 使用React时遇到的难点？



### 5. 平时怎么学习前端？



### 6. 最近在看那方面的书？



### 7. http1.1和http2.0的区别

![img](https://img-blog.csdnimg.cn/cefbded175644c95b861c66bb0eb6d18.png)

#### HTTP 0.9

> 只有 GET 命令，TCP 建立链接后请求资源，协议规定只能返回 HTML 格式的字符串

#### HTTP 1.0

> - 可以发送任何格式的内容，包括图像，视频，二进制；
> - 引入 POST，HEAD 命令，丰富了 C/S 交互的手段；
> - HTTP 请求和响应的格式变了，除了数据部分，每次通信都必须包括头信息，用来描述元数据

> 缺点：每一个 TCP 请求只能发送一次请求，发送完数据就断开连接，需要获得其他数据必须新建 TCP 链接；

![img](https://img-blog.csdnimg.cn/f0cca5fab08e43d5a68a6876fd0cd413.png)

```http
GET /index.html

User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)

Accept: */*

响应：

HTTP/1.0 200 OK

Content-Type: text/plain

Content-Length: 137582

Expires: Thu, 05 Dec 1997 16:00:00 GMT

Last-Modified: Wed, 5 August 1996 15:55:28 GMT

Server: Apache 0.84

<html>   <body>Hello World</body> </html>

```

#### HTTP 1.1

> - 持久连接
> - 管道机制：同一个 TCP 连接里，客户端可以发送多个请求，进一步改进了 HTTP 协议的效率。
>
> 举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。

> 缺点：服务器处理响应是一个个处理的，容易发生队头堵塞的情况；
>
> 解决方案：
>
> 1. 减少请求数：合并 JS，CSS，雪碧图
> 2. 同时多开持久连接，资源放在多个域名下面；

#### HTTP 2.0

> 主要解决 1.1 版本对头阻塞的问题；
>
> - 二级制协议：http2 采用二进制传输数据，而非 1 版本的文本格式；请求响应数据被分割为二进制编码的帧；
>
>   将数据包切开成一片一片的，然后每一片可以乱序传输；浏览器接受到所有的片后，按照片所带的序号，整合为一个完整的数据包
>
>   ![img](https://img-blog.csdnimg.cn/40fd0ca5568d4a3a9e6eaf02342c036b.png)
>
> - 多路复用：所有的请求，都复用一个 tcp 连接
>
> - 头压缩：在同一个 HTTP 页面中，许多资源的 Header 是高度相似的，但是在 HTTP2 之前都是不会对其进行压缩的，这使得在多次传输中白白浪费了资源来进行重复无谓的操作
>
> - 服务器推送：
>
> - HTTP2 还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）

> 缺点：
>
> 1. 虽然解决了应用层的对头阻塞，但是没有解决传输层的对头组设；
> 2. 因为是基于 tcp，所以建立连接会经过三次握手四次挥手

#### HTTP 3.0

![img](https://img-blog.csdnimg.cn/0d1496da681c4828806f5e56a6e41ade.png)

> 基于 UDP 协议的“QUIC”协议。
>
> 通常来说 QUIC 是一种通用传输协议，与 TCP 非常相似。为什么要打造一套新的协议呢？这是因为现有的 TCP 协议扩展起来非常困难，因为已经有太多太多的设备使用了各种不同的 TCP 协议的版本，如果想直接在现有的 TCP 协议上进行扩展非常困难，因为需要给这么多台设备进行升级几乎是不可能完成的任务。
>
> 所以 QUIC 在选择在 UDP 协议之上进行构建。QUIC 使用 UDP，主要是因为希望能让 HTTP/3 更容易部署，因为它已经被互联网上的所有设备所知并已实现.
>
> QUIC 实际上就是在 UDP 的基础上重写了 TCP 功能，但是又比 TCP 更加智能；
>
> - 无需三次握手，四次挥手
> - 队头阻塞：UDP 是无序的，无需等待；

> 1. 使用 UDP 如何保证可靠性？
>
>    http 数据包中加入 packet header，实现了可靠连接。通过 packet number 来实现报文重传；
>
> 2. 没有了三次握手，四次挥手？
>
>    使用 1RTT 或者 0RTT，使用 DH 密钥交换算法；

![img](https://img-blog.csdnimg.cn/0a5f5340d6194e78b38bf09f11c73d27.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamF2YeiQjOaWsOWHjA==,size_20,color_FFFFFF,t_70,g_se,x_16)

https://blog.csdn.net/weixin_47667221/article/details/127861656?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-127861656-blog-123592573.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-127861656-blog-123592573.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=5

### 8. 垂直水平居中



### 9. 了解React数据流吗？Redux



### 10. Context



### 11. 最近关注的前端技术点？

- 微前端
- 3D Unity

### 12. 为什么选择前端？



### 13.前端领域有想做的方向吗？



### 14. React源码解读



### 15.仿写React的时候什么地方最难以理解？



### 16.接下来想研究什么方向？



### 17.进程和线程有什么区别？

线程是一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。进程是一个正在执行的程序的实例，包括程序计数器、寄存器和程序变量的当前值。

> - 进程依赖于程序运行而存在，进程是动态的，程序是静态的；
> - 进程是操作系统进行资源分配和调度的一个独立单位（CPU 除外，线程是处理器任务调度和执行的基本单位）；
> - 每个进程拥有独立的地址空间，地址空间包括代码区、数据区和堆栈区，进程之间的地址空间是隔离的，互不影响。

> 进程的创建、销毁与切换存在着较大的时空开销，因此人们急需一种轻型的进程技术来减少开销。在 80 年代，线程的概念开始出现，线程被设计成进程的一个执行路径，同一个进程中的线程共享进程的资源，因此系统对线程的调度所需的成本远远小于进程。

![img](https://pic1.zhimg.com/80/v2-579ef3f193e8027150590d7b9496e36c_720w.webp)

> - **本质区别：**进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
> - **包含关系：**一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
> - **资源开销：**每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
> - **影响关系：**一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。

https://zhuanlan.zhihu.com/p/519803985

https://zhuanlan.zhihu.com/p/556004836

### 18.数组和链表有什么区别？



### 19.图的遍历一般有哪两种算法？

- BFS/DFS

### 20.排序算法有哪些？时间复杂度低的是哪个？快排基准值的选择上有没有讲究？



### 21.三次握手



### 22.为什么要设计成三次握手？

双方证明自己可以正常发送和接收消息



### 23.TCP和UDP的区别是什么呢？



### 24.为什么UDP容易丢包？



### 25.TCP和UDP的使用场景有了解吗？



### 26. XSS和CSRF攻击



## React

### 1. React key有什么作用？



### 2. React Class组件和Function组件区别？



### 3. React组件通信方式



### 4. React useMemo vs useCallback



### 5. React useEffect vs useLayoutEffect





## VUE

### 1. Vue如何实现双向绑定的？



## 算法

### 1.根据表达式计算字母数量

> **描述**：输入一串字符串，根据字符串求出每个字母的数量并返回结果对象。（数字为1时可省略）
> **示例一**：输入：A3B2，输出：{"A": 3, "B": 2}
> **示例二**：输入：A(A(A2B)2)3C2，输出：{"A": 16, "B": 6, "C": 2}

### 2.手写节流

> **描述**：参数一：执行的函数，参数二：时间间隔。要求实现即使函数被连续处罚多次也只在连续时间内执行一次。

```js
function throttle(func, time) {
    let timeout;
    return function () {
        if (!timeout) {
            func.apply(this, arguments);
            timeout = setTimeout(() => {
                timeout = null;
            }, time);
        }
    };
}

```

### 3. 对象扁平化


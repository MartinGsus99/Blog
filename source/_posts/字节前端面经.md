---
title: 字节前端面经
date: 2023-12-12 21:13:45
categories:
  - 前端
tags:
  - JS
  - 笔记
  - TS
mp3:
cover: img/bg3.jpg
---

https://www.nowcoder.com/discuss/480837661645615104?sourceSSR=search

https://www.nowcoder.com/discuss/435136038420439040?sourceSSR=search

# 字节前端实习面经

## 一、三大件

### 1.场景题：CSS实现两个子元素2:1比例分割父元素。

```css
.parent {
  display: flex;
  flex-direction: row;
  background-color: aqua;
  width: 300px;
  height: 300px;
}

.son-2 {
  flex-grow: 2;
  border: 1px solid black;
}

.son-1 {
  flex-grow: 1;
  border: 1px solid black;
}

```

### 2. flex-grow  flex--shrink  flex-basis 具体都有什么用？

- `flex-grow` 属性定义了 Flex 子元素在容器中的增长比例。默认值为 0，表示子元素不会增长。如果所有子元素的 `flex-grow` 值都为 1，则它们将平均分配剩余的可用空间。如果一个子元素的 `flex-grow` 值为 2，而其他子元素的 `flex-grow` 值为 1，则前者将获得的增长空间是后者的两倍。
- `flex-shrink` 属性定义了 Flex 子元素在容器中的收缩比例。默认值为 1，表示子元素可以缩小。如果所有子元素的 `flex-shrink` 值都为 1，则它们将平均缩小以适应容器。如果一个子元素的 `flex-shrink` 值为 2，而其他子元素的 `flex-shrink` 值为 1，则前者在收缩时将缩小的比例是后者的两倍。
- `flex-basis` 属性定义了 Flex 子元素的基础大小。它指定了子元素在没有放大或缩小之前的初始大小。可以使用像素（px），百分比（%），或者其他长度单位来指定基础大小。默认值为 `auto`，表示子元素的基础大小由其内容决定。

### 3.重绘重排

重绘（Repaint）和重排（Reflow）是浏览器渲染页面时的两个关键过程。

- 重绘（Repaint）是指浏览器根据元素的样式属性进行绘制，例如颜色、背景、边框等。当元素的样式属性发生改变但不影响其布局时，浏览器只需进行重绘，而无需重新计算元素的位置和大小。
- 重排（Reflow）是指浏览器根据元素的布局属性重新计算元素的位置和大小，以适应页面的布局变化。当元素的布局属性发生改变时，浏览器需要进行重排，从而影响其他元素的位置和大小。

> 重绘和重排是相互依赖的过程，当发生重排时，必然会触发重绘。因此，过多的重绘和重排操作会导致性能下降，影响页面的响应速度和流畅度。

以下是一些常见导致重绘和重排的操作：

- 修改元素的样式属性，如颜色、背景、边框等。
- 修改元素的几何属性，如宽度、高度、位置等。
- 添加、删除、修改 DOM 节点。
- 修改页面的布局结构。

为了优化页面性能，可以采取以下方法：

- 尽量减少对样式和布局的频繁修改，合并多个修改操作，或使用 CSS 动画代替直接修改样式。
- 使用 CSS3 的 transform 属性来实现位移、缩放等变换，它只会触发重绘，不会触发重排。
- 使用文档片段（Document Fragment）来批量插入、删除 DOM 节点，减少重排的次数。
- 使用 CSS3 的动画和过渡效果，利用硬件加速，避免过多的重绘和重排。

### 4.怎么样利用合成来减少重绘重排？

https://www.nowcoder.com/discuss/518766195420540928?urlSource=sitemapApi

- 合并多次对DOM和样式的修改，最后一次处理掉；

```js
const el = document.getElementById('test');
el.style.cssText +='border-left: 1px; border-right: 2px; padding: 5px;';

const el = document.getElementById('test');
el.className += ' active'; 
```

- 批量修改DOM

当需要对DOM进行一系列的修改时，可以通过：

1.使元素脱离文档流；

2.对其进行多次修改；

3.将元素带回文档流；

三种方式脱离文档流：

1.隐藏元素，应用修改，重新显示；

2.使用文档片段在当前DOM之外构建一个子树，再拷贝回文档；

3.将原始元素拷贝到一个脱离文档的节点中，修改节点后再替换原始元素；



### 5.rem和em的区别

- 相对性质：rem是相对于根元素（通常是元素）的字体大小，而em是相对于父元素的字体大小。这意味着，如果你改变了根元素的字体大小，所有使用rem单位的元素都将相应地调整大小。而对于使用em单位的元素，只有当其父元素的字体大小改变时，它们的大小才会改变。利用这个性质可以结合响应式设计思考。
- 计算方式：rem单位的大小是相对于根元素的字体大小的倍数，而em单位的大小是相对于父元素的字体大小的倍数。因此，使用rem单位进行单位换算时，只需要知道根元素的字体大小即可。而使用em单位时，需要逐级计算每个父元素的字体大小。
- 简洁性和可维护性：使用rem单位可以简化样式表的编写，因为只需要设置根元素的字体大小，其他元素的大小都可以使用rem单位进行计算。这使得页面的维护更加方便。而使用em单位时，需要逐级设置每个父元素的字体大小，这可能会增加维护的复杂性。
- 响应式设计：由于rem单位的相对性质是固定的，因此在实现响应式设计方面，rem单位具有更大的优势。只需要在根元素上设置字体大小，就可以影响整个页面的尺寸。而em单位则需要考虑父元素的字体大小，这在实现响应式设计时可能会更加复杂。
- 兼容性：rem单位在一些旧版本的浏览器中不被支持，而em单位在所有浏览器中都被支持。因此，在使用rem单位时，需要考虑浏览器的兼容性。

### 6.px,rpx区别

1. px（像素）：是最常见的单位，它表示屏幕上的实际像素点。在不同设备上，px 会根据屏幕的分辨率进行换算，因此在不同设备上显示效果可能会有差异。

2. rpx（响应式像素）：是微信小程序中引入的单位，主要用于适配不同尺寸的手机屏幕。rpx 的换算规则是 750rpx 等于屏幕宽度，因此可以通过设置不同尺寸下的 rpx 值来实现适配效果。

3. em：是相对于父元素的字体大小的单位。如果父元素的字体大小为 16px，子元素设置 2em，则子元素的字体大小将会是 32px。
4. rem（相对于根元素的字体大小）：与 em 类似，但是相对的是根元素（即 html 元素）的字体大小。通常情况下，开发者会将根元素的字体大小设置为一个基准值，然后使用 rem 单位来表示其他元素的尺寸。这样可以方便地调整整个页面的比例。

### 7.vh、vw

将屏幕宽高各分为100份，100vh为屏幕高度，100vw为屏幕宽度。

##### vh、vw、%的区别

- vh、vw是相对于屏幕可视窗口确定的，%是相对于父级元素确定的。
- vh、vw 设置宽高是有真实高度的，但%不是



### 8.如何去除浮动？

**浮动的元素会脱离标准流（文档流），浮动的盒子不再保留原先的位置**

**清除浮动的本质就是清除浮动元素带来的影响，策略——闭合浮动**

#### 为什么要清除浮动？

> 在实际开发中，一般都不给父盒子设定高度，让子盒子撑开父盒子，
>
> 但是不给父盒子高度，子盒子浮动后，父盒子高度就会为0，
>
> 则会影响后面的标准流排版，所以就需要清除浮动

- 额外标签法

> 额外标签法是在浮动元素的末尾添加一个空标签，例如<div>标签
>
> 优点：通俗易懂
>
> 缺点：添加无意义的标签，代码结构化差
>
> 注意：添加的空标签必须是块级元素，不能是行内元素

- 父级添加overflow方法

>  可以通过触发BFC的方式，实现清楚浮动效果。必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度
>
> **优点：** 简单、代码少、浏览器支持好
>
> **缺点：** 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。不能和position配合使用，因为超出的尺寸的会被隐藏。

- 使用伪元素清除浮动

>  :after方式为空元素的升级版，好处是不用单独加标签了。IE8以上和非IE浏览器才支持:after，，zoom(IE专有属性)可解决ie6,ie7浮动问题（较常用推荐）
>
> 优点： 符合闭合浮动思想，结构语义化正确，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）
>
> 缺点： 由于IE6-7不支持：after，使用zoom：1
>

- **使用before和after双伪元素清除浮动：**（`较常用推荐`）

```html
<style>
            .father{
                border: 1px solid black;
                *zoom: 1;
            }
            .clearfix:after,
    		.clearfix:before{
                   content: "";
                   display: block;
                   clear: both;
               }
               .big ,.small{
                width: 200px;
                height: 200px;
                float: left;
               }
               .big{
                background-color: red;
               }
               .small{
                background-color: blue;
               }
</style>

   <div class="father clearfix">
        <div class="big">big</div>
        <div class="small">small</div>
   </div>
    <div class="footer"></div>

</div>
              

```



## 二、JS

### 1.ES6的新特性

https://blog.csdn.net/ZLJ_999/article/details/124122540

### (1)let const var

- var 声明变量会存在变量提升，let和const不存在变量提升；
- let const 只能在块级作用域访问；
- 同一作用域下let和const不能声明同名变量，var可以；
- const 定义常量，不能修改，但是可以修改对象属性；

### (2)symbol

> symbol为ES6中的新的基本数据类型，表示独一无二的数，不能与其他数据类型进行运算；

```js
const a = Symbol();
const b = Symbol();

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/b6619bbd2c6a476ab9f3b7c20141358b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAYWRtaW5femxq,size_20,color_FFFFFF,t_70,g_se,x_16)

### (3)模板字符串

```js
${}
(``)

<script>
      url="xxxxxx"
       // es6之前
       let html="<div>"+
                  " <a>"+url+"</a>"+
               "</div>";
		//es6
       let eshtml=`<div>
                   <a>${url}</a>
               </div>`
</script>

```

### (4)解构表达式

- 数组结解构

```js
let [a,b,c]=[1,2,3]
console.log(a,b,c)   // 1 2 3

let [a,b,c]=[1,,3]
console.log(a,b,c)  //1 undefine 3

let [a,,b]=[1,2,3]
console.log(a,b)    //1,3

let [a,..b]=[1,2,3]
console.log(a,b)    //1,[2,3]
```

- 对象解构

```js
let obj={
    name:'ren',
    age:12,
    sex:'male'
}

let {name,age,sex}=obj;
console.log(name,age,sex)   //ren 12 male

let {
    name:myName,
    age:myAge,
    sex:mySex
}=obj;
console.log(myName,myAge,mySex)   //ren 12 male
```

### (5)对象方面

> Map()和Set()属于es6新增加的对象

- Map()

```js
let myMap=new Map([['name','ren'],['age',12]])
console.log(myMap)

myMap.set('sex','male')
console.log(myMap.size)
myMap.get('name')
myMap.has('age')
myMap.delete('age')

```

- Set()

```js
let mySet=new Set([1,2,3])
cosole.log(mySet)

mySet.add(4)
console.log(mySet)

mySet.delete(1)
mySet.has(1)
```

### (6)数组的新方法

- Array.from()

> 可以将可迭代的对象转换为新的数组
>
> - 函数可接受3个参数（后两个参数可以没有）：
>   - 第一个表示将被转换的可迭代对象(如果只有一个参数就是把形参转变成数组)
>   - 第二个是回调函数，将对每个数组元素应用该回调函数，然后返回新的值到新数组，
>   - 第三个是回调函数内this的指向。

```js
let arr=[1,2,3]
let obj={
    double(n){
        return n*2
    }
}

Array.from(arr,function(n){
    return this.double(n)
},obj)
```



- includes()

> 查看数组中是否有这个元素，存在就返回true，不存在返回false

```js
let arr=[1,33,44,22,6,9]
let arr=arr.includes(22)  //true

```



- map(),filter()

> map利用原数组经过运算或者从对象数组中取某属性
>
> filter将符合挑选得筛选出来成为新的数组；

```js
let arr=[1,2,3,4,5]

let newArr=arr.map((v)=>v*2)
let newArr1=arr.filter((v)=>v>10)
```



- forEach()

> forEach()循环遍历数组得每一项，没有返回值
>
> find()查找数组中符合条件得第一个元素返回

```js
let arr=[1,2,3,4]
let res=[]

arr.forEach((v,i)=>{
    if(v>10){
        res.push(arr[i])
    }
})

let a2=arr.find((v)=>v>10)
```



- some(),every()

> some()数组中某一个符合就返回true；
>
> every()每一个都符合才返回true；

### 2.异步编程解决方案Promise

- Promise时异步编程的解决方案，比较传统的回调函数和事件更加合理强大；
- 一个用来保存某个未来才会结束的事件；

> Promise对象有以下两个特点：
>
> （1）对象的状态不受外界影响，Promise对象代表一个异步操作，有三种状态：
>
> pending（进行中）、fulfilled（已成功）、rejected（已失败）只有异步操作的结果才能决定状态；
>
> （2）一旦状态改变，不会再变。Promise对象的状态改变只有：pending->fulfilled，pending->rejected
>
> 状态凝固了就是resolved。如果改变已经发生了，再对Promise对象添加回调函数，也会立即得到结果；这与事件不同，事件一旦错过就不再获得结果；
>
> 缺点：
>
> 无法取消Promise，一旦新建就会立即执行，无法中途取消；
>
> 不设置回调函数，Promise内部抛出的错误不会反映到外部；
>
> 当处于pending状态时，无法得知目前进展到哪一个阶段；

```js
//promise构造函数接受一个函数作为参数，该函数的两个参数分别为resolve和reject
//resolve函数是将Promise对象的状态从未完成变成成功；pending->resolved，异步操作成功时调用并将异步操作的结果作为参数传递出去；
//reject函数时将promise对象的状态从未完成变成失败，pending->rejected，异步操作错误时将报错错位参数传递出去；
promise.then(function(valueA){
    
},function(error){
    
})

```

- promise.prototype.then(参数1，参数2)

```js
//Promise实例具有then方法，定义在原型对象上，作为Promise实例添加状态改变时的回调函数；
//可以采用链式写法
getJSON("url").then((res)=>{
    
}).then((error)=>{
    
})
```

- promise.prototype.catch()

```js
//是then的别名，用于指定发生错误时的回调函数
getJson().then((res)=>{
    
}).catch((error)=>{
    console.log(error);
})
```

- promise.prototype.finally()

```js
getJson().then((res)=>{
    
}).catch((error)=>{
    console.log(error);
}).finally(()=>{
    //最后一定执行
})
```

- promise.all()

```js
//用于将多个promise实例，包装成一个新的promise实例
const p=Promise.all([p1,p2,p3]);

//只有p123的状态都称为fulfiled p才会成功；任一个rejected p也会；
const databasePromise = connectDatabase();

const booksPromise = databasePromise
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) => pickTopRecommendations(books, user));
```

- Promise.race():多个实例任一成功都会返回成功；

```js
Promise.resolve().then(()=>{
    console.log(0)
    return Promise.resolve(4)
}).then((res)=>{
    console.log(res)
})


```

### 3.事件循环

> Event Loop 即事件循环， 是JavaScript或Node为解决单线程代码执行不阻塞主进程一种机制，也就是我们所说的异步原理。
>
> 事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。

### 4.Promise实现一个超时请求控制（race）









### 5.Promise.all  Promise.race手写一下













### 6.js为什么是单线程？单线程有什么弊端？js如何解决这些弊端的？

- 取决于它的用途，js作为浏览器得脚本语言，主要用途是与用户交互和操作DOM；如果JS是多线程，那么多个线程修改同一个DOM会出现冲突；
- 利：代码依次执行，确保了事件执行的稳定性，不会产生多线程冲突；
- 弊：遇到耗时任务，比如IO，网络请求会造成阻塞，影响后续代码的执行；
- 阻塞问题：通过EventLoop来处理不同类型的任务，常用的promise，async/await即为其思想的实践；
- 效率问题：webWorker，可以开启新的线程进行工作，但是会有限制不能操作DOM，适用于计算量大的情况；

> JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
>
> 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
>

### 7.setTimeout()事件队列问题

```js
setTimeout(() => {
  console.log(1);
}, 0)
new Promise(function(resolve){
  console.log(2);
  for(let i = 0; i < 10000; i++){
    if(i == 9999){
      resolve()
    }
  }
  console.log(3);
}).then(() => {
  console.log(4);
})
console.log(5);

//2 3 5 4 1

```

```js
console.log(1);

setTimeout(() => {
   
  console.log(2);
  Promise.resolve().then(() => {
   
    console.log(3)
  });
});

new Promise((resolve, reject) => {
   
  console.log(4)
  resolve(5)
}).then((data) => {
   
  console.log(data);
})

setTimeout(() => {
   
  console.log(6);
})

console.log(7);
复制代码

```

https://www.cnblogs.com/smile-fanyin/p/14622432.html

首先执行scrip代码，打印出1；
遇到第一个定时器setTimeout，将其加入到宏任务队列；
遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；
遇到第二个定时器setTimeout，将其加入到红任务队列；
执行script代码，打印出7，至此第一轮执行完成；
指定微任务队列中的代码，打印出resolve的结果：5；
执行宏任务中的第一个定时器setTimeout，首先打印出



2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；
执行完这个宏任务，就开始执行微任务队列，打印出3；
继续执行宏任务队列中的第二个定时器，打印出6。

### 8.js数据类型、判断类型的方法

```js
   typeof，instanceof，Objectprototype.toString.call()，根据consturctor（注意null和undefined没有constructor）
```



### 9.call、apply、bind方法

> call,apply,bind都是用来改变this指向的；

```js
var year = 2021
function getDate(month, day) {
  return this.year + '-' + month + '-' + day
}

let obj = {year: 2022}
getDate.call(null, 3, 8)    //2021-3-8
getDate.call(obj, 3, 8)     //2022-3-8
getDate.apply(obj, [6, 8])  //2022-6-8
getDate.bind(obj)(3, 8)     //2022-3-8

```

### Call（）方法

##### call和apply

> call方法接受的语法和作用与apply()方法类似，只有一个区别就是call（）接受的是一个参数列表，而apply方法接受的是一个包含多个参数的数组；
>
> 两个都是函数对象Function的方法，且第一个参数都是要绑定对象的上下文；

```js
let obj = {
    a: 1,
    get: function () {
        return 2
    }
}

let g = obj.get
g.call({}, 1, 2, 3)
g.apply({}, [1, 2, 3])
```

##### call方法调用父结构函数

```js
//调用父构造函数的call方法来实现继承
function Product (name, price) {
    this.name = name
    this.price = price
}

function Food (name, price) {
    Product.call(this.name, toy)
    this.category = 'food'
}

function Toy (name, price) {
    Product.call(this, name, price)
    this.catrgory = 'toy'
}

let cheese = new Food('cheese', 10)
let car = new Toy('car', 100)
```

##### call方法调用匿名函数

```js

const animals = [
    {
        species: 'cat',
        name: 'Tom'
    },
    {
        species: 'dog',
        name: 'Jen'
    }
]

for (let i = 0; i < animals.length; i++) {
    (function (i) {
        this.print = function () {
            console.log('#' + i + ' ' + this.species + ' ' + this.name)
        }
        this.print()
    }).call(animals[i], i) //调用匿名函数
}
```

##### call方法调用函数并且指定上下文this

```js
var obj = {
    animal: 'cats', sleepDuration: '12 and 16 hours'
};

function greet(){
    var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');
    console.log(reply);
}

greet.call(obj);  //"cats typically sleep between 12 and 16 hours"

```

##### call方法调用函数并且不指定第一个参数

> this的值会被绑定为全局对象；
>
> 严格模式下，this的值将会是undefined；

### apply（）方法

> 使用apply我们可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法；

##### apply方法调用一个具有给定this的函数，以及一个数组的形式提供参数

```js

var array = ['marshall', 'eminem']
var elements = [1, 2, 3]
array.push.apply(array, elements)
console.log(array)
```

##### 使用apply和内置函数

```js
//对于需要使用玄幻遍历数组的需求，可以使用apply完成避免循环
let nums = [3, 12, 31, 24, 1, 25, 1]
let max = Math.max.apply(null, nums)
let min = Math.min.apply(null, nums)
console.log(max, min)
```

> 上边这种调用apply的方法，有超出JavaScript引擎参数长度上限的风险。
> 如果我们的参数数组非常大，推荐使用下边这种混合策略：**将数组切块后循环传入目标方法**

```js
function minOfArray(arr) {
    var min = Infinity;
    var QUANTUM = 32768;
  
    for (var i = 0, len = arr.length; i < len; i += QUANTUM) {
      var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len)));
      min = Math.min(submin, min);
    }
  
    return min;
  }
  
  var min = minOfArray([5, 6, 2, 3, 7]);

```

##### apply和call的实现

```js
// call和apply实现方式类似，只是传参的区别
// 基本思想是把fn.call(obj,args)中的fn赋值为obj的属性，然后调用obj.fn即可实现fn中this指向的改变
Function.prototype.myCall = function(context = window){ //myCall函数的参数，没有传参默认是指向window
  context.fn = this //为对象添加方法（this指向调用myCall的函数）
  let args = [...arguments].slice(1) // 剩余的参数
  let res = context.fn(...args)  // 调用该方法，该方法this指向context
  delete context.fn //删除添加的方法
  return res
}

Function.prototype.myApply = function(context = window){ //myCall函数的参数，没有传参默认是指向window
  context.fn = this //为对象添加方法（this指向调用myCall的函数）
  let res
  if(arguments[1]){ //判断是否有第二个参数
    res = context.fn(...arguments[1])// 调用该方法，该方法this指向context
  }else{
    res = context.fn()// 调用该方法，该方法this指向context
  }
  delete context.fn //删除添加的方法
  return res
}

// 验证
function sayName(name= 'wwx',age= 18){
  this.name = name
  this.age = age
  console.log(this.name)
  return this.age
}
var obj = {
  name : 'zcf',
  age:24
}
var age = sayName.myCall(obj,"wxxka",19) // 19
var age1 = sayName.myApply(obj,["wwxSSS",20]) //20

```

### bind（）方法

> bind函数会创建一个新的绑定函数，这个绑定函数包装了原函数的对象，调用绑定函数通常会执行包装函数；
>
> 绑定函数内部属性;
>
> 1. 包装的函数对象
> 2. 在调用包装函数时始终作为this传递的值
> 3. 在对包装函数做任何调用时都会有限用列表原始填充参数列表

```js
this.x = 9 //this指向全局window对象

console.log(this.x)  //9
let mymodule = {
    x: 81,
    getX: function () {
        return this.x
    }
}

console.log(mymodule.getX())  //81

let retrieveX = mymodule.getX
console.log(retrieveX())   // 9 函数在全局作用域调用

//创建一个新函数，将this绑定到module对象

let boundGetX = retrieveX.bind(mymodule)
console.log(boundGetX());

```

##### bind传递参数问题

通过bind改变this指向的时候所传入的参数会拼接在调用返回函数所传参数之前，多余参数不起作用；

https://blog.csdn.net/qq_43000315/article/details/125360096







### 10.为什么不使用toString而是Object.prototype.toString

https://blog.csdn.net/weixin_30402343/article/details/96598949





### 11.js的基础类型，堆内存和栈内存

- 基本数据类型（原始值）：

  Number（数值，包含NaN）
  String（字符串）
  Boolean（布尔值）
  Undefined（未定义/未初始化）
  Null（空对象）
  Symbol（独一无二的值，ES6 新增）

  > 注意， Symbol() 函数的参数只有描述作用，即使两个 Symbol() 函数的参数相同 ，它们的返回值也是不相等的。

  BigInt （大整数，能够表示超过 Number 类型大小限制的整数，ES 2020新增）

- 引用数据类型（引用值）：

  Object（对象。Array/数组 和 function/函数 也属于对象的一种）

### 12.垃圾回收机制



### 13.js字符串转number ，number转字符串

```
toString()
String
parseInt()
&{}
```



##   三、CSS

### 1.如何实现一个圆？

##### css

```css
.circle {
  background-color: aquamarine;
  width: 100px;
  height: 100px;
  border-radius: 50%;
}

```

##### svg

```html
     <svg viewBox="0 0 80 80" width="80" height="80">
            <circle class="circle-svg" cx="40" cy="40" r="38" />
        </svg>
```

#### clip-path

```css

.clip-path {
  background: #456bd9;
  clip-path: circle(50%);
  height: 5em;
  width: 5em;
}

```

##### dadial-gradient

```css
.circle {
  background-image: radial-gradient(circle, #456BD9, #456BD9 66%, transparent 66%);
  height: 5em;
  width: 5em;
}
```



### 2.元素垂直水平居中的方法

##### flex

```html
<body>
<div id="parent">
    <div id="children"></div>
</div>
<style>
    body{
        margin: 0;
        padding: 0;
    }
    #parent{
        display: flex;
        justify-content: center;
        align-items: center;
        width: 500px;
        height: 500px;
        background-color: #999;
    }
    #children{
        width: 50px;
        height: 50px;
        background-color: red;
    }
</style>
</body>

```

##### 使用transform将元素进行移动，必要时可将margin设为负

```html
<style>
    body{
        margin: 0;
        padding: 0;
    }
    #parent{
        width: 500px;
        height: 500px;
        background-color: #999;
    }
    #children{
        width: 50px;
        height: 50px;
        background-color: red;
        transform: translate(225px,225px);
    }
</style>
```



### 3.讲讲flex属性



### 4.H5中的块元素和行内块元素

##### 块级元素

- 独占一行
- 默认宽度100%
- 默认高度由内容撑开
- 可以设置高度和宽度
- html、body、div、p、h1-h6、ul、li、

##### 行内元素

- 填充网页内容
- 高度由自身决定
- 可以和其他行内元素共享一行
- 不可以设置高度和宽度
- span、a、em、i、strong、img



### 5.css优先级

> 内联样式>内部样式》外部样式
>
> **!important > 内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器 > 通配选择器 > 浏览器默认样式**
>
> 如果两组样式具有相同的优先级，则后定义的样式将覆盖先定义的样式。
>
> 浏览器默认样式是指浏览器在渲染 HTML 文档时，为每个 HTML 元素设置的默认样式。这些默认样式取决于浏览器的版本和类型，并且可能会因浏览器之间的差异而产生不一致。为了保证页面的一致性，通常会采用 CSS reset 或 normalize.css 这样的技术来重置浏览器的默认样式。
> 
>

示例：

- 内联样式：写在标签属性 style 的样式，如 <span style="color:green">

- ID 选择器，如 #id{…}
- 类选择器，如 .class{…}
- 属性选择器，如 p[type="email"]{…}
- 伪类选择器，如 input:hover{…}
- 标签选择器，如 div{…}
- 伪元素选择器，如 span::before{…}
- 通配选择器，如 *{…}

Note:

​    \1. !important写在属性值的后面，分号的前面！

​    \2. !important不能提升继承的优先级，只要是继承优先级最低！

​    \3. 实际开发中不建议使用 !important 。

##### 权重叠加计算

![img](https://img-blog.csdnimg.cn/ebd1b86a59994e2aac6ef3d2c0c5be24.jpeg)

https://blog.csdn.net/giegie0506/article/details/129969357?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-129969357-blog-129007183.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-129969357-blog-129007183.235%5Ev43%5Epc_blog_bottom_relevance_base6&utm_relevant_index=5

### 6. css选择器，选择div下的第二个p该怎么做

```css
   div p:nth-child(2)
```

### 7.css实现文本溢出省略号

```css
 overflow:hiddren
 text-overflow:ellipsis
```



## 四、框架

### 1.Vue双向绑定的原理说一下。

> vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

https://www.cnblogs.com/qianxiaox/p/14119940.html

### 2.响应式原理详细说一下，Vue2的响应式有什么问题？

> 在Vue 2中，响应式是**通过使用Object.defineProperty()方法来实现的**。
> 在组件实例化过程中，Vue会对数据对象（data）进行**递归地遍历**，将**每个属性都转换为getter/setter**，并且为每个属性创建一个依赖追踪的系统。当属性被访问或修改时，getter/setter会触发**依赖追踪系统**，从而进行**依赖收集**和**派发更新**，以保证数据和视图的同步。
>
> 1.创建**Observer**对象：通过递归地将data对象的属性转换为响应式属性，使用**Object.defineProperty()为每个属性添加getter和setter方法**。`Vue2中 通过使用 Object.defineProperty() 方法，将对象的属性转换成 getter 和 setter，当数据发生变化时，会自动触发相应的更新函数，实现数据的响应式。`
> 2.创建**Dep**对象：用来管理 Watcher，它用来收集依赖、删除依赖和向依赖发送消息等。用于解耦属性的依赖收集和派发更新操作。
> 3.创建Watcher对象：Watcher对象用于连接视图和数据之间的桥梁，当被依赖的**属性发生变化时**，**Watcher对象会接收到通知并更新视图**。当数据发生变化时，它会通知订阅该数据的组件更新视图。Watcher 在实例化时会将自己添加到 Dep 中，当数据发生变化时，会触发相应的更新函数。
> 4.模板编译：Vue会解析模板，将模板中的数据绑定指令转译为对应的更新函数，以便在数据发生变化时调用。

##### 问题

1.新增属性的响应问题

Vue在初始化时会对data对象的属性进行数据劫持，但是对于后续新增的属性，Vue无法自动进行响应式处理。
Vue 无法探测普通的新增属性 ，比如` this.myObject.saying = 'hi'`，**这个新增的saying属性是不具有响应式的**，Vue探测不到

2.数组变动的响应问题

Vue对数组的变动（例如通过索引修改数组元素、通过splice方法删除或插入元素）无法直接进行响应式处理。

> 如果你通过数组下标修改对象属性的话是可以监测的，因为对象里的属性都是响应式的，但如果你通过数组下标修改普通元素是无法监测到的
>
> 如果用一个新数组覆盖掉原先的数组，Vue是能监测到的

3.对象属性的删除问题

> Vue无法直接检测到对象属性的删除操作。
> `利用delete删除对象的属性，无法被Vue监测到`

##### 解决方法

1.新增属性

给data中的student对象添加一个属性，并且是响应式的，有两种写法，Vue.set或者this.$set

```js
// Vue.set(this._data.student,'sex','男') // 这里加不加_data实际上都可以，就是一个数据代理，访问谁都一样，那我们肯定选择偷懒啦
this.$set(this.student,'sex','男')  // this代表vm vue实例对象
```

2.数组变动

- 数组变异方法：例如push、pop、shift、unshift、splice、sort和reverse这些方法会触发数组的响应式更新。如果不是这七个方法的话，比如调用slice等数组方法的话，记得要把返回的新数组覆盖掉原来的旧数组，依然能触发响应式
- 利用set方法

3.对象属性的删除问题

- 利用Vue.delete完美解决删除对象属性无法被监测的问题（很少用到），或者`vm.$delete(vm.person,'name')`



### 3.Vue3为什么采用了Proxy？

#### defineProperty缺陷

- 不能监听数组变化
- 只能劫持对象的属性（给对象添加属性vue无法检测到）

#### Proxy的好处

- proxy可以直接监听数组的变化
- proxy可以监听对象而非属性.它在目标对象之前架设一层“拦截”，因此提供了一种机制，可以对外界的访问进行过滤和改写。proxy直接劫持一个对象，并且会返回一个新对象。

但是proxy由于是es6的方法，所以也会存在着兼容性的问题



### 4.设计一个图片懒加载方案

> 懒加载是一种网页性能优化方式，比如当访问一个网页的时候，优先显示可视区域内的图片而不是一次加载全部的图片；
>
> 1. 避免首次加载时消耗大量事件，降低页面渲染速度，造成卡顿现象；
> 2. 按需加载，避免无效图片的加载，减轻服务器压力，节约网络资源；

> 基本原理：
>
> - 监听图片是否存在页面可视区域内，若存在，则加载，否则不加载；
> - 将图片url存储在自定义属性中，当监听到图片进入可视区域，将自定义属性的url赋值给src属性
>
> 实现方法：
>
> 1. 监听页面滚动事件`window.addEventListener('scroll',lazyLoad)`
>
> 2. 判断图片是否在可视区域内：
>
>    （1）top < window.innerHeight
>
>    （2）left< window.innerWidth
>
>    （3）图片的bottom和right均大于0

> 方法二：调用IntersectionObserver实现懒加载
>
> 可以不监听scroll事件，做到元素一旦可见就回调



### 5.原生实现轮播图，说一说实现的思路。

> 首先通过id获取到放置图片的父容器slider，然后利用getElementsByTagName方法获取到所有的img标签，并将其转为数组形式。 接着，我们定义一个变量currentImage来表示当前显示的图片索引，默认为0。 最后，我们使用setInterval函数设置一个定时器，每隔3秒就执行一个回调函数。回调函数中，我们先移除当前显示图片的.active类名，然后计算下一张图片的索引（使用取余运算实现循环切换），并给下一张图片添加.active类名来显示出来。

```html
<div id="slider">
  <img id="img1" src="image1.jpg" alt="Image 1">
  <img id="img2" src="image2.jpg" alt="Image 2">
  <img id="img3" src="image3.jpg" alt="Image 3">
</div>

```

```css
#slider {
  position: relative;
  width: 600px;
  height: 400px;
  overflow: hidden;
}

#slider img {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  transition: opacity 1s ease-in-out;
}

#slider img.active {
  opacity: 1;
}

```

```js
// 获取图片列表和第一个图片
const slider = document.getElementById('slider');
const images = Array.from(slider.getElementsByTagName('img'));
let currentImage = 0;

// 启动定时器，每隔3秒切换一张图片
setInterval(() => {
  // 隐藏当前图片
  images[currentImage].classList.remove('active');

  // 计算下一张图片的索引
  currentImage = (currentImage + 1) % images.length;

  // 显示下一张图片
  images[currentImage].classList.add('active');
}, 3000);

```



### 6. Vue2有哪些钩子？网络请求应该放在哪里？如果是使用骨架屏或者加载动画的话，请求又应该放在哪里？

一般来说我们会将数据请求放在mounted阶段，如果放在created阶段那么SSR（Server-side Rendering)会在后端执行一次，在前端也执行一次，这并不符合我们的预期，放在update里面因为更新太频繁了，我们不能每更新一次就请求一次数据，放在destroy里面因为这个实例马上就要销毁了，请求了也没有多大的意义，所以最好我们就是放在 mount 里面。


### 7. Vue2和Vue3的响应式对于数组而言有什么不同？



### 8.从你自己的角度看，TypeScript有用吗？



### 9.用 react 实现一个列表，可以单选，多选和取消选择



### 10.实现图片异步加载函数



### 11.实现虚拟列表





### 12.vue数据请求放在哪里

>   在created中，因为此时data，methods已经创建，vue实例对象已经创建好
>   mounted中，实例挂载在dom上，可以进行dom操作了

## 四、其他

### 1.浏览器的缓存策略

https://zhuanlan.zhihu.com/p/660265758

### 2. webpack从0到1构建一个项目

- 检查node版本、webpack版本
- 

https://blog.csdn.net/weixin_43575775/article/details/128958093?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-128958093-blog-127458739.235^v38^pc_relevant_default_base&spm=1001.2101.3001.4242.1&utm_relevant_index=3



### 3. webpack的优化手段，除了持久化缓存、多线程打包、splitChunk还有哪些？

##### 优化方案：

1、减少入口文件大小： 将入口文件拆分为多个较小的模块，使用动态导入（dynamic imports）按需加载，减少初始加载的文件大小。

2、代码分割（Code Splitting）： 通过配置Webpack的代码分割功能，将项目代码分割成多个块（chunks），并且在需要的时候按需加载。

3、使用Tree Shaking： 通过配置Webpack的Tree Shaking功能，只保留项目中实际使用到的代码，剔除未使用的代码，减少打包后的文件大小。

4、优化加载速度： 使用Webpack的插件如MiniCssExtractPlugin来提取CSS代码，使用babel-loader的缓存机制等，以减少构建时间和加载时间。

5、并行构建： 使用Webpack的thread-loader或happypack插件将任务分发给多个子进程并行处理，提高构建速度。

6、优化文件体积： 使用Webpack的压缩插件如terser-webpack-plugin来压缩JavaScript代码，使用cssnano等工具压缩CSS代码，减小文件体积。

7、使用缓存： 配置Webpack的缓存功能，使得构建过程中只重新构建发生更改的部分，而不是每次都重新构建整个项目。

8、懒加载与预加载： 对于大型应用，使用Webpack的懒加载（Dynamic Import）功能，按需加载非关键性资源；同时可以使用预加载（Preload）和预解析（Prefetch）机制提前加载关键资源。

9、优化图片资源： 对于图片资源，可以使用Webpack的url-loader或file-loader来压缩和处理图片，并根据需要进行懒加载或响应式加载。

10、配置合理的模块解析规则： 通过配置Webpack的resolve选项，设置合适的模块解析规则，避免过多的文件查找和解析过程。

https://blog.csdn.net/m0_61643133/article/details/128246282?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-128246282-blog-132219844.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-128246282-blog-132219844.235%5Ev43%5Epc_blog_bottom_relevance_base6&utm_relevant_index=2



### 4. TreeShaking为什么需要基于ES Module才能实现？

#### 什么是TreeShaking?

> Tree shaking 是一个通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code) 行为的术语。
> 它依赖于ES2015中的 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。

#### 原理

> Tree shaking的本质是移除掉无用的js代码。无用代码移除存在于各种compiler中，compiler会根据代码的export和import的关系，判断出一些代码没有用到，或者注释掉了等，删除不会影响逻辑，然后把他们移除掉，这个过程就是DCE（dead code elimination）。
>
> 在ES6里引入了ES Module这样的静态的模块，**ES Module依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析**，这就是tree-shaking的基础。能够把依赖树静态地推导出解析语法树。
> 
>

### 5. http和websocket协议的不同点？项目里面用过吗？

#### 区别

1. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息，而HTTP是单向的；
2. WebSocket是需要浏览器和服务器握手进行建立连接的，而http是浏览器发起向服务器的连接。

#### 作用

> 提供了一种在浏览器和服务器之间建立持久连接来交换数据的方法。数据可以作为数据包在两个方向上传递，而无需中断连接也无需额外的http请求。
>
> 对于需要连续数据交换的服务，例如网络游戏，实时交易系统等，WebSocket 尤其有用

#### 使用

```js
let s=new WebSocket("ws://javascript.info")
```

始终使用wss：ws存在奇怪的header，会被终止连接，而且不安全；

### 6.如果没有后端接口，前端怎么提前模拟数据请求？

- Apifox
- mock



### 7. axios的拦截器知道吗？拦截器有什么用？

> axios中的拦截器可以在请求发送前和响应返回后对请求和响应进行统一处理，比如添加公共请求头、处理请求参数、统一处理错误信息等。拦截器可以在请求和响应的过程中插入一些逻辑，方便管理和统一处理网络请求。axios提供了`axios.interceptors.request`和`axios.interceptors.response`来添加请求和响应拦截器。

### 8.自己封装过组件吗？一个好的组件的标准应该是什么？

- 高性能、低耦合
- 数据从父组件传入：子组件不要生成数据，生成也只能在内部使用；
- 在父组件处理事件
- 预留Slot：通用组件往往不能满足所欲的应用场景，可以预留slot让父组件通过slot解决；
- 不依赖vuex
- 合理使用scoped：样式中添加scope让样式只对当前组件生效，但是一味使用scoped会产生重复代码。
- 组件应具有单一职责

### 9.吸顶的效果是怎么实现的？如果需要你原生实现呢？

> JS实现吸顶效果通常有两种方法：
>
> - 监听页面滚动事件，当滚动到一定位置时，将需要吸顶的元素的定位改为fixed，并设置相应的样式，如top和z-index等。当页面滚动回到原位置时，将元素的定位改回原来的状态。
>
> - 使用CSS的position: sticky属性，将需要吸顶的元素的position属性设置为sticky，并设置相应的top和z-index等样式，即可实现吸顶效果。需要注意的是，该属性的兼容性并不是很好，需要针对不同的浏览器进行兼容处理。

```html
<div id="header">需要吸顶的元素</div>
<div id="content">页面内容</div>
```

```js
var header = document.getElementById('header');
var headerOriginalPos = header.offsetTop; // 获取元素原来的位置
 
window.addEventListener('scroll', function() {
  var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
  if (scrollTop >= headerOriginalPos) {
    header.style.position = 'fixed';
    header.style.top = '0';
    header.style.zIndex = '999';
  } else {
    header.style.position = 'static';
  }
});
```



### 10.从前端的角度减少首页的白屏时间？

https://blog.csdn.net/Jk200165/article/details/130112217

### 11.如果减少请求的数据之后，首页渲染时间还是不达标？应该怎么办？



### 12.前端用什么存储token的?

方法1：存在 cookie 中
cookie的大小约4k，兼容性在ie6及以上 都兼容，在浏览器和服务器间来回传递，因此它得在服务器的环境下运行，而且可以设定过期时间，默认的过期时间是session会话结束。

方法2：存在 localStorage 中
localStorage的大小约5M，兼容性在ie7及以上都兼容，有浏览器就可以，不需要在服务器的环境下运行， 会一直存在，除非手动清除 。

### 13.浏览器本地存储cookie localstorage sessionstorage 区别

https://zh.javascript.info/cookie



### 14.操作系统中进程和线程的区别和联系





### 15.七层网络模型





### 16. tcp 三次握手与四次挥手过程





### 17. http1.0 1.1 2.0 3.0 说一下



### 18. https 与 http 区别 



### 19. http缓存  浏览器缓存策略



### 20.节流 防抖 概念和项目中的应用场景



### 21..最近在学习前端的什么部分？



### 22..了解哪些性能优化？（前面问题延续）



### 23.解析html遇到script怎么办？

https://segmentfault.com/a/1190000044622503

### 24.有defer async属性呢 两者有什么异同

> 如果没有defer或者async属性，浏览器会立即加载并执行相应的脚本，不会等待后续加载的文档元素，读取到就会开始加载和执行，阻塞后续文档的加载；
>
> defer和async属性都是异步加载外部的js脚本文件，都不会阻塞页面的解析，区别如下：
>
> 1. 执行顺序：多个async属性的标签，不能保证加载的顺寻；多个defer属性的标签，按照加载顺序执行；
> 2. 脚本是否并行执行：async属性表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，将在onload时间之前完成；defer属性加载后续文档和js脚本的加载是并行进行的（异步），js脚本要等到文档所有元素解析完成之后执行，DOMContentLoaded事件触发执行之前；





### 25.为什么js阻塞html的解析

https://blog.csdn.net/song854601134/article/details/123676989





### 26.说说vuex 使用场景/数据管理的模式



### 27.组件通信方式



### 28.数据响应式原理 怎么更新视图的



### 29. vue3怎么做的？



### 30.commonjs和es6的模块化两种导入规范的区别

```js
//ES6 Module
function show(){
    console.log("show方法被执行")
}
//导出
export default show
export function make()
export {show,make}

//导入
import {show,make} from './B/js'
show()
import * as A from './b.js'

//CommonJS
function show(){
     console.log("show方法被执行")
}
//导出
//方法1:将需要导出的函数或变量存储到module.exports里面，其中module.exports原本是空对象；
module.exports={
    show
}
//方法2：exports在内部其实指向了module.exports 相当于把变量或函数存储到module。exports
exports.show=show
exports.count=count

//导入
const bModule =require('./B.js')
bModule.show()

```

#### 区别：

- 对于模块的依赖，CommonJS是动态的，ES6 Module是静态的；
- CommonJS导入的是值的拷贝，ES6 Module导入得是值的引用；
- 动态指对于模块依赖关系建立在代码执行阶段；静态指在代码编译阶段

上文提到，CommonJS导入时，`require` 的路径参数是支持表达式的，例如

```js
// A.js
let fileName = 'example.js'
const bModule = require('./' + fileName)
```

```js
//COmmonJS
// B.js
let count = 3
function change() {
    count ++    // 变量count + 1
    console.log('原count值为：', count);  // 打印B.js模块中count的值
}
module.exports = {
    count,
    change
}
// A.js
let count = require('./B.js').count 
let change = require('./B.js').change
console.log('改变前：', count);   
change()     // 调用模块B.js中的change方法，将原来的count + 1
console.log('改变后：', count); 

```

```
改变前：3
原count值为：4
改变后：3
```

```js

//ES6
// B.js
let count = 3
function change() {
    count ++        // 变量count + 1
    console.log(count);   // 打印B.js模块中count的值
}
export {count, change}
// A.js
import {count, change} from './B.js';
console.log('改变前：',count);
change()         // 调用模块B.js中的change方法，将原来的count + 1
console.log('改变后：', count);

```

```
改变前：3
原count值为：4
改变后：4
```



### 32.见过的状态码和含义





### 33.泛型



### 34.JS实现并发控制器

```js
class Scheduler {
  constructor() {
    this._max = 2;
    this.unwork = [];
    this.working = [];
  }

  add(asyncTask) {
    return new Promise((resolve) => {
      asyncTask.resolve = resolve;
      if(this.working.length < this._max) {
        this.runTask(asyncTask);
      } else {
        this.unwork.push(asyncTask);
      }
    })
  }

  runTask(asyncTask) {
    this.working.push(asyncTask);
    asyncTask().then(() => {
      asyncTask.resolve();      //asyncTask异步任务完成以后，再调用外层Promise的resolve以便add().then()的执行
      var index = this.working.indexOf(asyncTask);
      this.working.splice(index,1);   //从正在进行的任务队列中删除
      if(this.unwork.length > 0) {
        this.runTask(this.unwork.shift());  
      }
    })
    
  }
}

const timeout = (time) => new Promise(resolve => {
  setTimeout(resolve,time);
})

const scheduler = new Scheduler();
const addTask = (time,order) => {
  scheduler
  .add(() => timeout(time))
  .then(() => console.log(order));
}

addTask(4000,4);
addTask(2000,2);
addTask(3000,3);
addTask(900,1);

```



## 五、项目

### 1.说一下学前端的历程和路线，都是通过什么方式学的



### 2.介绍一下项目的难点



### 3.说一下技术选型的原因



### 4.react和vue学习上有哪些区别有什么感受



### 5.埋点怎么实现的？

#### 什么是埋点？

> 针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程，用来跟踪用户使用情况和优化产品；
>
> 技术实质：监听软件运行中的事件；捕获需要关注的事件发生；

#### 实现方法：

- 基于ajax的埋点上报
- 基于img的埋点上报
- 基于Navigator.sendBeacon的埋点上报

### 6.大文件上传怎么做？

- 分段上传：将大文件切割成多个小文件分别上传，在服务器端组合；可以提高上传速度和可靠性，但需要额外的后端开发和维护；

- 断点续传：将文件切片后每次上传部分数据，可以在上传失败或者中断后继续上传剩余的数据；

  #### 基本思路

  

  - 切割文件： `JavaScript` 中，文件 `File` 对象是 `Blob` 对象的子类，`Blob` 对象包含一个重要的方法 `slice`，通过这个方法，我们就可以对二进制文件进行拆分。使用js中的File API的slice方法；

  ```js
   // 生成文件切片
  function createFileChunk(file, size = SIZE) {
    const fileChunkList = []
    let cur = 0
    while (cur < file.size) {
      fileChunkList.push({
        file: file.slice(cur, cur + size),
      })
      cur += size
    }
    return fileChunkList
  }
  
  ```

  

  - 上传文件片段：使用API上传每个文件片段到后端，并携带相关信息，如文件名、文件ID、当前片段序号等；
  - 后端接受并保存文件片段：后端接收后保存在临时位置，并记录文件片段的序号和文件ID等信息；
  - 续传处理： 上传过程终端后，下次继续上传时，通过查询后端已保存的文件片段信息，得知已成功上传的文件片段，从断点出上传剩余的文件片段；另外，断点续传需要考虑到网络中断、用户关闭页面等各种异常情况，需要适当处理这些异常来保证上传的稳定性和可靠性。
  - 合并文件：当所有文件上传后，后端根据文件ID合并成完整的问及那；

在Vue中，你可以使用相关的库来简化文件上传和切割的过程，比如`vue-upload-component`、`axios`等，具体使用方式可以参考它们的文档。

#### 注意事项：

- 如果要上传一个文件，需要把 `form` 标签的 `enctype` 设置为 `multipart/form-data`，同时`method` 必须为 `post` 方法。

> multipart 互联网上的混合资源，就是资源由多种元素组成，form-data 表示可以使用 HTML Forms 和 POST 方法上传文件，具体的定义可以参考 RFC 7578。

但是现在，我们很少使用这种 `form` 的方式了，我们都是直接使用 `XMLHttpRequest` 来发送 `Ajax` 请求。

最开始 `XMLHttpRequest` 是不支持传输二进制文件的。文件只能使用表单的方式上传，我们需要写一个 `Form`，然后将 `enctype` 设置为 `multipart/form-data`。

后来 `XMLHttpRequest` 升级为 `Level 2` 之后，新增了 `FormData` 对象，用于模拟表单数据，并且支持发送和接收二进制数据。我们目前使用的文件上传基本都是基于 `XMLHttpRequest Level 2`。

`xhr.send(data)` 中 `data` 参数的数据类型会影响请求头部 `content-type` 的值。我们上传文件，`data` 的类型是 `FormData`，此时 `content-type` 默认值为 `multipart/form-data`；**在上传文件场景下，不必设置 content-type 的值，浏览器会根据文件类型自动配置**

- 显示进度：可以通过 `onprogress` 事件来实时显示进度，默认情况下这个事件每 `50ms` 触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的 `onprogress` 事件：上传触发的是 `xhr.upload` 对象的 `onprogress` 事件，下载触发的是 `xhr` 对象的 `onprogress` 事件。

```js
xhr.onprogress = updateProgress;
xhr.upload.onprogress = updateProgress;

function updateProgress(event) {
  if (event.lengthComputable) {
    var completedPercent = event.loaded / event.total;
  }
}

```









## 六、三面

### ①问项目 

###   ②输入url到页面渲染的过程（非常详细的说） 

###   ③content-type有几种类型，post请求体有哪些 

###   ④箭头函数和普通函数有什么区别，为什么要用箭头函数 

```js
  const Person = {
    'name': 'little bear',
    'age': 18,
    'sayHello': function () {
      setInterval(function () {
        console.log('我叫' + this.name + '我今年' + this.age + '岁!')
      }, 1000)
    }
  }
  Person.sayHello()  //输出我叫undefined，今年我undefined岁。因为setInterval执行时，是在全局作用域下，this指向window，window上没有name和age；

```

通常缓存this，然后在setInterval中用缓存的this进行操作；

```js
 const Person = {
    'name': 'little bear',
    'age': 18,
    'sayHello': function () {
     let self = this
      setInterval(function () {
        console.log('我叫' + self.name + '我今年' + self.age + '岁!')
      }, 1000)
    }
  }
  const sayHelloFun = Person.sayHello
  sayHelloFun()
```

大家可能会觉得这样不科学，明明是写在对象里面的方法，为什么还要使用缓存这个对象才能正确使用。ECMA组织觉得这确实是个问题，之后在es6的新特性里添加了箭头函数，它能很好的解决这个问题。另外箭头函数还用简化代码量的特点。

特点：

- 不绑定this，arguments；this由所在上下文决定，arguments有...rest参数获取；

```js
let arrowfunc = (...theArgs) => console.log(theArgs.length)
arrowfunc(1,2)
//output
2
```

- 简化代码语法；



###   ⑤对promise的理解（详细的说） 



###   算法：

#### 比较版本号并排序 

```js
function arrSort(arr) {
    arr.sort(function(versionA,versionB){
        const numsA=versionA.split(".")
        const numsB=versionB.split(".")
        const len=Math.min(numsA.length,numsB.length);

        for(let i=0;i<len;i++){
            let n1=Number(numsA[i])
            let n2=Number(numsB[i])
            if(n1>n2){
                return 1;
            }
            if(n1<n2){
                return -1;
            }
        }
        return 0;
    })
}

const arr = ['4.8', '1.7.1', '4.1.9', '5'];
arrSort(arr);
console.log(arr); //["1.7.1", "4.1.9", "4.8", "5"]
```

#### 青蛙跳台阶细节讲解



1. ### 自我介绍 聊天 （聊了二十分钟你敢信？） 

（leader貌似对于我非科班的身份很感兴趣，问我为啥学前端，学了多久，我说三个月，还以为他会觉得我没啥经验，后来问他，他觉得我学习能力强，有潜力hhh） 

2. ### 一句话概括Jquery（简历上写了 我说操作dom的工具） 

3. ### 一句话概括vue 

> 一套构建用户界面的渐进式框架。
>
> 渐进式：渐进式的含义，我的理解是：没有多做职责之外的事。按需学习，按需添加功能；

2. ### 实现动画的方式 尽可能多地说 

> - gif
> - css3
> - canvas
> - svg
> - requestionAnimationFrame
> - webGL

2. ### 算法： 

#### （1）  实现一个发布订阅模式 

#### （2）  输入给定数字的下一个比他大的数字 比如输入1234 输出1243  输入12531 输出13125 

```js
var nextGreaterElements = function(nums) {
    const n = nums.length;
    const ret = new Array(n).fill(-1);
    const stk = [];
    for (let i = 0; i < n * 2 - 1; i++) {
        while (stk.length && nums[stk[stk.length - 1]] < nums[i % n]) {
            ret[stk[stk.length - 1]] = nums[i % n];
            stk.pop();
        }
        stk.push(i % n);
    }
    return ret;
};

```



### 不知道为啥八股反而多了

### 如何响应式布局？

- 媒体查询：为不同尺寸的屏幕设备设置不同的css样式；
- flex弹性布局：为盒装模型提供最大灵活性；
- rem布局：相对于根元素字体大小；

```css
html{
    font-size:10px;
}
div {
    font-size:1rem;
}

```

- 百分比布局
- grid布局

### vue的响应式怎么做的？

### Proxy和Object.defineProperty区别？

- Object.defineProperty

> 在一个对象上定义一个新属性，或者修改一个对象的现有属性并返回；
>
> 事实上，通过索引访问或者修改数组中已经存在的元素，是可以出发get和set的，但是对于通过push、unshift增加的元素，会增加一个索引，这种情况需要手动初始化，新增加的元素才能被监听到。另外， 通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法。
> 

```js
let person = {}
let personName = 'lihua'
//在person对象上添加属性name,值为personName
Object.defineProperty(person, 'name', {
  //但是默认是不可枚举的(for in打印打印不出来)，可：enumerable: true
  //默认不可以修改，可：wirtable：true
  //默认不可以删除，可：configurable：true
    get: function () {
        return personName
    },
    set: function (val) {
        return name=val
    }
})
//当读取person对象的name属性时，触发get方法
console.log(person.name)
//当修改person对象的name属性时，触发set方法
personName = 'liming'
//检查后发现，修改成功了
console.log(person.name)

//监听对象上的多个属性
let person = {
    name: '',
    age: 0
}
// 实现一个响应式函数
function defineProperty(obj, key, val) {
    Object.defineProperty(obj, key, {
        get() {
            console.log(`访问了${key}属性`)
            return val
        },
        set(newVal) {
            console.log(`${key}属性被修改为${newVal}了`)
            val = newVal
        }
    })
}
// 实现一个遍历函数Observer
function Observer(obj) {
    Object.keys(obj).forEach((key) => {
        defineProperty(obj, key, obj[key])
    })
}
Observer(person)
console.log(person.age)
person.age = 18
console.log(person.age)

```

- Proxy

> Proxy对代理对象上的一些操作进行拦截，外界对这个对象的各种操作（基本方法），都要先通过这层拦截。
>
> ```js
> const p=new Proxy(target,handler)
> ```
>
> ```js
> //定义一个需要代理的对象
> let person = {
>     age: 0,
>     school: '西电'
> }
> //定义handler对象
> let hander = {
>     get(obj, key) {
>         // 如果对象里有这个属性，就返回属性值，如果没有，就返回默认值66
>         return key in obj ? obj[key] : 66
>     },
>     set(obj, key, val) {
>         obj[key] = val
>         return true
>     }
> }
> //把handler对象传入Proxy
> let proxyObj = new Proxy(person, hander)
> 
> // 测试get能否拦截成功
> console.log(proxyObj.age)//输出0
> console.log(proxyObj.school)//输出西电
> console.log(proxyObj.name)//输出默认值66
> 
> // 测试set能否拦截成功
> proxyObj.age = 18
> console.log(proxyObj.age)//输出18 修改成功
> 
> ```

#### 基本方法

- get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。

- set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。

- has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。

- deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。

- ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。

- getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。

- defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。

- preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。

- getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。

- isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。

- setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。

- apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。

- construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。
  


#### Proxy中的this问题

Proxy完成了对目标对象的代理，但是不是透明代理。也就是说，即使handler为空对象，他所代理的对象中的this指向也不是该对象，而是proxyObj对象。

```js
const target = new Date();
const handler = {};
const proxyObj = new Proxy(target, handler);

proxyObj.getDate();
// TypeError: this is not a Date object.

```

getDate方法只能在Date 对象实例上拿到，如果this不是Date对象则会报错，因此需要手动将this绑定到Date对象；

```js
const target = new Date('2015-01-01');
const handler = {
    get(target, prop) {
        if (prop === 'getDate') {
            return target.getDate.bind(target);
        }
        return Reflect.get(target, prop);
    }
};
const proxy = new Proxy(target, handler);
proxy.getDate() // 1

```

### vue2如何重写的数组方法？

> 核心：arrayMethods 首先继承了 Array，然后对数组中所有能改变数组自身的方法，如 push、pop 等这些方法进行重写。重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 push、unshift、splice 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 ob.dep.notify() 手动触发依赖通知，这就很好地解释了之前的示例中调用 vm.items.splice(newLength) 方法可以检测到变化。
>
> ```js
> // src/core/observer/array.js
> 
> // 获取数组的原型Array.prototype，上面有我们常用的数组方法
> const arrayProto = Array.prototype
> // 创建一个空对象arrayMethods，并将arrayMethods的原型指向Array.prototype
> export const arrayMethods = Object.create(arrayProto)
> 
> // 列出需要重写的数组方法名
> const methodsToPatch = [
>   'push',
>   'pop',
>   'shift',
>   'unshift',
>   'splice',
>   'sort',
>   'reverse'
> ]
> // 遍历上述数组方法名，依次将上述重写后的数组方法添加到arrayMethods对象上
> methodsToPatch.forEach(function (method) {
>   // 保存一份当前的方法名对应的数组原始方法
>   const original = arrayProto[method]
>   // 将重写后的方法定义到arrayMethods对象上，function mutator() {}就是重写后的方法
>   def(arrayMethods, method, function mutator (...args) {
>     // 调用数组原始方法，并传入参数args，并将执行结果赋给result
>     const result = original.apply(this, args)
>     // 当数组调用重写后的方法时，this指向该数组，当该数组为响应式时，就可以获取到其__ob__属性
>     const ob = this.__ob__
>     let inserted
>     switch (method) {
>       case 'push':
>       case 'unshift':
>         inserted = args
>         break
>       case 'splice':
>         inserted = args.slice(2)
>         break
>     }
>     if (inserted) ob.observeArray(inserted)
>     // 将当前数组的变更通知给其订阅者
>     ob.dep.notify()
>     // 最后返回执行结果result
>     return result
>   })
> })
> 
> ```
>
> 

### 拿到一段js代码，如何调用它？除了new Function还有哪些？

- eval
- new Function 

> 都将字符串解析为一段JS脚本并执行；

```js
let func = new Function ([arg1[, arg2[, ...argN]],] functionBody);
```



### 函数的this指向？this非严格模式下的指向？如何为函数绑定this？

- 默认绑定window；
- 对象调用时指向对象；
- 全局作用域指向window；

非严格模式：默认绑定到widnow；

严格模式：不会自动绑定到window对象，导致函数的调用者丢失，this相当于未初始化；为undefined；

#### 如何绑定this？

- 隐式绑定：调用函数时为其指明对象上下文；
- 显式绑定：call/apply/bind方法； 多个对象、对象数组、多个对象； bind延迟调用；
- new绑定，底层创建一个新对象，this绑定到新对象；
- 箭头函数绑定；

绑定优先级

1. `new`绑定
2. 显示绑定
3. 隐式绑定
4. 默认绑定



### 首屏渲染性能如何优化？

#### 性能指标

- FCP First Contentful Patin ：  白屏时间（第一个文本绘制时间）
- Speed Index ： 首屏时间
- TTI Time To Interactive : 第一次可交互时间
- Lighthouse Score 

#### 工具

- webpack bundle ：查看代码冗余依赖；

#### 优化

- 排查并移除冗余依赖
- 构建时压缩图片

> - 构建流程中使用image-webpack-loader；
> - webP格式的图片：webP-converter转换；
> - 封装svg组件，按需引入需要的图标；

- 优化Element-Plus体积

> - 按需引入；
> - 删除冗余组件改为import（）

- 传输优化

> - 优化分包策略：vue3-cli默认将所有npm依赖打包进chunk-vendor，依赖多时会导致包过大；
>
>   ```js
>   
>   optimization: isProd ? {
>     splitChunks: {
>       chunks: 'all',
>       maxInitialRequests: Infinity, // 默认为3，调整为允许无限入口资源
>       minSize: 20000, // 20K以下的依赖不做拆分
>       cacheGroups: {
>         vendors: {
>           // 拆分依赖，避免单文件过大拖慢页面展示
>           // 得益于HTTP2多路复用，不用太担心资源请求太多的问题
>           name(module) {
>             // 拆包
>             const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1]
>             // 进一步将Ant组件拆分出来,请根据情况来
>             // const packageName = module.context.match(/[\\/]node_modules[\\/](?:ant-design-vue[\\/]es[\\/])?(.*?)([\\/]|$)/)[1]
>             return `npm.${packageName.replace('@', '')}` // 部分服务器不允许URL带@
>           },
>           test: /[\\/]node_modules[\\/]/,
>           priority: -10,
>           chunks: 'initial'
>         }
>       }
>     },
>     runtimeChunk: { name: entrypoint => `runtime-${entrypoint.name}` }
>   } : {}
>   ```
>
> - 优化路由懒加载：当页面打开时采取加载对应的文件，利用vue异步组件和webpack的代码分割实现；
>
> ```js
> component:()=>import('@/views/user/register')
> //只在生产时懒加载，开发时构建速度感人；
> ```
>
> - 使用Http2
>
> 更快，延迟低，功能多；使用一个TCP连接分帧处理多个请求，压缩头部文件；
>
> - Gzip压缩传输
>
> Http协议头中用字段Accept-Encoding和Content-Encoding进行了协定，请求头的Accept-Encoding会列出客户端支持的编码格式；
>
> ```js
> // vue.config.js
> const CompressionPlugin = require('compression-webpack-plugin')
> // gzip压缩处理
> chainWebpack: (config) => {
>     if(isProd) {
>         config.plugin('compression-webpack-plugin')
>             .use(new CompressionPlugin({
>                 test: /\.js$|\.html$|\.css$/, // 匹配文件名
>                 threshold: 10240, // 对超过10k的数据压缩
>                 deleteOriginalAssets: false // 不删除源文件
>             }))
>     }
> }
> ```
>
> 插件默认压缩等级为9最高级；
>
> 图片不建议使用gzip，效果较差；
>
> - CDN加速+OSS对象存储
>
> CDN加速原理是把提供的域名作为源站，将源内容缓存到边缘节点。当客户读取数据时，会从最适合的节点（一般来说就近获取）获取缓存文件，以提升下载速度。

#### 感知性能优化

- loading动画
- 首屏骨架加载；
- 渐进式图片：先加载小兔，模糊化渲染，加载完成后替换为原图；模糊化可以用filter或者canvas处理；
- 占位图



### http1.1和http2区别？

### js加载会阻塞dom吗？如何防止阻塞？

> 默认情况下，当浏览器遇到 `<script>` 标签时，它会停下来立即加载并[执行脚本](https://so.csdn.net/so/search?q=执行脚本&spm=1001.2101.3001.7020)，然后再继续解析和渲染 DOM。这种行为可能会导致页面加载的延迟，尤其是当脚本文件很大或者网络状况不佳时。
>
> 异步加载（Async）：
> 使用 <script async> 属性可以让浏览器异步加载脚本文件，不会阻塞 DOM 的解析。一旦脚本加载完成，浏览器会暂停 DOM 的解析，执行脚本，然后继续解析 DOM。这种方式适用于那些不依赖于其他脚本或 DOM 的独立脚本。
>
> 延迟加载（Defer）：
> 使用 <script defer> 属性也可以让浏览器异步加载脚本文件，但不同之处在于，无论脚本加载完成的顺序如何，浏览器都会保证按照它们在文档中出现的顺序执行这些脚本。这种方式适用于那些依赖于其他脚本或 DOM 的脚本。
>
> 动态脚本加载：
> 通过 JavaScript 动态创建 <script> 标签，并将其添加到 DOM 中，可以实现更灵活的脚本加载策略。这种方式可以让你根据需要控制脚本的加载时机，甚至可以根据用户的行为或其他条件来决定是否加载某个脚本。
>
> 使用模块打包工具：
> 现代前端工程通常会使用模块打包工具（如 Webpack、Rollup 等）来组织和优化脚本文件。这些工具提供了代码分割（Code Splitting）的功能，可以将代码拆分成多个小块，按需加载，从而有效减少初始加载时所需加载的

### 在前几段实习中学到了什么？

### 手撕：最长不重复字符串

```js
var lengthOfLongestSubstring = function(s) {
    let ans = 0;
    let left = 0;
    const window = new Set(); // 维护从下标 left 到下标 right 的字符
    for (let right = 0; right < s.length; right++) {
        const c = s[right];
        // 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素
        // 所以要在加入 c 之前，先移出窗口内的 c
        while (window.has(c)) { // 窗口内有 c
            window.delete(s[left++]); // 缩小窗口
        }
        window.add(c); // 加入 c
        ans = Math.max(ans, right - left + 1); // 更新窗口长度最大值
    }
    return ans;
};


```



### 说一下项目难点

### 登录技术选型为啥选这个

### 不同域名下的local storage共享怎么做

### 有没有看过相关的文章

### 平时怎么学前端

### 说一个印象最深刻的设计模式

### 怎么用es module实现单例

### 手撕: 提取url




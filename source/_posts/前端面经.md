---
title: 前端面筋
date: 2023-03-27 18:51:45
categories: 
    - 前端
tags: 
    - 面试笔记
    - 笔记
mp3: 
cover: img/bg11.jpg

---

https://zh.javascript.info/


# 前端三大件

## 一、HTML

### 1.页面生命周期

#### DOMContentLoaded

>  浏览器已完全加载 HTML，并构建了 DOM 树，但像 `<img>` 和样式表之类的外部资源可能尚未加载完成。
>
> DOM已经就绪，可以查找DOM节点并初始化接口。

#### DOMContentLoaded 和脚本

```js
    function ready () {
            console.log("Dom ready")
            let body = document.getElementsByTagName("body")
            console.log(body)
        }


        document.addEventListener("DOMContentLoaded", ready)
```

当浏览器处理一个 HTML 文档，并在文档中遇到 `<script>` 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 `document.write` 操作，所以 `DOMContentLoaded` 必须等待脚本执行结束。

⚠不会阻塞DOMContentLoaded脚本

- 具有async特性的脚本不会阻塞；
- 使用`document.createElement('script')`动态生成并添加到网页的脚本也不会阻塞；

#### DOMContentLoaded和样式

外部样式表不会影响 DOM，因此 `DOMContentLoaded` 不会等待它们。

但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：

```js
<link type="text/css" rel="stylesheet" href="style.css">
<script>
  // 在样式表加载完成之前，脚本都不会执行
  alert(getComputedStyle(document.body).marginTop);
</script>
```

原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。

当 `DOMContentLoaded` 等待脚本时，它现在也在等待脚本前面的样式。

#### Load

> 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等；
>
> 外部资源已加载完成，样式已被应用，图片大小也已知；

```js
   window.onload = function () {
            console.log("图片资源加载完成~")
        }
```



#### beforeunload/unload

> 当用户正在离开页面时。
>
> 可以检查用户是否保存了更改并询问是否真的要离开

```js


  window.onbeforeunload = function () {
            return "有未保存的值。确认要离开吗？"
        };
```

⚠`event.preventDefault()`在beforeunload处理程序中不起作用

#### readyState

- loading:文档正在被加载；
- interactive：文档被全部读取；
- complete：文档被全部读取，并且所有资源被加载完成；

### 2.async、defer

#### 两个问题

1. 脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。
2. 如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容

#### defer

> defer特性告诉浏览器不要等待脚本，相反，浏览器将继续处理HTML，构建DOM。脚本会在后台下载，等待DOM构建完成后脚本才会执行。

换句话说：

- 具有 `defer` 特性的脚本不会阻塞页面。
- 具有 `defer` 特性的脚本总是要等到 DOM 解析完毕，但在 `DOMContentLoaded` 事件之前执行。
- `defer` 特性除了告诉浏览器“不要阻塞页面”之外，还可以确保脚本执行的相对顺序。

**`defer` 特性仅适用于外部脚本**

如果 `<script>` 脚本没有 `src`，则会忽略 `defer` 特性。



#### async

> async的特性和defer有些类似，能够让脚本阻塞，但是，两者有重要的区别。
>
> async特性意味着脚本是完全独立的：
>
> - 浏览器不会因async脚本而阻塞
> - 其他脚本不会等async脚本加载完成，async脚本也不会等其他脚本；
> - DOMContentLoaded和异步脚本不会彼此等待

换句话说，`async` 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。`async` 脚本就是一个会在加载完成时执行的完全独立的脚本。

当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：计数器，广告等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们

**`async` 特性仅适用于外部脚本**

就像 `defer` 一样，如果 `<script>` 标签没有 `src` 特性（attribute），那么 `async` 特性会被忽略。

#### 动态脚本

可以使用 JavaScript 动态地创建一个脚本，并将其附加（append）到文档（document）中





## 二、CSS

### 1.Flex布局

> Flex布局包括容器和Item两部分；一个容器的所有子元素都成为他的item成员；

![](https://s3.bmp.ovh/imgs/2023/03/16/1d4271c9004b7a95.png)

- flex-direction:主轴方向，row，row-reverse，column，column-reverse；
- flex-wrap:默认所有的容器里的Item都在一条线上，一行放不下可以换行：nowrap（默认不换行）wrap（换行，第一行在上）
- flex-flow:前两者的缩写，默认row nowrap
- justify-content:主轴对其方式，有五个值，flex-start:主轴起始位置对齐；flex-end:主轴结束位置对齐；center:居中；space-between:始末位置各一个，中间按照平均间距防止；space-around:每个item周围的间隔相同；
- align-items:纵轴如何对齐，五个值：flex-start:从最上方开始，排列row；flex-end:最底下开始；center:中间线；baseline:项目的第一行文字的基线对其；stretch:默认，item妹有设置高度或者auto，占满容器；
- align-content:定义多根轴线对齐方式，一行则不生效；
- order属性：属于item，按照order大小排序；
- flex-grow:定义item的放大比例；
- flex-shrink:按照比例缩小；
- flex: flex-grow,flex-shrink,flex-basis;
- align-self:允许item自己的属性；可覆盖aligin-items;

### 2.CSS预处理器

> CSS预处理器式一种基于CSS，用于解决CSS难以解决的问题的Domian Specific Language;
>
> 通过用一种专门的编程语言，为CSS添加一些编程特性，再编译成CSS文件；
>
> 如：语法不够强大，妹有变量和合理的样式复用机制等；



##### CSS预处理器的作用

- 提供css缺失的样式层复用机制，减少冗余代码；
- 提高样式代码的可维护性；

##### Sass（.scss）

成熟稳定强大的专业级CSS拓展语言，兼容CSS、功能丰富；

功能：

- 变量、常量

```scss
$bgColor:#fff;		//以$开头，表示全局和局部变量
div{
    $width:100px;	//局部变量
    width:$width;
    background:$bgColor;
}

//变量用在属性中，需要写在#{}中
$posi:left;
div{
    border-#{$posi}:1 px solid $color;
}

//默认变量，值后面加上 ！default
$myLineHeight:1.5 !default;

body{
    line-height:$myLineHeight;
}

body{
    line-height:1.5;
}
```

- CSS代码嵌套

```scss
//在一个选择器中嵌套另一个选择器来实现继承，增强了sass文件的结构性和可读性；
//选择器嵌套中，可以使用&表示父元素选择器；
#top_btn{
    line-height:40px;
    text-transform:capitalize;
    li{
        float:left;
    }
    a{
        display：block;
        
        &:hover{
            color:#ddd;
        }
    }
}

//属性嵌套
.main-container{
    //选择器嵌套
    &-top{
        color:red;
    }
    //伪类嵌套
    &:hover{
        color:green'
    }
}
```

- 混入Mixin

> Mixins是CSS预处理器最强大的特性；
>
> 可以将一部分样式抽出，作为单独定义的模块，被很多选择器重复使用；

```scss
//无参数mixin
@mixin center-block{
    margin-left:auto;
    margin-right:auto;
}
.btn{
    @include center-block;
}

```

```scss
//有参数mixin
@mixin theme($theme:Darkgray){
    background:$theme;
    box-shadow:0 0 1px rgba($theme, .25);
    color:#fff;
}

.infor{
    @include theme;
}

.alert{
    @include theme($theme:Darkred);
}

//多个mixin,多个参数以逗号分隔，如果@include传入的参数个数小于@mixin定义参数的个数，则按照顺序表示，后面不足的使用默认值；如果不足的没有默认值则报错；
@mixin theme($theme:Darkgray,$color:red){
    background:$theme;
    box-shadow:0 0 1px rgba($theme, .25);
    color:$red;
}
```

```scss
//模块系统
//test.scss
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}

//styles.scss
// 使用@use导入文件
@use 'test'; // 生成了一个 test 命名空间

.inverse {
  background-color: test.$primary-color;
  color: white;
}

```

- 继承

```scss
/* This CSS will print because %message-shared is extended. */
%message-shared {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

// This CSS won't print because %equal-heights is never extended.
%equal-heights {
  display: flex;
  flex-wrap: wrap;
}

.message {
  @extend %message-shared;
}

.success {
  @extend %message-shared;
  border-color: green;
}

.error {
  @extend %message-shared;
  border-color: red;
}

.warning {
  @extend %message-shared;
  border-color: yellow;
}

```

- 函数

```scss
x @use "sass:math";

.container{
    display:flex;
}

article[role="main"]{
    width:math.div(600px,960px)*100%;
}

aside[role="complementary"]{
    width:math.div(300px,960px)*100%;
    margin-left:auto;
}
//支持加减乘除，循环等；
```

缺点：采用Ruby语言编写，单独使用妹有问题，但是工程化项目中，存在问题；

- 需要借助node-sass,node版本与node-sass版本相关联，一旦本地nodeJS升级，出现node-sass无法工作；（Rebuild或者冲洗安装node-sass）
- 需要node-gyp作为先决条件->需要兼容版本的python；
- binding.node源无法访问或者速度慢；

##### Less

Less是CSS预处理语言，拓展了CSS，增加了变量、Mixin、函数等特性；使CSS更易维护和拓展。Less可以运行在Node或浏览器端；



##### Stylus

Stylus是一种创新的样式表语言，可编译为CSS。Stylus是用nodeJS构建的；





### 3.多屏适应，自适应布局和响应式布局区别

#### 响应式布局

> 响应式布局就是实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。换句话说就是一个网站能够兼容多个终端，而不是为了每一个终端做一个特定的版本。

#### 自适应布局

> 自适应布局就是指能忘了使网页自适应的显示在不同大小终端设备上的新网页设计方式及技术，它需要开发多套界面来适应不同的终端。

#### 区别

> 1.自适应布局通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；响应式布局通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。
>
> 2.自适应布局需要开发多套界面，而响应式布局只需要开发一套界面就可以了。
>
> 3.自适应对页面做的屏幕适配是在一定范围：比如pc端一般要大于1024像素，手机端要小于768像素。而响应式布局是一套页面全部适应。
>
> 4.自适应布局如果屏幕太小会发生内容过于拥挤。而响应式布局正是为了解决这个问题而衍生出的概念，它可以自动识别屏幕宽度并做出相应调整的网页设计。
>
> 总之，响应式布局还是要比自适应布局要好一点，但是自适应布局更加贴切实际，因为你只需要考虑几种状态就可以了而不是像响应式布局需要考虑非常多状态。所以的说无论哪种设计都有它们各自的特点，我们要根据项目的需求来选择适合的布局方式。





### 4.过渡动画

- transform（平移旋转缩放）

```css
.{
    translate(50px,100px);			/*平移，x y方向*/
    rotate(20deg);					/*旋转 顺时针旋转20°*/
    rotateX(150deg);					/*x轴旋转*/
    scaleX(2);			/*增大两倍宽度*/
    scale(1,2);				/*宽度一赔，高度两倍*/
    
}
```

- animation

```css
*animation-name：关键帧的名字，该参数必需。
*animation-duration：动画持续的时间，该参数必需。
animation-timing-function：定时器函数，默认是ease。
animation-delay：动画效果多少秒后开始，默认为0。
animation-iteration-count：动画重复的次数，可以指定为一个整数，表示多少次，默认值是infinite关键字，表示无限次。
animation-direction：动画方向，可能的值为forward、backward或alternating，默认值为normal。
animation-fill-mode：默认值为none。
animation-play-state：动画默认是否生效，默认值为running。

```

- `animation` 强调流程与控制，对元素的一个或多个属性的变化进行控制，可以有多个[关键帧](https://so.csdn.net/so/search?q=关键帧&spm=1001.2101.3001.7020)（`animation` 和 `@keyframes`结合使用）
- `transition` 强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式；

### 5.标准盒模型和怪异盒模型

W3C标准盒子模型由：content、margin、padding、border组成；

##### 区别：总宽度的计算公式不一样

标准盒模型总宽度=width+margin（左右）+padding（左右）+border（左右）；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201224112703410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgwODQ4Mw==,size_16,color_FFFFFF,t_70#pic_center)

怪异盒模型总宽度=width+margin（左右）（width已经包含padding和border的值）；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201224113002950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgwODQ4Mw==,size_16,color_FFFFFF,t_70#pic_center)

```css
    .box {
        margin: 30px;
        padding: 20px;
        width: 80px;
        height: 40px;
        border: 10px solid #00007e;
        background: #fec997;
        box-sizing: border-box /* 设置盒子类型 */
      }

/*
	content-box:标准盒模型；
	border-box:怪异盒模型；
	padding-box:盒子宽度等于content+padding;
	inherit:从父元素继承box-sizeing的属性；
*/

```

### 6.css、scss、less有什么区别？

#### css

> CSS（Cascading Style Sheets）是一种[样式表](https://so.csdn.net/so/search?q=样式表&spm=1001.2101.3001.7020)语言，用于描述HTML或XML（包括如SVG、XUL等等）文档的外观和格式。CSS描述了如何将元素显示在屏幕上，打印出来，或者以其他方式呈现给用户。

#### scss

> SCSS（Sassy CSS）是CSS预处理器[Sass](https://so.csdn.net/so/search?q=Sass&spm=1001.2101.3001.7020)的一种语法格式。它使用全新的语法结构，相比于原生的CSS，SCSS可以使用变量、嵌套规则、混合、函数等高级功能。

- $变量
- 嵌套规则
- 混合
- 函数

#### less

> LESS是一种动态样式语言，也是一种CSS预处理器，它扩展了CSS的语法，增加了变量、混合、函数和许多其他的特性，使得CSS更易维护、主题化和可扩展。

- @变量
- 嵌套
- 混合
- 函数：懒惰求值，只在被调用时才会计算

### 7.CSS权重

```
！important>类选择器>ID选择器>行内样式>元素选择器
```

![img](https://uploadfiles.nowcoder.com/images/20220703/57482729_1656859671727/D82CFBECAEDB7FAB7998C956BF463875)

### 8.保持元素宽高比

```css
.item {
  background: #f40;
  width: 50%;
  margin: 0 auto;
  /* 新方法，兼容性差 */
  aspect-ratio: 4/3;
}

/* 老方法需要两个容器 */
.container {
  background: rgb(115, 71, 211);
  width: 50%;
  margin: 0 auto;
}

.inner {
  width: 100%;
  padding-bottom: 75%;
  position: relative;
}

```

### 9.层叠样式

> z-index是CSS样式中的一个属性，用于控制元素在层叠上下文中的垂直顺序。具体来说，z-index决定了一个元素在层叠顺序中的位置。层叠顺序是指浏览器在渲染页面时，确定每个元素的堆叠顺序，决定哪个元素在视觉上位于其他元素的上方或下方。
>

1. **z-index的默认值是多少？** z-index的默认值是`auto`，即浏览器自动决定元素的层叠顺序。通常，如果没有显式地设置z-index的值，元素将按照它们在HTML文档中的顺序进行层叠。
2. **如何处理层叠上下文重叠的情况？** 当两个层叠上下文元素发生重叠时，它们的层叠顺序由它们各自的z-index值决定。确保需要置于顶部的元素具有较高的z-index值，以确保正确的层叠效果。
3. **如何处理层叠顺序混乱的问题？** 当页面中的多个元素具有不同的z-index值时，可能会导致层叠顺序混乱。为了避免这种情况，最佳实践是在编写CSS样式时使用一致的z-index命名约定，避免使用过多的z-index层级，以及使用层叠上下文来控制元素的层叠顺序。
4. **如何在使用z-index时避免副作用？** 在设置z-index值时，需要小心避免过度使用或错误使用。过多的z-index层级可能会导致维护和排错困难。建议仅在需要控制层叠顺序的特定元素上使用z-index，并使用合理的命名和注释来提高代码可读性和可维护性。

### 10.px,rpx,em,rem

- px

> 表示屏幕实际的像素点，不同设备上，px 会根据屏幕的分辨率进行换算，因此不同设备上的显示效果会有差异

- rpx

> 响应式像素：是微信小程序中引入的最小单位，用于适配不同尺寸的手机屏幕，换算规则：750rpx 等于屏幕宽度

- em

> 相对于父元素的字体大小的单位，如果父元素的字体大小为 16px，子元素设置 2em，则子元素字体大小将会是 32px

- rem

> 相对根元素的字体大小，与 em 类似，但是相对的是根元素即 html 字体大小。通常情况下开发者将根元素的字体大小设置为一个基准值，然后使用 rem 单位来表示其他元素的尺寸；

- vh、vw

> 相对于视口的高度和宽度

- pt

> 设备像素/设备独立像素

- ppi

> m 每英寸像素

### 11.元素垂直居中

#### 定位+Margin

```css
.father{
            width: 400px;
            height: 400px;
            border: 1px solid;
            position: relative;
        }
.son{
            position: absolute;
            width: 200px;
            height: 200px;
            background-color: red;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            margin: auto;
        }

```

#### 定位+Transform

> 首先通过 top: 50%; left: 50%; 将元素的左上角移到其容器的中心，然后再通过 translate(-50%, -50%) 向左和向上移动元素的一半宽度和一半高度，以此达到完全居中的效果。

```css
.father{
            width: 400px;
            height: 400px;
            border: 1px solid;
            position: relative;
        }
.son{
            position: absolute;
            width: 200px;
            height: 200px;
            background-color: blue;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
        }
```

#### flex布局

```css
.father{
            display: flex;
            justify-content: center;
            align-items: center;
            width: 400px;
            height: 400px;
            border: 1px solid;
        }
.son{
            width: 200px;
            height: 200px;
            background-color: green;
        }
```

#### 其他

```css
      .parent {
            width: 400px;
            height: 400px;
            background-color: pink;
            display: flex;
            align-items: center;
        }

        .son {
            width: 100px;
            height: 100px;
            background-color: red;
            margin: 0 auto;
            text-align: center;
            line-height: 100px;
        }
```

### 12.怎样实现一个两边栏固定宽度，中间自动填满的三分布局？

```css
    .parent {
            width: 100%;
            height: 100%;
            display: flex;
        }

        .son1 {
            width: 100px;
            background-color: aqua;
        }

        .son2 {
            width: 100%;
            background-color: red;
        }

        .son3 {
            width: 100px;
            background-color: blue;
        }
```

### 13.重排重绘

> 重排（回流）：
> 布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小
> 对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排
> 重绘：
> 计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制
> 对DOM的样式进行修改，如color等，浏览器不需要重新计算几何属性时，直接修改绘制元素的新样式，就是重绘

#### 重排

1 改变窗口大小：

        当用户调整浏览器窗口大小时，浏览器需要重新计算和调整页面布局，因此会触发重排。

2 改变字体大小：

        修改页面中文本的字体大小可能导致所有相关元素的重排。

3 改变元素的位置：

        通过修改元素的位置属性（例如position、top、left等）来移动元素会触发重排。

4 改变元素的尺寸：

        修改元素的宽度和高度，包括边距、填充和边框大小，都可能导致重排。

5 改变元素的内容：

        如果通过JavaScript动态添加或删除文档的内容，可能导致包含该内容的元素重排。

6 计算元素的尺寸或位置：

        当通过JavaScript访问offsetTop、offsetLeft、offsetWidth、offsetHeight等属性时，浏览器可能需要重新计算元素的位置和尺寸，从而触发重排。

7 更改字体：

        修改页面上的字体或字体相关属性可能导致浏览器重新计算文本的大小和布局，触发重排。

8 改变浏览器默认字体大小：

        在某些情况下，浏览器默认字体大小的改变可能会导致所有文本的重排。

9 激活CSS伪类：

        例如:hover、:active等伪类样式的激活可能会导致元素的重排。

10 修改表格布局：

        改变表格的列宽或行高会导致表格重新布局，从而触发重排。

11 更改浏览器窗口滚动位置：

        当用户滚动页面时，浏览器需要重新计算可视区域内元素的布局，可能触发重排。

12 改变浏览器的默认缩放级别：

        在某些情况下，浏览器的默认缩放级别的改变可能会导致重排。

#### 重绘

color、background 相关属性：background-color、background-image 等
outline 相关属性：outline-color、outline-width 、text-decoration
border-radius、visibility、box-shadow

> ***\*重绘就是重新绘制（repaint）：\****是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。
>
> ***\*重排就是重新排列（reflow）：\****当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。

改变元素几何信息（大小和位置），都会引起：


        元素位置改变，或者使用动画
    
        元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）
    
        内容改变（例如：文本改变或图片被另一个不同尺寸的图片替代、在input框输入内容）
    
        浏览器窗口尺寸改变（resize事件发生时）
    
        页面渲染初始化
    
        设置style属性的值
    
        计算offsetWidth、offsetHeight、offsetTop和offsetLeft等布局信息
    
        激活CSS伪类（如 :hover）
    
        查询某些属性或调用某些方法（如：getComputedStyle()、getBoundingClientRect()）

减少重排盒重绘：

        避免一条一条的修改DOM的样式，可以直接修改DOM的className
    
        避免把DOM结点的属性值放在一个循环里当成循环里的变量
    
        给动画的HTML元件使用fixed或absolute的position，那么修改他们的css是不会重排
    
        避免在大量元素上使用:hover
    
        分离读写操作
    
        避免使用Table布局
    
        避免设置多层内联样式
    
        避免在布局信息改变时查询布局信息
    
        当需要对DOM元素进行一系列的操作时，可以先使元素脱离文档流，再对其进行一些列操作，然后再把元素带回文档中



### 14.定义css的三种方式

- 元素内嵌样式：**加在标签内部的样式称之为行内样式，用style来声明，=后面写属性和值**
- 文档内嵌样式：**写在head标签里面，用闭合style来声明。**
- 外部引入样式：**写在head里面，用link来声明,href去链接你的文件，rel必须要写。**



### 15.css选择器与优先级

- id选择器（#id）

- 类选择器（.class）
- 标签选择器（div,h1,p）
- 子选择器（ul < li）
- 后代选择器（从父集到子孙集的选择器，比如：li a）
- 伪类选择器（比如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover；比如：a:hover,li:nth-child）

https://www.cnblogs.com/webpon/p/13445297.html

#### 不同级别

1. 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。
2. 作为style属性写在元素内的样式（优先级1000）
3. id选择器（优先级100）
4. 类选择器、伪类选择器（优先级10）
5. 元素选择器（优先级1）
6. 通配符选择器（优先级0）
7. 浏览器自定义或继承（没有优先级）

总结排序：!important > 行内样式 > ID选择器 > 类选择器、伪类选择器 > 元素选择器 > 通配符选择器 > 继承 > 浏览器默认属性

#### 同一级别

(1) 同一级别中后写的会覆盖先写的样式

(2) 同一级别css引入方式不同，优先级不同

总结排序：内联(行内)样式 > 内部样式表 > 外部样式表 > 导入样式(@import)。

### css flex布局

| display         | 指定 HTML 元素的盒子类型                                     |
| --------------- | ------------------------------------------------------------ |
| flex-direction  | 指定弹性盒子中子元素的排列方式                               |
| flex-wrap       | 设置当弹性盒子的子元素超出父容器时是否换行                   |
| flex-flow       | flex-direction 和 flex-wrap 两个属性的简写                   |
| justify-content | 设置弹性盒子中元素在主轴（横轴）方向上的对齐方式             |
| align-items     | 设置弹性盒子中元素在侧轴（纵轴）方向上的对齐方式             |
| align-content   | 修改 flex-wrap 属性的行为，类似 align-items，但不是设置子元素对齐，而是设置行对齐 |
| order           | 设置弹性盒子中子元素的排列顺序                               |
| align-self      | 在弹性盒子的子元素上使用，用来覆盖容器的 align-items 属性    |
| flex            | 设置弹性盒子中子元素如何分配空间                             |
| flex-grow       | 设置弹性盒子的扩展比率                                       |
| flex-shrink     | 设置弹性盒子的收缩比率                                       |
| flex-basis      | 设置弹性盒子伸缩基准值                                       |

### 16. css其他布局

https://blog.csdn.net/weixin_42981560/article/details/133968780

- 响应式布局
- 自适应布局

- table布局
- flex布局
- 两栏布局
- 三栏布局
- flexbox布局
- float布局

（1）对自身的影响：
● float元素是可以形成块的，如span元素，可以让行内元素拥有宽和高，因为块级元素就是有宽高的。
● 浮动元素的位置尽量是靠上 的
● 尽量是靠左（float:left）或者是靠右的（float:right），要是哪一行满足不了浮动元素的宽度要求，那么元素是往下掉的。
（2）对兄弟元素的影响：
● 不影响其他块级元素的位置
● 影响其他块级元素的文本
● 上面贴非float元素
● 旁边贴float元素 或者边框
（3）对父级元素的影响：
● 从布局上“消失”
● 高度塌陷

● 父元素设置overflow:auto 或者overflow:hidden

### 17.伪类选择器了解多少？after before

伪类是一种让你可以选择元素的某个状态或位置的 CSS 选择器。其中，`:before` 和 `:after` 伪类允许你在一个元素之前或之后插入内容。

`:before` 和 `:after` 伪类创建的元素是不在 HTML 文档中的，它们是通过 CSS 生成的。可以用它们来在一个元素的前面或后面插入一些内容，这些内容可以是文本、图像或者其他任何可以用 CSS 生成的内容。

`before/after`伪类相当于在元素内部插入两个额外的标签，其最适合也是最推荐的应用就是图形生成。在一些精致的UI实现上，可以简化HTML代码，提高可读性和可维护性。

![img](https://img-blog.csdnimg.cn/88e616114fbf46eb911c9486a66c87aa.png)

#### 基本用法

```css
#example:before {
    content: "#";
    color: red;
}
#example:after {
    content: "$";
    color: red;
}
```

两个伪类都属于内联元素，但是用display:block；属性可以将其转换成块状元素，比较常见的用法就是样式的一些实现，还有就是清除浮动的效果。。



#### 样式修改

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style type="text/css">
        .quote:before,
        .quote:after {
            content: "";
            display: inline-block;
            width: 5%;
            margin: 5px 1%;
            border-bottom: 1px solid rgb(220, 25, 171);
        }
    </style>
</head>

<body>
    <div class="quote">
        <span>打老虎</span>
    </div>
</body>

</html>
```



#### 清除浮动

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style type="text/css">
        .son1 {
            width: 300px;
            height: 200px;
            background-color: lightgray;
            float: left;
        }

        .son2 {
            width: 300px;
            height: 100px;
            background-color: lightblue;
            float: left;
        }

        .parent2 {
            width: 400px;
            height: 400px;
            background-color: blue;
            color: #fff;
            text-align: center;
            line-height: 400px;
            font-size: 30px;
        }

        .parent:after {
            content: "";
            display: block;
            clear: both;
        }
    </style>
</head>

<body>
    <div class="parent">
        <div class="son1">Son1</div>
        <div class="son2">son2</div>
    </div>
    <div class="parent2">Parent2</div>
</body>

</html>
```

::before和::after下特有的content，用于在css渲染中向元素逻辑上的头部或尾部添加内容。

这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。

所以不要用:before或:after展示有实际意义的内容，尽量使用它们显示修饰性内容，例如图标。


> 注意：在使用before和after时content必不可少。

### content属性

> ::before和::after必须配合content属性来使用，content用来定义插入的内容，content必须有值，至少是空。
>
> 默认情况下，伪类元素的display是默认值inline，可以通过设置display:block来改变其显示。

- string
- attr():调用当前元素的属性，比如图片alt文字或者链接href
- url()/uri():用于引用媒体文件
- counter（）：调用计数器，可以不使用列表元素实现序号功能；

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style type="text/css">
        body {
            counter-reset: section;
        }

        h1 {
            counter-reset: subsection;
        }

        h1:before {
            counter-increment: section;
            content: counter(section) "、";
        }

        h2:before {
            counter-increment: subsection;
            content: counter(section) "." counter(subsection) "、";
        }
    </style>
</head>

<body>
    <h1>HTML tutorials</h1>
    <h2>HTML Tutorial</h2>
    <h2>XHTML Tutorial</h2>
    <h2>CSS Tutorial</h2>
    <h1>Scripting tutorials</h1>
    <h2>JavaScript</h2>
    <h2>VBScript</h2>
    <h1>XML tutorials</h1>
    <h2>XML</h2>
    <h2>XSL</h2>

</body>

</html>
```



### 18.px,rpx,em,rem

1. px（像素）：是最常见的单位，它表示屏幕上的实际像素点。在不同设备上，px 会根据屏幕的分辨率进行换算，因此在不同设备上显示效果可能会有差异。
2. rpx（响应式像素）：是微信小程序中引入的单位，主要用于适配不同尺寸的手机屏幕。rpx 的换算规则是 750rpx 等于屏幕宽度，因此可以通过设置不同尺寸下的 rpx 值来实现适配效果。
3. em：是相对于父元素的字体大小的单位。如果父元素的字体大小为 16px，子元素设置 2em，则子元素的字体大小将会是 32px。
4. rem（相对于根元素的字体大小）：与 em 类似，但是相对的是根元素（即 html 元素）的字体大小。通常情况下，开发者会将根元素的字体大小设置为一个基准值，然后使用 rem 单位来表示其他元素的尺寸。这样可以方便地调整整个页面的比例。

### 19.如何清除浮动？

https://blog.csdn.net/weixin_43638968/article/details/107617275

> 清除浮动主要是为了解决，父元素因为子级元素浮动引起的内部高度为0的问题

1. 额外标签法

>  给谁清除浮动，就在其后额外添加一个空白标签 。
>
>  **优点：** 通俗易懂，书写方便。（`不推荐使用`）
>  **缺点：** 添加许多无意义的标签，结构化比较差。

```html
<div class="fahter">
        <div class="big">big</div>
        <div class="small">small</div>
        <div class="clear">额外标签法</div>
</div>

.clear{
        clear:both;
    }

```

2.父级添加overflow

> 可以通过触发BFC的方式，实现清楚浮动效果。
>
> 必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度
>
> **优点：** 简单、代码少、浏览器支持好
>
> **缺点：** 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。不能和position配合使用，因为超出的尺寸的会被隐藏。

3.使用after伪元素清除浮动

>  `:after`方式为空元素的升级版，好处是不用单独加标签了。IE8以上和非IE浏览器才支持:after，，zoom(IE专有属性)可解决ie6,ie7浮动问题（`较常用推荐`）
>
>  **优点：** 符合闭合浮动思想，结构语义化正确，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）
>
>  **缺点：** 由于IE6-7不支持`：after`，使用`zoom：1`

```html
/*伪元素是行内元素 正常浏览器清除浮动方法*/
.clearfix:after{
        content: "";
        display: block;
        height: 0;
        clear:both;
        visibility: hidden;
    }
/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
    .clearfix{
        *zoom: 1;
    }
 
<body>
    <div class="father clearfix">
        <div class="big">big</div>
        <div class="small">small</div>
        <!--<div class="clear">额外标签法</div>-->
    </div>
    <div class="footer"></div>
</body>

```

4.使用before何after双伪元素清除浮动（常用）

```html
<style>
            .father{
                border: 1px solid black;
                *zoom: 1;
            }
            .clearfix:after,.clearfix:before{
                   content: "";
                   display: block;
                   clear: both;
               }
               .big ,.small{
                width: 200px;
                height: 200px;
                float: left;
               }
               .big{
                background-color: red;
               }
               .small{
                background-color: blue;
               }
        </style>
   <div class="father clearfix">
        <div class="big">big</div>
        <div class="small">small</div>
   </div>
    <div class="footer"></div>

</div>
              

```

### 20.主题库的切换是怎么实现的？暗黑模式？线上换肤？

- css变量+类型切换

> 首先定义全局样式变量，定义集合属性，将其放在html根元素标签里，再通过JS动态切换集合实现主题的切换；

```html
<!DOCTYPE html>
<!-- <html lang="en" data-theme="light"> -->
    <html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>王国梁</title>
    <link rel="shortcut icon" href="./img/w.png" type="image/x-icon">
    <!-- 引入谷歌字体 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Dhurjati&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
        rel="stylesheet">
    <!-- 自定义样式 -->
    <link rel="stylesheet" href="./index.css">
    <style>
        .container {}
    </style>
</head>
 
<body>
    <!-- 标题部分 -->
    <header>
        <a href="#" class="logo"><span>W</span>GL</a>
        <ul class="nav-bar">
            <li><a href="#">首页</a></li>
            <li><a href="#">教育背景</a></li>
            <li><a href="#">技术栈</a></li>
            <li><a href="#">经历</a></li>
            <li><a href="#">博客</a></li>
            <li><a href="#">联系我</a></li>
        </ul>
        <div>
            <span>更多</span>
            <div></div>
        </div>
        <button onclick="toggle()" class="toggle">切换主题</button>
        <!-- <theme-button value="dark" id="btn" size="3"></theme-button> -->
    </header>
    <!-- 自定义js文件链接 -->
    <script src="./index.js"></script>
</body>
 
</html>
```

```scss
*{
    padding: 0;
    margin: 0;
    box-sizing: border-box;
    font-family: "rubik",sans-serif;
    list-style: none;
    text-decoration: none;
}
 
@media screen and (max-width: 768px) {
    
}
 
/* 全局样式变量 */
:root{
    /* 背景色/边框颜色/主色/辅色/其他色 */
    --color-border:#deddee;
    --color-main:#ffae00;
    --color-auxiliary:#00ff11;
    --color-other:#00ffdd;
    --color-bg:#1f1f21;
    --font-color-main:#ffffff;
    --font-color-secondary:#ffffffb3;
    --font-color-auxiliary:#ffffff3b;
    /* 字号和字体颜色 */
    --font-root:1rem;
    --font-32px:2rem;
    --font-20px:1.25rem;
    --font-18px:1.125rem;
    --font-16px:1rem;
    --font-14px:.875rem;
    --font-12px:.75rem;
    --font-10px:.625rem;
    /* 层级 */
    --z-index10:10;
    --z-index100:100;
    --z-index1000:1000;
    /* 间距 */
    --spacing-2:.125rem;
    --spacing-4:.25rem;
    --spacing-6:.375rem;
    --spacing-8:.5rem;
    --spacing-10:.625rem;
    --spacing-12:.75rem;
    --spacing-14:.875rem;
    --spacing-16:1rem;
    --spacing-20:1.25rem;
    --spacing-24:1.5rem;
    --spacing-30:1.875rem;
    --spacing-40:2.5rem;
    --spacing-50:3.125rem;
    --spacing-60:3.75rem;
}
/* 集合属性（主题样式） */
[data-theme="dark"] {
    --color-bg:#1f1f21;
    --color-btn:#ffffff;
    --color-btn-font:#333333;
    --color-border:#deddee;
    --color-main:#ffae00;
    --color-auxiliary:#00ff11;
    --color-other:#00ffdd;
    --font-color-main:#ffffff;
    --font-color-secondary:#ffffffb3;
    --font-color-auxiliary:#ffffff3b;
}
[data-theme="light"] {
    --color-bg:#ffffff;
    --color-btn:#000000;
    --color-btn-font:#ffffff;
    --color-border:#deddee;
    --color-main:#ffae00;
    --color-auxiliary:#00ff11;
    --color-other:#00ffdd;
    --font-color-main:#333333;
    --font-color-secondary:#777777;
    --font-color-auxiliary:#aaaaaa;
}
 
/* 切换按钮 */
.toggle{
    border: none;
    padding: var(--spacing-6);
    font-size: var(--font-14px);
    background-color: var(--color-btn);
    color: var(--color-btn-font);
    border-radius: .25rem;
    transition: all ease .45s;
}
 
body{
    background: var(--color-bg);
    color: var(--font-color-main);
    overflow-x: hidden;
    transition: all 0.5s ease-in-out;
}
 
/* 标题部分 */
header{
    position: fixed;
    top: 0;
    right: 0;
    width: 100%;
    background: transparent;
    z-index: var(--z-index10);
    font-size: var(--font-14px);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spacing-30) 15%;
    transition: all ease .45s;
}
.logo{
    color: var(--font-color-main);
    font-weight: 600;
    font-size: var(--font-32px);
}
.logo span{
    color: var(--color-main);    
}
.nav-bar{
    display: flex;
}
.nav-bar a{
    font-size: var(--font-14px);
    color: var(--font-color-secondary);
    margin:0 var(--spacing-24);
    transition: all ease.5s;
}
.nav-bar a:hover{
    color: var(--color-main);
    font-weight: 600;
}
```

```js
// 切换主题
function toggle() {
    let html = document.querySelector('html')
    let currentTheme = html.getAttribute('data-theme');
 
    if (currentTheme === "light") {
        html.setAttribute('data-theme', 'dark');
    } else {
        html.setAttribute('data-theme', 'light');
    }
}
```

### 21.position属性的用法

- static:包含此属性的元素遵循常规流，即块级元素占一行，行内元素依次排列同一行，当超过父布局最大宽度后自动换行。


- relative：在不设置`top,right,bottom,left`这些属性时，与static无区别，加上后会相对于自身在常规流中的位置进行定位；
- absolute：相对定位`relative`没有脱离文档流，但是`absolute`脱离了文档流；ralative相对于自身在常规流中的位置进行偏移定位，而`absolute`相对于离自身最近的定位祖先元素进行定位；拥有相对定位属性值的祖先元素可以充当拥有绝对定位属性值的子孙元素的定位祖先元素。如果子孙元素没有定位祖先元素，会一直回溯到body元素，使用body元素充当自己的定位祖先元素。

```css
    body {
      border: 1px solid black;
      padding: 12px;
      position: relative;
    }

    .parent {
      width: 300px;
      height: 300px;
      background-color: #ff0;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
```

https://blog.csdn.net/qq_16121469/article/details/122357306

- fixed：fixed相对于窗口进行偏移定位；absolute相对于祖先元素进行偏移定位；

```css
    body {
      border: 1px solid black;
      padding: 12px;
      height: 1000px;
    }

    .center {
      position: fixed;
      width: 100px;
      height: 100px;
      background-color: #f00;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
```

- sticky：类似`relative`和`fixed`的结合，若不设置`top,right,bottom,left`则和static一致；设置了则存在两种状态，以top：10px;为例，若元素相对于窗口顶部距离大于2.px，则处于类似relative相对定位的状态；若小于等于10px，则立马切换到fixed的状态；

```css
       body {
                border: 1px solid black;
                padding: 32px;
                margin: 32px;
                height: 1000px;
            }
            div {
                width: 100px;
                height: 100px;
                position: relative;
            }
            #div1 {
                background-color: red;
            }
            #div2 {
                background-color: black;
                position: sticky;
                top: 100px;
                left: 100px;
                padding: 0;
                margin: 0;
            }
            #div3 {
                background-color: gray;
            }
```

### 22.隐藏元素的方法

- overflow:hidden;
- display:none;
- opacity:0;
- position:absloute; top:-9999px;left:-9999px;
- **visibility:hidden**,元素消失后，位置空间保留，只会导致重绘不会导致重排；
- 设置盒模型属性为0

### 23.css实现三角形

> https://mp.weixin.qq.com/s?__biz=MzU2MTIyNDUwMA==&mid=2247493438&idx=1&sn=86e6cb82dc1e7bf591e38dcc81105552&chksm=fc7ea965cb0920736dcfb8876892c68e5b667db77728aa1b18755cdefce1d82c441c9bafcd48

```css
.triangle {
 border-style: solid;
  border-color: transparent;
  border-width: 50px 0 50px 50px;
  border-left-color: skyblue;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMnSI8IngMJeUCXvxMdFtmGBwIYK5ZCmIhicvPS0jTeqZic7kTMGHB6kjJTuA908awibG0pib2LxAbGfA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



```css
.triangle {
    width: 0;
    height: 0;
    border-top: 100px solid skyblue;
    border-right: 100px solid transparent;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMnSI8IngMJeUCXvxMdFtmGrXwwoUHHQFIPT4VicAgV27R6hR5JVcecIUXAvAl7uBpQianD7JdPwD2Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 三、JS

### 1.基本数据类型

- 基本数据类型

```
number,string,undefined,Boolean,null;
ES6添加：Symbol
```

- 复杂数据类型

```
Object；
```

> 0.1+0.2！=0.3
>
> 浮点数值的最高精度事28位小数，0.1+0.2= 0.30000 0000 0000 0004
>
> 基于IEEE754数值的浮点计算通病；
>
> 只有0.2和0.1有循环数，并且循环数相同 0.1 >> 0.0001 1001 1001 1001…（1001无限循环） 0.2 >> 0.0011 0011 0011 0011…（0011无限循环）

![](https://s3.bmp.ovh/imgs/2023/08/14/a2969685a0c6e552.png)

### 2.ES6新特性

> ES6=ES2015

- 新增块级作用域let,const;

```js
//let 
for(var i=0;i<5;i++){
    console.log(i);
}

console.log(i+1);			//循环体外部能够访问i，使用let不会

//const声明的是常量，不能被修改；
const a=1;

//const 声明的数组不可以被重新赋值，但是可以修改元素；
const names=["A","B"];

```

- 定义类的语法糖；
- 新增基本数据类型Symbol；
- 新增变量解构赋值；

```js
//数组
let arr=[1,2,3]
const [x,y,z]=arr;

//对象
const person={
    name:"Martin",
    age:22,
    languages:['Java','Python']
};

const {name:n,age:a,language:l}=person;
console.log(n,a,l);
```



- 函数参数允许默认值，引入rest参数，新增箭头函数；

https://blog.csdn.net/sinat_41696687/article/details/121903414

```js
// =>不只是function的简写，还有其他优点：和包围他的代码公用this，解决了this指向问题；原理是补获上下文的this；
//如果箭头函数的外层有普通函数，this指向普通函数的this；
//妹有普通函数，this指向全局变量
//有
let obj = {
  fn:function(){
      console.log('我是普通函数',this === obj)   // true
      return ()=>{
          console.log('我是箭头函数',this === obj) // true
      }
  }
}
console.log(obj.fn()())

//妹有
let obj = {
    fn:()=>{
        console.log(this === window);
    }
}
console.log(obj.fn())
// true

//默认值

function add(a,b=1){
    return a+b;
}

//箭头函数是匿名函数，不能作为构造函数，不可以使用new；

//箭头函数不绑定arguments,使用rest参数，妹有super和new.target;
```

- 数组新增API，isArray/from/of,数组实例增加：entries（）,keys(),values（）等方法；

```js
//字符串拓展
let str = "hello ReactJS";
console.log(str,"中是否包含ReactJS",str.includes("ReactJS"));
console.log(str,"是否以h开头",str.startsWith("h"));
console.log(str,"是否以actJS结尾",str.endsWith("actJS"));

//字符串模板
let str = `c
y
l`;
```



- 对象和数组新增拓展运算符号；
- 新增模块化：import,export;

```js
var name='Martin';
export {name};

export function MakeLove(){
    
}


```

- 新增Set()和Map数据结构；
- 原生提供Proxy构造函数，用来生成Proxy实例；
- 新增生成器**Generater**和**Iterator**；



### 3.Bigint

> 支持任意长度的整数：末尾+n；
>
> 不能混用常规的和Bigint

```js
const bigint = 1234567890123456789012345678901234567890n;

const sameBigint = BigInt("1234567890123456789012345678901234567890");

const bigintFromNumber = BigInt(10); // 与 10n 相同
数学运算符
```

```js
let bigint = 1n;
let number = 2;

// 将 number 转换为 bigint
alert(bigint + BigInt(number)); // 3

// 将 bigint 转换为 number
alert(Number(bigint) + number); // 3
```

#### 不支持一元加法



### 4.Promise 和 Await

https://es6.ruanyifeng.com/#docs/promise

- Promise时异步编程的解决方案，比较传统的回调函数和事件更加合理强大；
- 一个用来保存某个未来才会结束的事件；

> Promise对象有以下两个特点：
>
> （1）对象的状态不受外界影响，Promise对象代表一个异步操作，有三种状态：
>
> pending（进行中）、fulfilled（已成功）、rejected（已失败）只有异步操作的结果才能决定状态；
>
> （2）一旦状态改变，不会再变。Promise对象的状态改变只有：pending->fulfilled，pending->rejected
>
> 状态凝固了就是resolved。如果改变已经发生了，再对Promise对象添加回调函数，也会立即得到结果；这与事件不同，事件一旦错过就不再获得结果；
>
> 缺点：
>
> 无法取消Promise，一旦新建就会立即执行，无法中途取消；
>
> 不设置回调函数，Promise内部抛出的错误不会反映到外部；
>
> 当处于pending状态时，无法得知目前进展到哪一个阶段；

```js
//promise构造函数接受一个函数作为参数，该函数的两个参数分别为resolve和reject
//resolve函数是将Promise对象的状态从未完成变成成功；pending->resolved，异步操作成功时调用并将异步操作的结果作为参数传递出去；
//reject函数时将promise对象的状态从未完成变成失败，pending->rejected，异步操作错误时将报错错位参数传递出去；
promise.then(function(valueA){
    
},function(error){
    
})

```

- promise.prototype.then(参数1，参数2)

```js
//Promise实例具有then方法，定义在原型对象上，作为Promise实例添加状态改变时的回调函数；
//可以采用链式写法
getJSON("url").then((res)=>{
    
}).then((error)=>{
    
})
```

- promise.prototype.catch()

```js
//是then的别名，用于指定发生错误时的回调函数
getJson().then((res)=>{
    
}).catch((error)=>{
    console.log(error);
})
```

- promise.prototype.finally()

```js
getJson().then((res)=>{
    
}).catch((error)=>{
    console.log(error);
}).finally(()=>{
    //最后一定执行
})
```

- promise.all()

```js
//用于将多个promise实例，包装成一个新的promise实例
const p=Promise.all([p1,p2,p3]);

//只有p123的状态都称为fulfiled p才会成功；任一个rejected p也会；
const databasePromise = connectDatabase();

const booksPromise = databasePromise
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) => pickTopRecommendations(books, user));
```

- Promise.race():多个实例任一成功都会返回成功；

```js
Promise.resolve().then(()=>{
    console.log(0)
    return Promise.resolve(4)
}).then((res)=>{
    console.log(res)
})


```



### 5.数组方法

##### join() （数组转字符串）

```js
var arr = [1, 2, 3, 4]
console.log(arr)
console.log(arr.join(''))
console.log(arr.join('-'))
console.log(arr)	//原数组不变

//join实现重复字符串
function repeateStr (str, n) {
  return new Array(n + 1).join(str)
}

```

##### push()和pop()

```js
//shift()删除数组第一个元素，并返回该元素的值
//pop 删除并返回最后一个数组元素
```

##### shift()和unshift()

```js
//push 向数组的末尾添加元素
//unshift() 向数组的开头添加一个或多个元素，并返回新的长度
```

##### sort()

```js

// sort() 对数组元素进行排序，并返回当前数组:对字符的排序是按照字母的Unicode码进行排序的
// reverse() 颠倒数组中元素的顺序，并返回当前数组
var arr = [1, 100, 20, 30]
console.log(arr.sort())
console.log(arr.reverse())
//实现数值排序
console.log(arr.sort(function (a, b) {
  return a - b
}))

```

##### concat()  (连接数组)

```js
// concat() 连接两个或多个数组，并返回新的数组
// slice() 选取数组的的一部分，并返回一个新数组
// splice() 从数组中添加或删除元素，并返回被删除的元素
var arr = [1, 2, 3, 4, 5]
console.log(arr.concat([6, 7, 8]))
console.log(arr.slice(1, 3))
console.log(arr.splice(1, 2, 6, 7, 8))

//传入二维数组，将其转化为一维数组
var arr1 = [[1, 2], [3, 4], [5, 6]]
console.log(arr.concat(arr1))		//讲数组当作元素项合并
console.log([].concat.apply([], arr1))		//合并
```

##### slice(start,end) 

·ES5新增·

##### indexOf()  lastIndexOf()  返回首次出现的位置，无返回-1

##### forEach() map(),filter(),some(),every();

```js
var arr = [1, 2, 3, 4, 5]

arr.forEach(function (item, index, arr) {
  console.log(index, item)
})

//指“映射”，方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值
var arr1 = arr.map(function (item, index, arr) {
  return item * 2
})
console.log(arr1)

// “过滤”功能，方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。和filter() 方法类似，jquery中有个 grep()方法也用于数组元素过滤筛选。
var arr2 = arr.filter(function (item, index, arr) {
  return item > 2
})
console.log(arr2)

//判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。
var arr3 = arr.every(function (item, index, arr) {
  return item > 2
})
console.log(arr3)

//判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。
var arr4 = arr.some(function (item, index, arr) {
  return item > 2
})
console.log(arr4)
```

##### reduce(),reduceRight()

```js
//归并方法:迭代数组中的所有项，然后生成一个最终返回值。
//第一个参数是每一项调用的函数，函数接受四个参数分别是初始值，当前值，索引值，和当前数组
//函数需要返回一个值，这个值会在下一次迭代中作为初始值。第二个参数是迭代初始值，参数可选，
//如果缺省，初始值为数组第一项，从数组第一个项开始叠加，缺省参数要比正常传值少一次运算。
//reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
var result = arr.reduce(function (prev, cur, index, arr) {
  return prev + cur
})

console.log(result) // 55
```

·ES6新增方法·

##### Array.from()

```js
let json = {
  //必须是数字
  "0": "zhangsan",
  "1": 18,
  length: 2			//需要长度
}

let arr = Array.from(json)
console.log(arr) // []
```

##### Array.of()



### 6.离线应用和客户端存储

- 离线检测

> HTML5定义了一个navigator.online属性，如果为true表示设备能够上网；

- 应用缓存

> H5使用appcache专门为开发离线Web应用设计；
>
> 从浏览器的缓存区划分一块，使用一个描述文件列出需要下载和缓存的资源；

- 数据存储

  1. ​	Cookie

  > Http Cookie最初在客户端用于存储会话信息。发送回服务器的额外信息可以用于唯一验证客户来自于发送的哪一个请求；

  > 限制：
  >
  > cookie在性质上是绑定在特定的域名下，当设定一个cookie后，再给创建他的域名发送请求时都会包含这个cookie，这个限制是的cookie中的信息只能让批准的接收者访问；无法被其他域访问；
  >
  > 构成:
  >
  > Cookie由名称，值，域，路径，失效时间，安全标志组成；

  2. Web存储机制

  - 提供一个cookie之外存储会话的途径；
  - 提供一种存储大量跨会话的数据机制；

  > storage类型
  >
  > 它提供组大的存储空间，有clear（），getItem(name)，setItem（name,value)等；
  >
  > 只能存储字符串；

  > sessionStorage类型
  >
  > 它用于存储某个会话的数据，也就是数据保存到浏览器关闭时。
  >
  > 存储在sessionStorage中的数据可以跨越页面刷新而存在，同时如果浏览器支持，崩溃之后也能使用；

  ```js
  //使用方法存储数据
  sessionStorage.setItem("name","Martin");
  //使用属性存储数据
  sessionStorage.book="JS";
  ```

  3. globalStorage类型

  ```js
  globalStorage['域名'].name="Martin";
  ```

  4. localStorage类型

> localStorage在H5中作为持久保存客户端数据的方案取代了globalStorage；
>
> 与globalStorage不同；

### 7.cookie设置，token如何实现登录



### 8.闭包

> 如果一个函数访问量此函数的父级或者父级以上的作用域变量，这个函数就是一个闭包；

```js
var a=1;

//匿名立即执行函数，访问了全局变量a;
(
	function test(){
        console.log(a);
    }
)()
```

```js
//常见的闭包形式：函数嵌套

function a(){
    var index=0;
    index=index+1;
    
    function b(){
        index=index+2;
        console.log(index);
    }
    
    return b;
}

var c=a();			//index=0+1; 将函数a赋值给全局变量c时，a会执行一次，局部变量index变为0+1，返回函数b；此时全局变量C为闭包函数b的引用；
c();				//index=0+1+2 //第一次执行c时，闭包函数b第一次执行；
c();				//index=0+1+2+2 //第二次执行c时，闭包函数b第二次执行；
```

##### 特点：

- 被闭包函数访问的父级以上函数的局部变量会一致存在于内存中，不会被JS的垃圾回收机制回收；
- 闭包函数实现了对其他函数内部变量的访问；

##### JS垃圾回收机制：

- 如果一个对象不再被引用，这个对象会被GC回收；
- 如果两个对象相互引用，而不再被第三者所引用，那么这两个对象都会被收回；

##### 闭包的用途：

- 访问函数内部的变量；
- 让变量始终保持在内存中；

##### 应用场景：

- 模拟面向对象的代码风格

```js
function Person(name){
    function Say(content){
        console.log(name+":"+content);
    }
    
    return Say;
}

a=Person("martin");
b=Person("jacy");
a("What are u doing ?");
b("Nothing");
a("Hang out with me ?");
b("To there?");
```

- 使用`setTimeout`支持传参(通过闭包实现setTimeout第一个函数传参)

```js
function func(param){
    return function(){
        console.log(param);
    }
}

var f1=func(1);
setTimeout(f1,1000);
```

- 封装私有变量：通过闭包定义能访问私有函数和私有变量的共有函数

```js
var counter=(function(){
    var privateCounter=0;   //私有变量

    function change(val){
        privateCounter+=val;
    }

    return {
        increment:function(){
            change(1);
        },
        decrement:function(){
            change(-1);
        },
        value:function(){
            return privateCounter;
        }
    };
})();

console.log(counter.value());
console.log(counter.increment());
console.log(counter.increment());
console.log(counter.increment());
console.log(counter.increment());
console.log(counter.value());
```

- 模拟块作用域

![在这里插入图片描述](https://img-blog.csdnimg.cn/764a7d4d2f244f3dbb50fa59da6105eb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyd6ZizMzk=,size_15,color_FFFFFF,t_70,g_se,x_16)

> onclick绑定的function中没有变量i，解析引擎会寻找父级作用域，最终找到全局变量i；for循环结束的时，i的值已经变成了4；所以此时任何onclick点击都会弹出4；
>
> 也可使用let i=0;来解决；

```js
var elements=document.getElementsByTagName('li');
var length=elements.length;

for(var i=0;i<length;i++){
    elements[i].onclick=function(num){
        return function(){
            console.log(num);
        }
    }(i);           //通过匿名闭包，把每次的i保存到一个变量中实现了效果
}
```

- 实现迭代器

```js
function setup(x){
    var i=0;
    return function(){
        return x[i++];
    };
}
var next=setup([1,2,3]);
console.log(next);
console.log(next);
console.log(next);
```

##### 闭包优点：

- 减少全局变量的定义，避免全局变量污染；
- 能够读取函数内部的变量；
- 内存中维护一个变量，用作缓存；

##### 闭包缺点：

- 造成内存泄漏，闭包会使函数中的变量一致保存在内存中，内存消耗极大；

解决方法：使用完毕以后设置为null；

- 闭包可能在父函数外部，改变父函数内部的值；
- 由于闭包设计跨作用域访问，会导致性能损失；

解决方法：通过跨作用域变量存储在局部变量中，直接访问局部变量来减轻对执行素的的影响；

- 防抖

```js
//防抖 避免函数的重复调用 只会调用一次
        function Antishake(fn,wait){ //第一个参数是函数 第二个参数是毫秒值
            let timer = null //声明一个变量来接收延时器 初始值为null
            return function(){
                clearTimeout(timer)
                timer = setTimeout(() => {
                    fn() //调用这函数
                }, wait);
            }
        }
        let an = Antishake(function(){ //用一个变量接收
            console.log('555');
        },2000)
        document.querySelector('div').onmouseenter = ()=>{
            an() //调用一次
        }
```

- 节流

```js
function throttle(fn,wait){
            let timer = null //节点闸
            return function(){
                if(timer) return //null false 不是null结果减少true 如果上传没有我就直接跳过 没有人我就上去
                timer = setTimeout(() => { //上车了
                    fn()
                    timer = null //做完之后重新关闭节点闸
                }, wait);
            }
        }
        let throttle1 = throttle(()=>{
            console.log('我上车了');
        },2000)
        document.querySelector('div').onclick = ()=>{
            throttle1()
        }
```

- 函数柯里化



### 9.如何实现原生ajax？

> Ajax是异步的JS和XML，是一种在无需重新加载整个网页的情况下，更新部分网页的技术；

- 创建XMLHttpRequest对象；

> 老版本的浏览器用的ActiveX对象；
>
> 现代浏览器使用XMLHttpRequest对象；

- 向服务器发送请求；

```
open(method,url,async)		//请求类型，url位置，true同步
send（string）			//仅用于POST；
```

- 服务器响应；

> 1.responseText   字符串形式的数据响应；
>
> 2.responseXML  XML形式的数据响应；

- 判断是否成；

> 1.onreadystatechange    存储函数，每当readystate属性改变时调用；
>
> 2.readyState  			存有XMLHttpRequest的状态；0初始化，1连接建立，2请求已接受，3请求处理中，4请求已完成；
>
> 3.status			200 ok   404 Page not found;

```js
//原生Ajax
function oriAjax(url,){
    //判断浏览器版本
    if(window.XMLHttpRequest){
        var ajaxRequest=new XMLHttpRequest();
    }else{
        var ajaxRequest=new ActiveXObject("Microsoft.XMLHTTP");
    }

    ajaxRequest.open("GET",url,true);

    ajaxRequest.onreadystatechange=function(){
        if(ajaxRequest.readyState==4 && ajaxRequest.status==200){
            //更新dom结点
            document.getElementById("myDiv").innerHTML=ajaxRequest.responseText;
        }else{
            console.log(ajaxRequest.response);
        }
    }
}
```





### 10.JS排序算法底层原理？

sort（）数组长度小于22使用插入排序，大于22快排；



### 11.nextTick(性能优化)

> **在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM**

Vue在更新DOM时是异步执行的，当数据发生变化，vue将开启一个异步更新队列，视图需要等到队列所有数据变化完成之后，再统一进行更细；如果我们一直修改相同数据，异步操作队列还会进行去重，等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿来进行处理，进行DOM的更新

#### 为什么需要nextTick?

```js
{{num}}
for(let i=0; i<100000; i++){
    num = i
}
```

> **如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新10万次视图)，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略**

#### 使用场景

- 如果想在修改数据后立即得到更新后的DOM结构，可以使用Vue.nextTick()
- 第一个参数为：回调函数（可以获取最近的DOM结构）
- 第二个参数为：执行函数上下文

```js
// 修改数据
vm.message = '修改后的值'
// DOM 还没有更新
console.log(vm.$el.textContent) // 原始的值
Vue.nextTick(function () {
  // DOM 更新了
  console.log(vm.$el.textContent) // 修改后的值
})
//组件内使用 vm.$nextTick() 实例方法只需要通过this.$nextTick()，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上

this.message = '修改后的值'
console.log(this.$el.textContent) // => '原始的值'
this.$nextTick(function () {
    console.log(this.$el.textContent) // => '修改后的值'
})
//$nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情

this.message = '修改后的值'
console.log(this.$el.textContent) // => '原始的值'
await this.$nextTick()
console.log(this.$el.textContent) // => '修改后的值'
```

**vue里面有一个虚拟dom，页面上所有的操作都是先改变虚拟dom，最后再把虚拟dom更新到实际的页面dom上，这个时候就会涉及到到一个问题，什么时候才是最后？**

> 这个时候就会涉及到JS事件执行机制中的宏任务和微任务
>
> 1、执行完当前宏任务script，立即执行微任务
>
> 2、微任务执行完毕后进行页面渲染
>
> 3、页面渲染完毕，开始执行$nextTick

简单来说，Vue 在修改数据后，视图不会立刻更新，而是等**同一事件循环**中的所有数据变化完成之后，再统一进行视图更新。

#### created、mounted

> 在created、mounted阶段如果需要操作渲染后的视图，也需要使用nextTick()方法；

```js
mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}
```

> microtast（微任务）：Promise， process.nextTick， Object.observe， MutationObserver
>
> macrotask（宏任务）：script整体代码、setTimeout、 setInterval等
>
> 执行优先级上，先执行宏任务macrotask，再执行微任务mincrotask。

参考题目：https://zhuanlan.zhihu.com/p/641997980





### 12. valueOf

valueOf() 方法用于返回指定对象的原始值，若对象没有原始值，则将返回对象本身。

### 13. 基础类型和引用类型

![](https://s3.bmp.ovh/imgs/2023/08/14/7172ff20fcc7fd2d.png)

### 14.yield

```js

/**
 * @return {Generator<number>}
 */
var fibGenerator = function* () {
  let a = 0, b = 1
  yield a
  yield b
  while (true) {
    yield a + b;
    [a, b] = [b, a + b]
  }
};

/**
* const gen = fibGenerator();
* gen.next().value; // 0
* gen.next().value; // 1
*/

```

### 15.call、apply、bind

> call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向；
>
> call、apply、bind是Function.prototype下的方法，都是用于改变函数运行时上下文，最终返回值就是调用的方法的返回值，若该方法没有返回值，则返回undefined;

```JS
//call 方法第一个参数是要绑定给this的值，第二个参数可选，有的话接收一个参数列表。
//当第一个参数为null、undefined的时候，默认指向window。
A.call(B, x, y, z)

//apply 方法第一个参数是要绑定给this的值，第二个参数可选，有的话是数组形式。
//当第一个参数为null、undefined的时候，默认指向window。
A.apply(B, [x, y, z])

//bind和call很相似，第一个参数是this的指向，第二个参数可选，有的话也是接收参数列表。
//区别在于bind方法返回值是函数，第二个参数是通过返回的函数对象传入。
A.bind(B)(x, y, z)
或者
var C = A.bind(B)
C(x, y, z)

```

|          | CALL           | APPLY      | BIND               |
| -------- | -------------- | ---------- | ------------------ |
| 调用时间 | 立即调用       | 立即调用   | 稍后调用，返回函数 |
| 参数     | 可选，参数列表 | 可选，数组 | 可选，参数列表     |
|          |                |            |                    |

Note：当希望改变上下文环境之后并非立即执行，而是回调执行，使用bind（）方法，而apply、call则会立即执行函数；

```js
//global,name=Martin,global.age=22
var name="Martin";
var age=22;


var p1={
    name:"Jack",
    func:function(){
        console.log(${this.name})
    }
}

var p2={
    name:"Make",
    age:18
}

p1.func()  //Jack 
p1.func.call() //Martin 20
p1.func.apply(p2) //Make 18
p1.func.bind(p2)() //Make 18


function fruits(){}

fruits.prototype={
    color:"red",
    say:function(){
        console.log("My color is"+this.color)
    }
}

var apple=new fruits()
apple.say() //red

banana={
    color:"yellow"
}
//当banana没有某个方法，但是其他的有，我们可以借助call或apply用其他对象的方法来操作

apple.say.call(banana) //yellow
apple.say.apply(banana) //yellow
```

#### 应用场景

- 求数组最大和最小值

```js
var arr=[1,2,33,442,12,3]
var max=Math.max.apply(null,arr)
var min=Math.min.apply(null,arr)
```

- 数组之间追加

```js
var arr1=[1,2,3]
var arr2=[4,5,6]

[].push.apply(arr1,arr2)
```

- 验证是否是数组（前提是toString()方法没有被重写过）

```js
function isArray(obj){
    return Objext.prototype.toString.call(obj)=='[object Array]'
}

isArray([])
isArray('dot')
```

- 类（伪）数组使用数组方法

```js
var trueArr=Array.prototype.slice.call(arrayLike)
var domNodes=Array.prototype.slice.call(document.getElementByTagName("*"))
```

js中存在一种名为伪数组的对象结构，比较特别的是arguments对象，还有像调用getElementByTagName,document.childNodes之类的，他们返回NodeList对象都属于伪数组，不能应用Array下的push、pop等方法；

但是我们能通过Array.prototype.slice.call转换为真正的数组带有length属性的对象，这样domNodes就可以应用Array下的所有方法了；

- 利用call和apply做继承

```js
function Person(name,age){
    //此处this指向实例
    this.name=name
    this.age=age
    this.sayName=function(){
        console.log(this.name,this.age)
    }
}

function Student(){
    Petson.apply(this,arguments) //将父元素所有方法在这里执行i便就继承了
}

var s=new Student("Martin",18)
console.log(s.sayName())
```

- 利用log代理console.log

```js
function log(){
    console.log.apply(console,arguments)
}

function log(){
    var args=Array.prototype.slice.call(arguments)
    args.unshift('(app)')
    console.log.apply(console,args)
}
```

- 绑定函数对象this指向

```js
//为了不改变this的指向，通常会在函数后面加上bind（this）
//es6开始使用箭头函数不会出现指向问题
function f(){}.bind(this)
```

https://blog.csdn.net/qq_39075021/article/details/104313447

### 16.JS继承

#### 原型

> 在 JavaScript 中，对象有一个特殊的隐藏属性 `[[Prototype]]`（如规范中所命名的），它要么为 `null`，要么就是对另一个对象的引用。该对象被称为“原型”

#### 原型继承

> 当从object读取一个缺失的属性时，JS会自动从原型中获取该属性。
>
> 当试图读取eats时，因为不存在于rabbit，所以js会顺着prototype引用，在animal中查找；

```js
let animals={
    eats:true
}

let rabbit={
    jumps:true
}

let littleRabbit = {
    plays: true
}

rabbit.__proto__ = animals
littleRabbit.__proto__ = rabbit

console.log(rabbit.eats) 
console.log(littleRabbit.laugh) //找不到undefined
```

Note:限制

1. 原型链的引用不能形成闭环，js会抛出错误
2. __proto__的值可以是对象，也可以为null，其他类型都会被会略；
3. __proto__是由于历史原型留下来的prototype的getter/setter
4. 现在使用`Object.getPrototypeof/Object.setPrototypeof`代替

Note:this

1. this在对象还是圆形中，在一个方法调用中，this时总是点符号前面的对象；

Note:循环

```js
console.log(Object.keys(rabbit))   //jumps
console.log(Object.keys(littleRabbit)) //plays

for (let prop in littleRabbit) {
    console.log(prop)    //plays jumps eats  从下向上
}

/检查是否为自有的key，hasOwnProperty继承自Object
for (let prop in littleRabbit) {
    let isOwn = littleRabbit.hasOwnProperty(prop)

    if (isOwn) {
        console.log(`Little Rabbits:, ${prop}`)
    } else {
        console.log(`Inherit: ${prop}`)
    }
}

```

![](https://s3.bmp.ovh/imgs/2024/03/08/650468e6ce323e13.png)

#### F.prototype

> 我们可以通过new F()来创建一个新对象，如果F.prototype是一个对象，那么new操作符会使用它为新对象设置[[prototype]]
>
> 请注意，这里的 `F.prototype` 指的是 `F` 的一个名为 `"prototype"` 的常规属性。这听起来与“原型”这个术语很类似，但这里我们实际上指的是具有该名字的常规属性。

Note:默认的prototype属性

每个函数都有prototype属性，即使我们没有提供

默认的prototype是一个只有属性constructor的对象，属性constructor指向函数自身；

```js
function Rabbit () { }

console.log(Rabbit.prototype.constructor == Rabbit) //true

```

![](https://s3.bmp.ovh/imgs/2024/03/08/c8eae0267df5c833.png)

```js
function Rabbit (name) {
    this.name = name
    console.log(name)
}

let rabbit = new Rabbit("White")
let rabbit2 = new rabbit.constructor("Block")
```

> 但是js的默认prototype可以随意替换，我们通过向prototype添加属性来代替将其整个覆盖；

https://zh.javascript.info/native-prototypes

- 原型链继承

> 子类构造函数的prototype指向父类的实例，具有查找特性；
>
> 存在共用同一块内存的缺点，多个实例会彼此影响；
>
> 可以复用父类方法；

- 构造函数继承

> 可以解决原型链继承的缺点，每个子类拷贝父类的属性和方法，这样就不会互相影响
>
> 在子类构造函数中调用父类构造函数；
>
> 缺点：不具备父类原型上定义的属性和方法；

- 组合式继承

> 让子类构造函数的prototype指向父类的实例对象，又在子类构造函数中调用父类的构造函数；
>
> 缺点：调用两次父类构造函数；

- 寄生式继承

> 借助函数创建对象；
>
> 无法实现函数复用；

- 组合寄生式继承

> 构造函数来继承属性，原型链继承方法

- ES6中添加了class关键字

> 本质想是组合寄生式的语法糖；

### 17.js作用域

- 内部的作用域能访问外面的，反之不行；访问时从内向外访问
- 如果内部的作用域中访问了外部的作用域，则会产生闭包
- 内部作用域能访问的外部取决于函数定义的位置，和调用无关
- 作用域内定义的变量、函数声明会提升到作用域顶部



### 18.js对象中的数据存在哪里？深浅拷贝/使用场景



#### 数据类型

- 简单类型：Number、String、Boolean、Undefined、Symbol
- 引用类型：Object

#### 堆栈空间分配区别

- 栈：由操作系统自动分配释放存放函数的参数值，局部变量的值；因为存在栈中的数据访问速度快，因此栈中直接存储变量的值；
- 堆：存储复杂类型，在访问时先从栈拿到堆的存储地址，再去堆中取数据；

![img](https://img-blog.csdnimg.cn/c3721b13cf644f3296009378f2ca6bdd.jpeg)

#### 传值

相当于把变量的值全新的复制了一份

```js
let a=666
log(a) //666

let b=a
a=888
log(a) //888
log(b) //666
```

在JS中只对Number、String、Booleanl等基本数据类型有效

#### 传址

就是类似给变量起了一个新的名字(别名)，但实际上还是原来的存储空间

```js
let a=[1,2,3]
log(a)  //1 2 3

let b=a
a[0]=100

log(a) //100 2 3
log(b) //100 2 3


let o1={
    name:'Martin',
    age:10
}

let b=a
a.name="Jacy"

log(a)
log(b)   //输出一样
```

表示传递的是变量所在的内存地址【内存地址：也就是所谓的指针】因为：堆是传址操作。

**一般情况下：简单(基本)类型赋值是 传值 ！！， 复杂(复合、引用)类型赋值是 传址！！**

#### 深浅拷贝

> 浅拷贝：当对某个数据（数组或对象）进行拷贝后，修改新数据（拷贝后的数据）里面第1层的数据是不会影响老数据（被拷贝的数据）的，但是如果还要第2层 或 更深层次的数据（复杂数据类型），它仍然是有关联的，如果修改了新数据，那么老数据也会被修改。

```js
//浅拷贝：拓展运算符
let a=[1,2,3,[4,5,6]]
log(a)  //1,2,3,[4,5,6]

let b=[...a]
a[0]=100
a[3][1]=500
log(b) //1,2,3,[4,500,6]

//浅拷贝：Object.assign()

```

> 深拷贝：\* 就是在拷贝数据（数组或对象）时，不管数据对象里面有多少层，是简单 还是 复杂数据类型，只要进行深拷贝后，和老数据（之前被拷贝的数据）就毫无关联，相互独立（重新开辟内存空间），互不影响！在修改新数据，对老数据毫无影响。

```js
//深拷贝：JSON.parse(JSON.stringfy(myArr))
let myArr=["1",["2","3",["4","5","6"]]]
let newArr=JSON.parse(JSON.stringfy(myArr))

//深拷贝：deepCopy()自定义方法
//判断是否是数组：
const isArray = (arr) => {
    return Object.prototype.toString.call(arr) === '[object Array]';
};
 
 
//判断是否是对象：
const isObject = (obj) => {
    return typeof obj === 'object' && obj !== null;
};

//数组或对象的深拷贝方法1
const deepCopy = (val) => {
    let oVal = isArray(val) ? [] : {};
    for (let v in val) {
        if (isObject(val[v])) {
            //这里是深拷贝的关键所在（递归调用）
            oVal[v] = deepCopy(val[v]);
        } else {
            oVal[v] = val[v];
        };
    };
    return oVal;
};
 
		
//数组或对象的深拷贝方法2
const deepCopy2 = (val) => {
    let oVal = Array.isArray(val) ? [] : {};
    for (let v in val) {
        if (val.hasOwnProperty(v)) {
            if ('object' === typeof val[v]) {
                //这里是深拷贝的关键所在（递归调用）
                oVal[v] = deepCopy2(val[v]);
            } else {
                oVal[v] = val[v];
            };
        }
    };
    return oVal;
};
 

//数组的深拷贝测试
let myArr = ["HTML", ["CSS", "H5", ["html", "head", ["meta", "title", "style"], "body"], "CSS3"], "ES6", "jQuery"]
let newMyArr = deepCopy(myArr);
 
newMyArr[1][2][2][1] = 'TITLE';
console.log('修改前：', myArr);
console.log('修改后：', newMyArr);

 
//数组对象深拷贝测试
let arr = ['H5', 'CSS', { a: 'PHP', b: 'Java', c: ['A', 'B', ['一', 2, '三'], 3, { d: '3D' }] }, 'ES6'];
let nArr = deepCopy(arr);
			
nArr[2].a = 'Python';		
nArr[2].c[2][0] = '壹壹壹';
console.log('修改前：', arr);
console.log('修改后：', nArr);
 
 
 
 
 
//对象数组深拷贝测试 deepCopy
let obj = { h5: 'H5', cs: 'CSS', back: { a: 'PHP', b: 'Java', c: ['A', 'B', ['一', 2, '三'], 3, { d: '3D' }] }, js: 'ES6', null: null, udf: undefined, fn: function (e) { console.log(666) } };
let nObj = deepCopy(obj);
			
nObj.back.c[0] = 'AAA';
nObj.back.c[2][0] = '壹';
nObj.back.c[2][2] = '叁';
nObj.fn = function(abc){
    alert(888)
}
console.log('修改前：', obj);
console.log('修改后：', nObj);
 
 
 
//对象数组深拷贝测试 deepCopy2
let obj2 = { h5: 'H5', cs: 'CSS', back: { a: 'PHP', b: 'Java', c: ['A', 'B', ['一', 2, '三'], 3, { d: '3D' }] }, js: 'ES6', null: null, udf: undefined, fn: function (e) { console.log(666) } };
 
let nObj2 = deepCopy2(obj);
nObj2.back.c[0] = 'AAA';
nObj2.back.c[2][0] = '壹';
nObj2.back.c[2][2] = '叁';
nObj2.fn = function(abc){
    alert(888)
}
console.log('修改前：', obj2);
console.log('修改后：', nObj2);
 

```

#### 使用场景

> 从服务器获取数据后存在store，通过props传递给界面，此时如果需要对数据进行修改就需要使用深拷贝；



### 19.async\await原理

> JS是单线程语言，为了提高效率就有了异步编程。

#### 回调函数

> 就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。

```js
const fs=require('fs')
fs.readFile('/etc/passwd',(err,data)=>{
    if(err){
        console.log(err)
        return
    }
    console.log(data.toString())
})
```

回调函数最大的问题就是回调低于，既多个回调函数嵌套。增加逻辑的复杂性，容易出错；

```js
fs.readFile(file1,function(err,data){
	fs.readFile(file2,function(err,data){
        
    })
})
```

#### Promise

为了解决回调函数的不足，就有了Promise

```js
const fs=require('fs')

const readFileWithPromise=file=>{
    return new Promise((resolve,reject)=>{
        fs.readFile(file,(err,data>{
            if(err){
                reject(err)
            }else{
            resolve(data)
        }
        })
    })
}


readFileWithPromise('/etc/passwd')
  .then(data => {
    console.log(data.toString())
    return readFileWithPromise('/etc/profile')
  })
  .then(data => {
    console.log(data.toString())
  })
  .catch(err => {
    console.log(err)
  })

```

> Promise实际上是利用编程技巧将回调函数的横向加载改成纵向加载，达到链式调用的效果，避免回调地狱；最大的问题是代码冗余。原来的任务被Promise包装了一下减少了代码嵌套，逻辑清晰；

#### async/await

> 为了解决Promise的问题，async，await在ES7被提出来了

```js
const fs=require('fs')
async function(){
    try{
        var f1=await readFileWithPromise('/etc/passwd')
         var f2=await readFileWithPromise('/etc/profile')
        
    }
    catch(err){
        console.log(err)
    }
}
```

特点：

- 异步async函数的调用，跟普通函数使用方式一样
- async的用法，作为一个关键字放在函数前面，变成了异步函数；
- 异步async函数返回一个promise对象
- async函数配合await使用可以阻塞代码，异步方法；

优点：

- 多个参数传递：promise使用then函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，频繁的解析又重新组合比较麻烦；而利用async和await可以没有这个限制，可以当做普通变量的局部变量来处理，也没有冗余工作；
- 同步和异步一起编写：使用promise的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰；async和await整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个promise对象放在await关键字后面；

- 对promise的优化：async和await是基于promise的，是进一步的一种优化。



#### 情景假设

> js中存在异步行为，例如加载脚本
>
> 当代码运行到加载脚本的代码时，并不会停下等待加载完成再继续，此时我们需要在脚本加载完毕时立即使用。但是目前加载函数并没有提供任何方法来告诉我们加载完毕了。
>
> 那就添加一个callback函数作为第二个参数；

```js
function loadScript(src,callback){
    let script=document.createElement('script')
    script.src=src

    script.onload=()=>callback(script)
    document.head.append(script)
}
```

> 现在我们调用脚本使用如下方法：

```js
loadScript('/my/script.js', function() {
  // 在脚本加载完成后，回调函数才会执行
  newFunction(); // 现在它工作了
  ...
});
    
```

这种被称为“基于回调”的异步编程风格。

#### 在回调中回调

> 如何加载第二个，第三个脚本？
>
> 自然的解决方案是将第二个loadScript加入回调

```
loadScript('/my/script.js', function(script) {

  loadScript('/my/script2.js', function(script) {

    loadScript('/my/script3.js', function(script) {
      // ...加载完所有脚本后继续
    });

  });

});
```

目前还算ok？

#### 处理Error

如果某一个脚本加载失败了？

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Script load error for ${src}`));

  document.head.append(script);
}


//使用
loadScript('/my/script.js', function(error, script) {
  if (error) {
    // 处理 error
  } else {
    // 脚本加载成功
  }
});
```

称为“Error 优先回调（error-first callback）”风格。

#### 厄运金字塔（回调地狱）

```js
loadScript('1.js', function(error, script) {

  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', function(error, script) {
      if (error) {
        handleError(error);
      } else {
        // ...
        loadScript('3.js', function(error, script) {
          if (error) {
            handleError(error);
          } else {
            // ...加载完所有脚本后继续 (*)
          }
        });

      }
    });
  }
});
```

#### Promise

```js
let promise=new Promise(function(resolve,reject){
    
})
```

> 当 executor 获得了结果，无论是早还是晚都没关系，它应该调用以下回调之一：
>
> - `resolve(value)` —— 如果任务成功完成并带有结果 `value`。
> - `reject(error)` —— 如果出现了 error，`error` 即为 error 对象。

> 由 `new Promise` 构造器返回的 `promise` 对象具有以下内部属性：
>
> - `state` —— 最初是 `"pending"`，然后在 `resolve` 被调用时变为 `"fulfilled"`，或者在 `reject` 被调用时变为 `"rejected"`。
> - `result` —— 最初是 `undefined`，然后在 `resolve(value)` 被调用时变为 `value`，或者在 `reject(error)` 被调用时变为 `error`。

实际上，executor 通常是异步执行某些操作，并在一段时间后调用 `resolve/reject`，但这不是必须的。我们还可以立即调用 `resolve` 或 `reject`

```js
let promise = new Promise(function(resolve, reject) {
  // 不花时间去做这项工作
  resolve(123); // 立即给出结果：123
});
```

#### 消费者：then\catch

```js
promise.then(
  function(result) { /* handle a successful result */ },
  function(error) { /* handle an error */ }
);
```

#### 清理：finally

> 当promise settled时执行，无论resolve还是reject

```js
function delay (ms) {
    // 你的代码
    let promise = new Promise(function (resolve, reject) {
        setTimeout(resolve, ms)
    })
    return promise

}

delay(3000).then(() => console.log('runs after 3 seconds'))
```

#### Promise链

> 如果 `.then`（或 `catch/finally` 都可以）处理程序返回一个 promise，那么链的其余部分将会等待，直到它状态变为 settled。当它被 settled 后，其 result（或 error）将被进一步传递下去

#### 错误处理

> - `.catch` 处理 promise 中的各种 error：在 `reject()` 调用中的，或者在处理程序中抛出的 error。
> - 如果给定 `.then` 的第二个参数（即 error 处理程序），那么 `.then` 也会以相同的方式捕获 error。
> - 我们应该将 `.catch` 准确地放到我们想要处理 error，并知道如何处理这些 error 的地方。处理程序应该分析 error（可以自定义 error 类来帮助分析）并再次抛出未知的 error（它们可能是编程错误）。
> - 如果没有办法从 error 中恢复，不使用 `.catch` 也可以。
> - 在任何情况下我们都应该有 `unhandledrejection` 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”。

```js
new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("Whoops!");
  }, 1000);
}).catch(alert);


/错误不会被触发，因为有隐式的try...catch
```

#### Promise API

- Promise.all([]):如果一个promise被reject，那么所有的promise都会立即reject，并且带有error
- Promise.allSettled:等待所有promise settled

> - `{status:"fulfilled", value:result}` 对于成功的响应，
> - `{status:"rejected", reason:error}` 对于 error。

```js
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://no-such-url'
];

Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => { // (*)
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
```

- Promise.race只等待第一个settled的promise并获取其结果
- Promise.any只等待第一个fulfilled的promise，并将其返回。如果都rejected，返回AggregateError；
- Promise.resolve/reject:很少用，使用async或者await代替

#### 微任务Microtask

> - 队列（queue）是先进先出的：首先进入队列的任务会首先运行。
> - 只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务。

当一个promise准备就绪时，他的.then/catch/finally处理程序会被放入队列，并不会立即执行。当js引擎完成当前代码才会从任务队列执行；

#### async/await

> async/await是以更舒服的方式使用promise的特殊性语法；

```js
//async关键字被放置再函数前面，这个函数总是返回一个promise
async function f () {
    console.log("async")
    return 1
}

f().then((res, rej) => {
    console.log(res, rej)
})
```

> await旨在async函数内部工作
>
> 关键字 `await` 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。

```js

async function f () {
    let promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve("Done"), 1000)
    })
    let res = await promise
    console.log(res)
}

f()
```

> `await` 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。



### 20.防抖/节流

> 1.节流（Throttling）：
>
> 节流是一种限制事件处理函数执行频率的技术，确保事件在一定时间间隔内最多执行一次。
> 当一个事件被触发，节流会立即执行事件处理函数，并在指定的时间间隔内忽略任何后续触发的相同事件。
> 适用于需要定期更新的操作，如滚动事件、搜索框输入，确保它们不会太频繁地触发，减轻服务器和客户端的负担。
> 2. 防抖（Debouncing）：
>
> 防抖是一种延迟事件处理函数执行的技术，确保事件触发后，在指定的时间内没有更多事件触发时才执行一次事件处理函数。
> 当一个事件被触发，防抖会等待一段时间，如果在这段时间内没有更多事件触发，那么事件处理函数将被执行。
> 适用于防止重复提交表单、搜索建议等需要等待用户停止输入的场景。
>
> 
>
> 1.触发方式：节流是在一定时间间隔内最多执行一次事件处理函数，而防抖是等待一段时间后执行事件处理函数，如果在等待期间有新的触发事件，等待时间会被重新计时。
>
> 2.应用场景：节流适用于需要限制事件频率的场景，确保事件在一定间隔内触发；防抖适用于需要等待用户停止操作后才执行的场景，例如搜索建议、输入框验证。

```js
function throttle(fn, delay) {
  let lastExecutionTime = 0;
  return function(...args) {
    const currentTime = Date.now();
    if (currentTime - lastExecutionTime >= delay) {
      fn(...args);
      lastExecutionTime = currentTime;
    }
  };
}
```



```js
function debounce(fn, delay) {
    let timer;
    return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
        fn(...args);
        }, delay);
    };
}
```





https://blog.csdn.net/qq_43000315/article/details/125361625

#### 防抖

> 当事件触发后，延迟n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时；
>
> 作用：高频率触发的事件，在指定的单位时间内只响应最后一次，如果在指定的时间内再次触发，则重新计算时间；

#### 防抖应用场景

- 登录、发短信等按钮避免用户点击过快，以至于发送多次请求；
- 调整浏览器窗口大小，造成计算过多，此时改成一次到位；
- 文本编辑器实时保存，当无任何更改操作一秒后进行保存；

![img](https://img-blog.csdnimg.cn/65a4e609e491477aaf3570af0faf015d.png)

```js
    // 防抖函数
    function debounce(fn, wait) {
        let timer;
        return function() {
            let _this = this;
            let args = arguments;
            if(timer) { clearTimeout(timer) }
            timer = setTimeout(function(){
                fn.apply(_this, args)
            }, wait);      
        }
    }
    // 使用
    window.onresize = debounce(function() {console.log('resize')}, 500)


```

#### 节流

> 控制事件发生的频率，如控制为1s发生一次或者一分钟一次；
>
> 作用：高频率触发的事件，在指定的单位时间内只响应第一次；

#### 节流应用场景

- 鼠标连续不断触发事件，单位时间内只触发一次；
- 监听滚动事件，比如是否滑倒底部加载更多，懒加载；
- 浏览器播放事件，每个疫苗计算一次进度等；

![在这里插入图片描述](https://img-blog.csdnimg.cn/3aa001a577bb4c26a350f61d11ed1740.png)

```js
    // 方式1: 使用时间戳
    function throttle1(fn, wait) {
        let time = 0;
        return function() {
            let _this = this;
            let args = arguments;
            let now = Date.now()
            if(now - time > wait) {
                fn.apply(_this, args);
                time = now;
            }
        }
    }
    
    // 方式2: 使用定时器
    function thorttle2(fn, wait) {
        let timer;
        return function () {
            let _this = this;
            let args = arguments;
            
            if(!timer) {
                timer = setTimeout(function(){
                    timer = null;
                    fn.apply(_this, args)
                }, wait)
            }
        }
    }

```





### 21. null undefined

> 值 `null` 和 `undefined` 是特殊的：它们只在 `==` 下相等，且不相等于其他任何值。
>
> 大于/小于比较，在比较字符串时，会按照字符顺序逐个字符地进行比较。其他类型则被转换为数字。

### 22.NFE

```js
let sayHi = function () {
    console.log("Hi")
}

console.log(sayHi.name); // sayHi（有名字！）
```

> 上下文命名：如果函数没有自己提供，那么在赋值2中，会根据上下文推测一个；

```js
let user = {

    sayHi () {
        // ...
    },

    sayBye: function () {
        // ...
    }

}

console.log(user.sayHi.name) // sayHi
console.log(user.sayBye.name) // sayBye

// 函数是在数组中创建的
let arr = [function() {}];

alert( arr[0].name ); // <空字符串>
// 引擎无法设置正确的名字，所以没有值
```

#### 命名函数表达式NFE（Named Function Expression）

Note:函数名称的特殊点

1. 允许函数在内部引用自己
2. 在函数外是不可见的

```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // 使用 func 再次调用函数自身
  }
};

sayHi(); // Hello, Guest

// 但这不工作：
func(); // Error, func is not de
```

用于避免原始变量被函数外部代码改变

```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi("Guest"); // Error: sayHi is not a function
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Error，嵌套调用 sayHi 不再有效！
```

> 给函数表达式添加的可选的名字，正是用来解决这类问题的。

```js
function sum(a) {

    let currentSum = a;
  
    function f(b) {
      currentSum += b;
      return f;
    }
  
    f.toString = function() {
      return currentSum;
    };
  
    return f;
  }
  
  alert( sum(1)(2) ); // 3
  alert( sum(5)(-1)(2) ); // 6
  alert( sum(6)(-1)(-2)(-3) ); // 0
  alert( sum(0)(1)(2)(3)(4)(5) ); // 15
```

### 23.setTimeout和setInterval

> 目前有两种方式可以实现：
>
> - `setTimeout` 允许我们将函数推迟到一段时间间隔之后再执行。
> - `setInterval` 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。

```js
function count (start, step) {
    console.log(start + step)
}

setTimeout(count, 1000, 0, 1)
```

> setTimeout期望得到的是一个对函数的引用

#### 取消调度clearTimeout

```js
let timerId = setTimeout(() => alert("never happens"), 1000);
alert(timerId); // 定时器标识符

clearTimeout(timerId);
alert(timerId); // 还是这个标识符（并没有因为调度被取消了而变成 null）
```

#### setInterval

```js
let start = 0


function count (step) {
    start+=step
    console.log(start)
}

let timer = setInterval(() => {
    count(1)
}, 1000)
```

#### 取消interval

```js
let timer = setInterval(() => {
    count(1)
}, 1000)

setTimeout(() => {
    clearInterval(timer)
}, 5000)
```

#### 嵌套的setTmeout

```js
let delay = 5000;

let timerId = setTimeout(function request() {
  ...发送请求...

  if (request failed due to server overload) {
    // 下一次执行的间隔是当前的 2 倍
    delay *= 2;
  }

  timerId = setTimeout(request, delay);

}, delay);
```

#### -零延时的setTimeout

```js
setTimeout(() => alert("World"));

alert("Hello");

//hello world
```

### 24.事件循环

https://zh.javascript.info/event-loop

#### 宏任务

> 1. 引擎执行任务时永远不会进行渲染，如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对DOM的更改
> 2. 如果一项任务执行花费的事件过长，浏览器将无法执行其他任务，此时建议终止；

#### 拆分CPU过载任务

```js
let i = 0;

let start = Date.now();

function count() {

  // 将调度（scheduling）移动到开头
  if (i < 1e9 - 1e6) {
    setTimeout(count); // 安排（schedule）新的调用
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  }

}

count();
```

#### 进度指示

```js
<div id="progress"></div>

<script>

  function count() {
    for (let i = 0; i < 1e6; i++) {
      i++;
      progress.innerHTML = i;
    }
  }

  count();
</script>
```

#### 事件后做一些事

```js
menu.onclick = function() {
  // ...

  // 创建一个具有被点击的菜单项的数据的自定义事件
  let customEvent = new CustomEvent("menu-open", {
    bubbles: true
  });

  // 异步分派（dispatch）自定义事件
  setTimeout(() => menu.dispatchEvent(customEvent));
};
```

#### 宏任务和微任务

> 微任务来自于代码，通常由promise创建，对`.then/catch/finally`处理程序的执行会成为微任务。为人与也被用于await的幕后。
>
> 特殊函数：`queueMicrotask(func)`它对func进行排队，一再微任务队列执行；
>
> 每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务或渲染，或进行其他操作；

```js
setTimeout(() => console.log("timeout"))

Promise.resolve().then(() => console.log("Promise"))

console.log("Code")
```

1. `code` 首先显示，因为它是常规的同步调用。
2. `promise` 第二个出现，因为 `then` 会通过微任务队列，并在当前代码之后执行。
3. `timeout` 最后显示，因为它是一个宏任务。

![](https://s3.bmp.ovh/imgs/2024/03/09/c4866918906d0a11.png)

##### Notice

- 微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成。这很重要，因为它确保了微任务之间的应用程序环境基本相同（没有鼠标坐标更改，没有新的网络数据等）。
- 如果我们想要异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么我们可以使用 `queueMicrotask` 来对其进行安排（schedule）。

#### 总结

更详细的事件循环算法（尽管与 [规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model) 相比仍然是简化过的）：

1. 从 **宏任务** 队列（例如 “script”）中出队（dequeue）并执行最早的任务。
2. 执行所有微任务：
   - 当微任务队列非空时：
     - 出队（dequeue）并执行最早的微任务。
3. 如果有变更，则将变更渲染出来。
4. 如果宏任务队列为空，则休眠直到出现宏任务。
5. 转到步骤 1。

##### 测试题

- 代码

```js
console.log(1); /M1

setTimeout(() => console.log(2)); /H1

Promise.resolve().then(() => console.log(3));  /w1

Promise.resolve().then(() => setTimeout(() => console.log(4)));   /W2 -> H3

Promise.resolve().then(() => console.log(5)); /W3

setTimeout(() => console.log(6)); /H2

console.log(7); /M2

1 7 3 5 2 6 4
```

```js
console.log(1);
// 第一行立即执行，它输出 `1`。
// 到目前为止，宏任务队列和微任务队列都是空的。

setTimeout(() => console.log(2));
// `setTimeout` 将回调添加到宏任务队列。
// - 宏任务队列中的内容：
//   `console.log(2)`

Promise.resolve().then(() => console.log(3));
// 将回调添加到微任务队列。
// - 微任务队列中的内容：
//   `console.log(3)`

Promise.resolve().then(() => setTimeout(() => console.log(4)));
// 带有 `setTimeout(...4)` 的回调被附加到微任务队列。
// - 微任务队列中的内容：
//   `console.log(3); setTimeout(...4)`

Promise.resolve().then(() => console.log(5));
// 回调被添加到微任务队列
// - 微任务队列中的内容：
//   `console.log(3); setTimeout(...4); console.log(5)`

setTimeout(() => console.log(6));
// `setTimeout` 将回调添加到宏任务队列
// - 宏任务队列中的内容：
//   `console.log(2); console.log(6)`

console.log(7);
// 立即输出 7
```

> Event Loop即事件循环，JS为单线程语言，同一时间内只能做一件事情，但是并不意味着单线程就是阻塞，实现单线程非阻塞的方法就是事件循环；
>
> 同步任务：立即执行的任务，一般进入主线程执行；
>
> 异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等；

> 同步任务进入主线程，异步任务进入任务队列，会在分为宏任务（宏任务队列）和微任务（微任务队列）；
>
> 当主线程任务为空时，检查微任务的任务队列，全部执行完后执行宏任务队列；
>
> 每执行完一个宏任务就清空一次微任务队列，此过程不断重复，这就是Event Loop

- 宏任务

  > - setInterval()
  > - setTimeout()
  > - setImmediate()
  > - ajax
  > - 事件绑定

- 微任务

  > - new Promise()后的then与catch函数
  > - new MutaionObserver()
  > - process.nextTick（Nodejs）

```js
setTimeout(() => {
    console.log('异步1任务time1');
    new Promise(function (resolve, reject) {
        console.log('异步1宏任务promise');
        setTimeout(() => {
            console.log('异步1任务time2');
        }, 0);
        resolve();
    }).then(function () {
        console.log('异步1微任务then')
    })
}, 0);

console.log('主线程宏任务');

setTimeout(() => {
    console.log('异步2任务time2');
}, 0);

new Promise(function (resolve, reject) {
    console.log('宏任务promise');
    // reject();
    resolve();
}).then(function () {
    console.log('微任务then')
}).catch(function () {
    console.log('微任务catch')
})

console.log('主线程宏任务2');
```



```node
主线程宏任务
宏任务promise
主线程宏任务2
微任务then
异步1任务time1
异步1宏任务promise
异步1微任务then
异步2任务time2
异步1任务time2
```





### 25.Symbol类型

> 只有两种原始类型可以用作对象属性键：
>
> - 字符串类型
> - symbol类型
>
> 否则，如果使用另一种类型，例如数字，它会被自动转换为字符串。

Symbo表示唯一的标识符；

```js
//创建一个描述为“id”symbol
let id = Symbol("ID")

let id1 = Symbol("ID")
let id2 = Symbol("ID")

console.log(id.toString())
```

#### 隐藏属性

symbol允许我们创建对象的隐藏属性，代码的任何其他部分都不能意外访问或重写这些属性；

```js
let user = {
    name: "John"
}

let id = Symbol("ID")
user[id] = 1

console.log(user[id])  //1
console.log(user.id)  //undefined
```

> 因为我们可能会影响代码库中的其他预定义行为。但 symbol 属性不会被意外访问到。第三方代码不会知道新定义的 symbol，因此将 symbol 添加到 `user` 对象是安全的。
>
> 另外，假设另一个脚本希望在 `user` 中有自己的标识符，以实现自己的目的。

#### 对象字面量中的symbol

```js
let id = Symbol("id")
let user = {
    name: "John",
    [id]: 123
}

console.log(user[id])
console.log(user.id)
```

#### symbol在for...in会被跳过

> Object.keys也会忽略
>
> Object.assign会同时复制字符串和symbol属性

#### 全局Symbol

```js
//从全局注册表读取
let id = Symbol.for("id")

//再次读取
let idAgain = Symbol.for("id")

console.log(id === idAgain)
```

#### keyFor

```js
let id = Symbol("ID")

//从全局注册表读取
let id1 = Symbol.for("id")

//再次读取
let idAgain = Symbol.for("id")


console.log(id1, idAgain)   //Symbol(id) Symbol(id)
console.log(Symbol.keyFor(id1))  //id
```

使用全局symbol注册表来查找symbol的键

#### 系统Symbol



### 26.Proxy

> 一个Proxy对象包装另一个对象并拦截诸如读取/写入和其他操作。可以选择自行处理谈么；

#### 语法

```js
let proxy=new Proxy(target,handler)
```

- target:要包装的对象，可以为任何东西，包括函数
- handler：代理配置，带有捕捉器的对象。

```js
let target = {}
let proxy = new Proxy(target, {})
proxy.test = 5

console.log(proxy.test)  //5

console.log(target.test) //5

for (let key in proxy) {
    console.log(key)    //test
}
```

![](https://s3.bmp.ovh/imgs/2024/03/09/1b3272f7f331cfb7.png)

以上是没有捕捉器的状态，对于对象的大多数操作，JS规范中哟一个所谓的内部方法，描述了最底层的工作方式，例如[Get]用于读取属性的内部方法，[Set]用于写入属性的内部方法；

Proxy 捕捉器会拦截这些方法的调用。

#### 带有Get捕捉器的默认值

要拦截读取操作，handler因该有`get(target,property,receiver)`方法，读取属性时触发。

```js
let numbers = [1, 2, 3, 4]

numbers = new Proxy(numbers, {
    get (target, prop) {
        if (prop in target) {
            return target[prop]
        } else {
            return 0
        }
    }
})


console.log(numbers[1])    //2
console.log(numbers[5])   //0，没有这个数组项
```

#### 使用set捕捉器进行验证

```js
let nums = []

nums = new Proxy(nums, {
    set (target, prop, val) {
        if (typeof val == 'number') {
            target[prop] = val
            return true
        } else {
            return false
        }
    }
})

nums.push(1)
nums.push(123)
//nums.push("TEST")  //报错

console.log(nums)
```

#### 使用ownKeys和getOwnPropertyDescriptor进行迭代

> 迭代方法：
>
> - `Object.getOwnPropertyNames(obj)` 返回非 symbol 键。
> - `Object.getOwnPropertySymbols(obj)` 返回 symbol 键。
> - `Object.keys/values()` 返回带有 `enumerable` 标志的非 symbol 键/值（属性标志在 [属性标志和属性描述符](https://zh.javascript.info/property-descriptors) 一章有详细讲解)。
> - `for..in` 循环遍历所有带有 `enumerable` 标志的非 symbol 键，以及原型对象的键。

```js
let user = {
    name: "John",
    age: 30,
    _password: "123123"
}


user = new Proxy(user, {
    ownKeys (target) {
        return Object.keys(target).filter(key => !key.startsWith("_"))
    }
})


for (let key in user) {
    console.log(key)
}

console.log(Object.keys(user))
console.log(Object.getOwnPropertyNames(user))
```

```js
let user = { };

user = new Proxy(user, {
  ownKeys(target) {
    return ['a', 'b', 'c'];
  }
});

alert( Object.keys(user) ); // <empty>
```

为什么？原因很简单：`Object.keys` 仅返回带有 `enumerable` 标志的属性。为了检查它，该方法会对每个属性调用内部方法 `[[GetOwnProperty]]` 来获取 [它的描述符（descriptor）](https://zh.javascript.info/property-descriptors)。

https://zh.javascript.info/proxy



### 27.数字类型转换

- 除法：string类型的值会转换成数字类型

| 值              | 变成……                                                       |
| :-------------- | :----------------------------------------------------------- |
| `undefined`     | `NaN`                                                        |
| `null`          | `0`                                                          |
| `true 和 false` | `1` and `0`                                                  |
| `string`        | 去掉首尾空白字符（空格、换行符 `\n`、制表符 `\t` 等）后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 `0`。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 `NaN`。 |

- Boolean类型转换

> 转换规则如下：
>
> - 直观上为“空”的值（如 `0`、空字符串、`null`、`undefined` 和 `NaN`）将变为 `false`。
> - 其他值变成 `true`。

- 二元运算符号+

```js
 2 + 2 + '1'   //41
'1'+2+2       //122
//二元 + 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。

let apples = "2";
let oranges = "3";

// 在二元运算符加号起作用之前，所有的值都被转化为了数字
alert( +apples + +oranges ); // 5

// 更长的写法
// alert( Number(apples) + Number(oranges) ); // 5
```

- x++,++x

> 详细点说。我们知道，所有的运算符都有返回值。自增/自减也不例外。前置形式返回一个新的值，但后置返回原来的值（做加法/减法之前的值）。

```js
"" + 1 + 0          //"10"
"" - 1 + 0   //-1
true + false  //1
6 / "3"   // 2
"2" * "3" //6
4 + 5 + "px" //"9px"
"$" + 4 + 5 //"$45"
"4" - 2 //2
"4px" - 2 //NaN
"  -9  " + 5 //" -9 5" 带字符串的加法会将数字 5 加到字符串之后。
"  -9  " - 5 //-14
null + 1 //1
undefined + 1  // NaN undefined 经过数字转换之后会变为 NaN。
" \t \n" - 2 //-2
```





### 28.浏览器事件简介

**鼠标事件：**

- `click` —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）。
- `contextmenu` —— 当鼠标右键点击一个元素时。
- `mouseover` / `mouseout` —— 当鼠标指针移入/离开一个元素时。
- `mousedown` / `mouseup` —— 当在元素上按下/释放鼠标按钮时。
- `mousemove` —— 当鼠标移动时。

**键盘事件**：

- `keydown` 和 `keyup` —— 当按下和松开一个按键时。

**表单（form）元素事件**：

- `submit` —— 当访问者提交了一个 `<form>` 时。
- `focus` —— 当访问者聚焦于一个元素时，例如聚焦于一个 `<input>`。

**Document 事件**：

- `DOMContentLoaded` —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时。

**CSS 事件**：

- `transitionend` —— 当一个 CSS 动画完成时。





### 29.对象

#### 属性存在性测试，“in”操作符

```js
let user = {
    name: "WLS"
}

console.log(user.noSuchProperty === undefined)

console.log('name' in user)
```

#### for ... in  循环

```js
for(ket in obj){}
```

#### 对象引用和复制

赋值了对象的变量存储的并不是对象本身，而是该对象“在内存中的地址”，换句话说激素hi该对象的“引用”

当一个对象变量被赋值的时候，引用被复制而该对象本身并没有被赋值；

```js
let a = {}

let b = a

console.log(a === b)  //true
console.log(a == b)  //true
```

```js
/两个独立的对象
let a = {}

let b = {}

console.log(a === b)  //false
console.log(a == b)  //false
```

#### 克隆与合并，Object.assign

```js
let user = {
    name: "John", age: 30
}

let cloneUser = {}

for (let key in user) {
    cloneUser[key] = user[key]
}


cloneUser.name = "Martin"
console.log(cloneUser.name) //martin
console.log(user.name)     //john
```

```js
let user = {
    name: "Martin",
    canView: false,  /已存在的属性会被覆盖
    age: 25
}

let permission1 = {
    canView: true
}

let permission2 = {
    canEdit: true
}


Object.assign(user, permission1, permission2)

console.log(user)
```

> 可以用 `Object.assign` 代替 `for..in` 循环来进行简单克隆
>
> 其他克隆语法：{...user}

#### 深层克隆

> 1. JSON.parse(JSON.stringfy(obj))：娶不到值为undefined的key；如果对象里面有函数，函数无法被拷贝下来；无法拷贝源对象原型链上的属性和方法；对象转为Date字符串
> 2. 递归复制
> 3. lodash的cloneDeep方法

```js
let user = {
    name: "Martin",
    score: [100, 90, 90, 99,],
    sizes: {
        height: 170,
        weight: 55
    }
}


// let cloneUser = JSON.parse(JSON.stringify(user))

//let cloneUser = Object.assign({}, user)

function deepClone (sObj) {
    if (typeof sObj !== 'object' || sObj == null) {
        return sObj
    }

    const target = Array.isArray(sObj) ? [] : {}

    for (const key in sObj) {
        if (Object.prototype.hasOwnProperty.call(sObj, key)) {
            if (typeof sObj[key] === 'object' && sObj[key] !== null) {
                target[key] = deepClone(sObj[key])
            } else {
                target[key] = sObj[key]
            }
        }


    }
    return target
}

let cloneUser = deepClone(user)

cloneUser.sizes.height = 180

console.log(cloneUser)
console.log(user)
```

##### 解决循环引用和symbol类型

```js
let user = {
    name: "Martin",
    score: [100, 90, 90, 99,],
    sizes: {
        height: 170,
        weight: 55
    }
}


// let cloneUser = JSON.parse(JSON.stringify(user))

//let cloneUser = Object.assign({}, user)

function deepClone (sObj, hash = new WeakMap()) {
    if (typeof sObj !== 'object' || sObj == null) {
        return sObj
    }

    if (hash.has(sObj)) {
        return hash.get(sObj)
    }

    const target = Array.isArray(sObj) ? [] : {}

    Reflect.ownKeys(sObj).forEach(key=>{
        const val=sObj[key]
        if(typeof val ==='object' && val !=null){
            target[key]=deepClone(val,hash)
        }else{
            target[key]=val
        }
    })

    return target
}

let cloneUser = deepClone(user)

cloneUser.sizes.height = 180

console.log(cloneUser)
console.log(user)
```



#### 垃圾回收

##### 可达性

- 只要在没有指针指向变量，就可以回收
- 环形引用但是没有其他指针指向也可以回收

##### mark-and-sweep算法

垃圾回收的基本算法被称为 “mark-and-sweep”。

定期执行以下“垃圾回收”步骤：

- 垃圾收集器找到所有的根，并“标记”（记住）它们。
- 然后它遍历并“标记”来自它们的所有引用。
- 然后它遍历标记的对象并标记 **它们的** 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
- ……如此操作，直到所有可达的（从根部）引用都被访问到。
- 没有被标记的对象都会被删除。

##### 优化

- 分代收集：对象被分为两组，新的和旧的，长期存在的对象会变得老旧并且检查次数降低
- 增量收集：引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。
- 闲时收集： 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响

![](https://s3.bmp.ovh/imgs/2024/03/12/11dc63a5e18798c8.png)

#### 对象方法this

https://zh.javascript.info/object-methods





### 30.柯里化

柯里化是一种函数的转换，它是指将一个函数从可调用的 `f(a, b, c)` 转换为可调用的 `f(a)(b)(c)`。

柯里化不会调用函数。它只是对函数进行转换。

```js
function curry (f) {
    return function (a) {
        return function (b) {
            return f(a, b)
        }
    }
}


function sum (a, b) {
    return a + b
}

let curriedSum = curry(sum)

console.log(curriedSum(1)(2))
```



#### 用处

1. 柯里化之后，我们没有丢失任何东西：`log` 依然可以被正常调用。
2. 我们可以轻松地生成部分应用函数，例如用于生成今天的日志的部分应用函数。

#### 高阶柯里化实现

```js
function curry (func) {
    return function curried (...args) {
        if (args.length >= func.length) {
            return func.apply(this, args)
        } else {
            return function (...args2) {
                return curried.apply(this, args.concat(args2))
            }
        }
    }
}


function sum (a, b, c) {
    return a + b + c
}

let curriedSum = curry(sum)

console.log(curriedSum(1, 2, 3,))
console.log(curriedSum(1)(2)(3))
console.log(curriedSum(1, 2)(3))
```

当我们运行它时，这里有两个 `if` 执行分支：

1. 如果传入的 `args` 长度与原始函数所定义的（`func.length`）相同或者更长，那么只需要使用 `func.apply` 将调用传递给它即可。
2. 否则，获取一个部分应用函数：我们目前还没调用 `func`。取而代之的是，返回另一个包装器 `pass`，它将重新应用 `curried`，将之前传入的参数与新的参数一起传入。



### 31.变量提升

> ES6 中新增 let 和 const 关键字，解决了变量提升的问题

> 变量提升指 js 代码执行过程中，JS 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为，变量提升后，会设置默认值 undefined

```js
console.log(num)
var num = 1
```

等同于

```js
var num
console.log(num)
num = 1
```

在函数作用域中也会存在变量提升，除了变量，函数实际上也存在提升。

> 变量提升和 JS 的编译过程有关，JS 在编译阶段，会搜集所有的变量声明，并且让声明生效，而剩下的语句需要等到执行阶段才能生效。

#### 变量覆盖

```js
var name = 'JavaScript'
function showName() {
  console.log(name)
  if (0) {
    var name = 'CSS'
  }
}
showName()
```

> 当执行 showName 函数调用的时候，会创建 showName 函数的执行上下文，之后 js 便开始执行 showName 函数内的代码，首先 showName 内部的代码。首先执行的是

```js
console.log(name)
```

> 一个 name 在全局上下文值为“JavaScript”
>
> 另一个在 showName，因为 if（0）永远不执行，所以 name 为 undefined

```js
function getNum() {
  var num 
  console.log(num) 
  num = 1  
}
getNum() //undefined
```

#### 变量没有被销毁

```js
function foo() {
  for (var i = 0; i < 5; i++) {}
  console.log(i)
}
foo() //5
```

#### 函数的声明

```js
//变量式声明
fn()
var fn = function () {
 console.log(1)  
}
// 输出结果：Uncaught TypeError: fn is not a function

//函数式声明
foo()
function foo () {
 console.log(2)
}
// 输出结果：2
```

#### 为什么会有变量提升？

ES6以前，作用域分为两种：

- **全局作用域**中的对象在代码中的任何地方都可以访问，其生命周期伴随着页面的生命周期。
- **函数作用域**是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

ES6以前不支持块级作用域；

#### 变量提升的好处

- 提高性能：JS执行前会进行语法检查和预编译，并且只执行一次。预编译时会统计声明了那些变量、创建了那些函数，并对函数代码进行压缩，去除注释和空白。每次执行函数都可以直接为该函数分配栈空间；
- 容错性更好：如果没有变量提升，以下代码会报错；

```js
a = 1;
var a;
console.log(a); // 1
```

#### 禁用变量提升

为了解决上述问题，**ES6 引入了 let 和 const 关键字**，从而使 JavaScript 也能像其他语言一样拥有块级作用域。let 和 const 是不存在变量提升的。

```js
console.log(num) 
let num = 1

// 输出结果：Uncaught ReferenceError: num is not defined
```

####  ES6是如何做到既要支持变量提升的特性，又要支持块级作用域？

```js
function fn(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
      console.log(d)
    }
    console.log(b) 
    console.log(c)
}   
fn()
```

- 创建执行上下文

![img](https://pic2.zhimg.com/80/v2-d0c52b3ffaf9f5068bf670437e78302d_720w.webp)

> 1. 通过var声明的变量，在编译阶段会被存放到变量环境中；
> 2. 通过let声明的变量，在编译阶段会被存放到词法环境中；
> 3. 函数作用域内部，通过let声明的变量并没有被放到词法环境中；

块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎就同时支持了变量提升和块级作用域。

#### 暂时性死区

```js
var name = 'JavaScript';
{
 name = 'CSS';
 let name;
}

// 输出结果：Uncaught ReferenceError: Cannot access 'name' before initialization
```

ES6 规定：如果区块中存在 let 和 const，这个区块对这两个关键字声明的变量，从一开始就形成了封闭作用域。假如尝试在声明前去使用这类变量，就会报错。这一段会报错的区域就是暂时性死区。

暂时性死区的本质：当程序的控制流程在新的作用域进行实例化时，在此作用域中用 let 或者 const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这段时间，就称之为暂时死区。

在 let 和 const关键字出现之前，typeof运算符是百分之百安全的，现在也会引发暂时性死区的发生，像import关键字引入公共模块、使用new class创建类的方式，也会引发暂时性死区，究其原因还是变量的声明先与使用。

https://zhuanlan.zhihu.com/p/438563024



### 32.`setInterval`的间隔时间是准确的吗? 如何做到间隔时间绝对准确

https://www.zhihu.com/question/301356245

> 不是准确的，因为`setInterval`的回调函数并不是时间到了就立即执行，而是系统资源空闲之后才会执行。因为 JS 是单线程语言。而下一次触发时间则是在 setInterval 回调函数执行完毕之后才开始计时。所以如果 setInterval 内执行的计算过于耗时，或者有其他任务在执行，那么其计时会越来越不准。
>
> setInerval()，setTimeout()是宏任务

解决方法：

- 使用动态时间纠正

- 使用 Web Worker 为 JS 创造多线程环境

> 允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在[后台运行](https://www.zhihu.com/search?q=后台运行&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2363760138})，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。

```js
// index.js
let count = 0
//耗时任务
setInterval(function () {
  let i = 0
  while (i++ < 100000000);
}, 0)

// worker
let worker = new Worker('./worker.js')

// worker.js
let startTime = new Date().getTime()
let count = 0
setInterval(function () {
  count++
  console.log(
    count + ' --- ' + (new Date().getTime() - (startTime + count * 1000))
  )
}, 1000)
```

- requestAnimationFrame()

> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行，理想状态下回调函数执行次数通常是每秒 60 次（也就是我们所说的[60fsp](https://www.zhihu.com/search?q=60fsp&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2363760138})），也就是每 16.7ms 执行一次，但是并不一定保证为 16.7 ms。

```js
const t = Date.now()
function mySetTimeout(cb, delay) {
  let startTime = Date.now()
  loop()
  function loop() {
    if (Date.now() - startTime >= delay) {
      cb()
      return
    }
    requestAnimationFrame(loop)
  }
}
mySetTimeout(() => console.log('mySetTimeout', Date.now() - t), 2000) //2005
setTimeout(() => console.log('SetTimeout', Date.now() - t), 2000) // 2002
```

### 33.原生js如何获取dom元素？如何监听dom元素全部加载出来？如何监听图片css也加载出来？



### 34.如何判断一个变量的类型？

type of、instance of、 constructor、 prototype(最好用)

#### type of

对一个值使用 typeof 操作符可能返回下列某个字符串，返回的类型都是字符串形式。

(1) undefined：如果这个值未定义

(2) boolean：如果这个值是布尔值

(3) string：如果这个值是字符串

(4) number：如果这个值是数值

(5) object：如果这个值是对象或null

(6) function：如果这个值是函数

> 需要注意：用typeof检测构造函数创建的Number，String，Boolean都返回object
> 基本数据类型中：null 。[引用数据类型](https://so.csdn.net/so/search?q=引用数据类型&spm=1001.2101.3001.7020)中的：Array，Object，Date，RegExp。不可以用typeof检测。都会返回小写的object

#### instance of

instanceof 运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的[原型链](https://so.csdn.net/so/search?q=原型链&spm=1001.2101.3001.7020)上。需要区分大小写。

用于判断一个变量是否某个对象的实例。

> 需要注意，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等。
>
> 判断它是否为字符串和数字时，只会返回false。
> null和undefined都返回了false，这是因为它们的类型就是自己本身，并不是Object创建出来它们，所以返回了false。

```js
function getTypeUsingInstanceof(variable) {
  if (variable instanceof Array) {
    return "array";
  } else if (variable instanceof Date) {
    return "date";
  } else if (variable instanceof RegExp) {
    return "regexp";
  } else if (variable instanceof Map) {
    return "map";
  } else if (variable instanceof Set) {
    return "set";
  } else {
    return typeof variable;
  }
}
```

#### constructor

constructor 属性返回对创建此对象的数组函数的引用。

在JavaScript中，每个具有原型的对象都会自动获得constructor属性。

```js
// String
var str = "字符串";
console.log(str.constructor); // function String() { [native code] }
console.log(str.constructor === String); // true
 
// Array
var arr = [1, 2, 3];
console.log(arr.constructor); // function Array() { [native code] }
console.log(arr.constructor === Array); // true
 
// Number
var num = 5;
console.log(num.constructor); // function Number() { [native code] }
console.log(num.constructor === Number); // true
```

#### prototype(最准确)

```js
function getTypeUsingObjectToString(variable) {
  return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
}

console.log(getTypeUsingObjectToString(42)); // "number"
console.log(getTypeUsingObjectToString("Hello")); // "string"
console.log(getTypeUsingObjectToString(true)); // "boolean"
console.log(getTypeUsingObjectToString([])); // "array"
console.log(getTypeUsingObjectToString({})); // "object"
console.log(getTypeUsingObjectToString(null)); // "null"
console.log(getTypeUsingObjectToString(undefined)); // "undefined"
console.log(getTypeUsingObjectToString(function() {})); // "function"
```

### 35.async和await

#### async/await

> 为了解决Promise的问题，async，await在ES7被提出来了

```js
const fs=require('fs')
async function(){
    try{
        var f1=await readFileWithPromise('/etc/passwd')
         var f2=await readFileWithPromise('/etc/profile')
        
    }
    catch(err){
        console.log(err)
    }
}
```

特点：

- 异步async函数的调用，跟普通函数使用方式一样
- async的用法，作为一个关键字放在函数前面，变成了异步函数；
- 异步async函数返回一个promise对象
- async函数配合await使用可以阻塞代码，异步方法；

优点：

- 多个参数传递：promise使用then函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，频繁的解析又重新组合比较麻烦；而利用async和await可以没有这个限制，可以当做普通变量的局部变量来处理，也没有冗余工作；
- 同步和异步一起编写：使用promise的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰；async和await整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个promise对象放在await关键字后面；

- 对promise的优化：async和await是基于promise的，是进一步的一种优化。



### 36.set和map

#### Set

Set是ES6新增的数据结构，类似于数组，但它的一大特性就是所有元素都是唯一的，没有重复的值，我们一般称为集合。

```js
//初始化一个Set ，需要一个Array数组，要么空Set
var set = new Set([1,2,3,5,6]) 
console.log(set)  // {1, 2, 3, 5, 6}

//添加元素 add()
//返回 Set 结构本身，当添加实例中已经存在的元素，set不会进行处理添加。也可以采用链式写法
set.add(7) //{1, 2, 3, 5, 6, 7}

//删除元素 delete()， 返回一个布尔值。
set.delete(3) // {1, 2, 5, 6, 7}

//检测是否含有此元素，有为true，没有则为false
set.has(2) //true

//清除所有元素，没有返回值。

```

用处：去重

```js
/最常用来数组去重，去重方法有很多但是都没有它运行的快
var arr = [2, 3, 5, 3, 5, 2];
var arrSet = new Set(arr);
console.log(arrSet);    // Set(6) {2, 3, 5}

//方法一：用ES6的...结构
let newArr1 = [...arrSet];
console.log(newArr1 );    // [2, 3, 5]
 
//方法二：用Array.from()将类数组转化为数组
let newArr2 = Array.from(arrSet);
console.log(newArr2 );    // [2, 3, 5]

/字符串去重
var str = "2234332244";
var newStr = [...new Set(str)].join("");
console.log(newStr);    //234

let a = new Set([1, 2, 3]),
b = new Set([2, 3, 4]);
 
/实现并集、交集、差集
//并集
var res1 = new Set([...a, ...b]);
console.log('并集：', res1);
 
//交集
var res2 = new Set([...a].filter(x => b.has(x)));
console.log('交集：', res2);
 
//差集（a 相对于 b）
var res3 = new Set([...a].filter(x => !b.has(x)));
console.log('差集：', res3);

//并集 Set(4) {1,2,3,4}
//交集 Set(2) {2,3}
//差集 Set(1) {1}

```

#### Map

JS的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。为了解决这个问题，最新的ES6规范引入了新的数据类型Map。

Map类似于对象，数据结构是一个键值对的结构，但是“键”的范围不限制于字符串，各种类型的值（包含对象）都可以当作键。
Map 也可以接受一个数组作为参数，数组的成员是一个个表示键值对的数组。注意Map里面也不可以放重复的项。

一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值覆盖掉；
初始化Map需要一个二维数组，或者直接初始化一个空Map

```js
//初始化`Map`需要一个二维数组(请看 Map 数据结构)，或者直接初始化一个空`Map` 
let map = new Map();

//添加key和value值
map.set('Amy','女')
map.set('liuQi','男')

//是否存在key，存在返回true,反之为false
map.has('Amy') //true
map.has('amy') //false

//根据key获取value
map.get('Amy') //女

//删除 key为Amy的value
map.delete('Amy')
map.get('Amy') //undefined  删除成功
```

#### 区别

map和set一样是关联式容器,它们的底层容器都是[红黑树](https://so.csdn.net/so/search?q=红黑树&spm=1001.2101.3001.7020)

- 两种方法具有极快的查找速度
- Map 和 Set 都不允许键重复
- 初始化需要值不一样，Map需要的是一个二维数组，而Set 需要的是一维 Array 数组
- Map 是键值对的存在，键和值是分开的；Set 没有 value 只有 key，value 就是 key；

### 37.ES6新特性及主要数组方法以及区别

- Array.from()

> 可以将可迭代的对象转换为新的数组
>
> - 函数可接受3个参数（后两个参数可以没有）：
>   - 第一个表示将被转换的可迭代对象(如果只有一个参数就是把形参转变成数组)
>   - 第二个是回调函数，将对每个数组元素应用该回调函数，然后返回新的值到新数组，
>   - 第三个是回调函数内this的指向。

```js
let arr=[1,2,3]
let obj={
    double(n){
        return n*2
    }
}

Array.from(arr,function(n){
    return this.double(n)
},obj)
```

- includes()

> 查看数组中是否有这个元素，存在就返回true，不存在返回false

```js
let arr=[1,33,44,22,6,9]
let arr=arr.includes(22)  //true

```

- map(),filter()

> map利用原数组经过运算或者从对象数组中取某属性
>
> filter将符合挑选得筛选出来成为新的数组；

```js
let arr=[1,2,3,4,5]

let newArr=arr.map((v)=>v*2)
let newArr1=arr.filter((v)=>v>10)
```

- forEach()

> forEach()循环遍历数组得每一项，没有返回值
>
> find()查找数组中符合条件得第一个元素返回

```js
let arr=[1,2,3,4]
let res=[]

arr.forEach((v,i)=>{
    if(v>10){
        res.push(arr[i])
    }
})

let a2=arr.find((v)=>v>10)
```

- some(),every()

> some()数组中某一个符合就返回true；
>
> every()每一个都符合才返回true；

### 38.this关键字

#### 方法中的this

通常，对象方法需要访问对象中存储的信息才能完成其工作。

```js
let user = {
  name: "John",
  age: 30,
  sayHi() {
    // "this" 指的是“当前的对象”
    alert(this.name);
  }
};

user.sayHi(); // John
```

#### this不受限制

在 JavaScript 中，`this` 关键字与其他大多数编程语言中的不同。JavaScript 中的 `this` 可以用于任何函数，即使它不是对象的方法。

`this` 的值是在代码运行时计算出来的，它取决于代码上下文。

**在没有对象的情况下调用：**`this == undefined`

```js
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```

#### 解除this绑定的后果

如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 `this`”的概念，即在对象中定义的方法总是有指向该对象的 `this`。

在 JavaScript 中，`this` 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。

在运行时对 `this` 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。

这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。



#### 箭头函数没有自己的this



### 39.普通函数和箭头函数的区别？

#### 箭头函数没有this

箭头函数没有 `this`。如果访问 `this`，则会从外部获取。

```js
let people = {
    name: "Martin",
    age: 20,
    subjects: ["Math", "English"],

    showInfo () {
        this.subjects.forEach(element => {
            console.log(element)
        })
    }
}

people.showInfo()
```

如果我们使用正常的函数，则会出现错误

报错是因为 `forEach` 运行它里面的这个函数，但是这个函数的 `this` 为默认值 `this=undefined`，因此就出现了尝试访问 `undefined.title` 的情况。

> **不能对箭头函数进行 `new` 操作**
>
> 不具有 `this` 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）。不能用 `new` 调用它们。

#### 箭头函数和bind的区别

- `.bind(this)` 创建了一个该函数的“绑定版本”。
- 箭头函数 `=>` 没有创建任何绑定。箭头函数只是没有 `this`。`this` 的查找与常规变量的搜索方式完全相同：在外部词法环境中查找。

#### 箭头函数没有arguments

当我们需要使用当前的 `this` 和 `arguments` 转发一个调用时，这对装饰器（decorators）来说非常有用。

```js
function defer (f, ms) {
    return function () {
        setTimeout(() => f.apply(this, arguments),ms)
    }
}

function sayHi (name) {
    console.log(`Hi, ${name}`)
}

let sayHiFriend = defer(sayHi, 5000)
sayHiFriend('Tom')
```

不用箭头函数的话，可以这么写：

```js
function defer(f, ms) {
  return function(...args) {
    let ctx = this;
    setTimeout(function() {
      return f.apply(ctx, args);
    }, ms);
  };
}
```

#### 箭头函数没有super





### 40.事件捕获事件冒泡？代码层面上怎么去实现？项目里如何去使用？

#### 冒泡

> 当一个事件发生在一个元素上时，他会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序

```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

p>div>form>document

> Note:几乎所有的事件都会冒泡
>
> 例如，focus 事件不会冒泡。同样，我们以后还会遇到其他例子。但这仍然是例外，而不是规则，大多数事件的确都是冒泡的。

#### Event.target

> 引发事件的那个嵌套层级最深的元素被称为目标元素，可以通过event.target访问。

注意与 `this`（=`event.currentTarget`）之间的区别：

- `event.target` —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。
- `this` —— 是“当前”元素，其中有一个当前正在运行的处理程序。

#### 停止冒泡

> 冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 `<html>`，然后再到 `document` 对象，有些事件甚至会到达 `window`，它们会调用路径上所有的处理程序。
>
> 但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。
>
> 用`event.stopPropagation`停止冒泡

##### **event.stopImmediatePropagation()**

如果一个元素在一个事件上有多个处理程序，技师其中一个停止冒泡，其他处理程序任会执行；

有一个 `event.stopImmediatePropagation()` 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行。

#### 捕获

DOM事件标准描述了事件传播的3个阶段：

1. 捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。
2. 目标阶段（Target phase）—— 事件到达目标元素。
3. 冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。

使用 `on<event>` 属性或使用 HTML 特性（attribute）或使用两个参数的 `addEventListener(event, handler)` 添加的处理程序，对捕获一无所知，它们仅在第二阶段和第三阶段运行。

为了在捕获阶段捕获事件，我们需要将处理程序的 `capture` 选项设置为 `true`：

```js
elem.addEventListener(..., {capture: true})
// 或者，用 {capture: true} 的别名 "true"
elem.addEventListener(..., true)
```

`capture` 选项有两个可能的值：

- 如果为 `false`（默认值），则在冒泡阶段设置处理程序。
- 如果为 `true`，则在捕获阶段设置处理程序。

#### Event.eventPhase

告诉我们捕获事件的阶段数。

> **要移除处理程序，`removeEventListener` 需要同一阶段**
>
> 如果我们 `addEventListener(..., true)`，那么我们应该在 `removeEventListener(..., true)` 中提到同一阶段，以正确删除处理程序。



### 41.原生js如何获取dom元素？有哪些方法？

##### **获取DOM元素的方法（8种）**

- 通过ID获取（getElementById）

> - 上下文必须是document。
> - 必须传参数，参数是string类型，是获取元素的id。
> - 返回值只获取到一个元素，没有找到返回null。
> - 坑~~坑坑~坑坑~坑坑~：  
> - 1.如果有多个id存在只获取第一个，也就是最先出现的哪一个。一般情况也不会出现同一个ID在页面上出现两次。
> - 2.在IE6、7中会把表单元素的name当做ID值获取到。所以大家在定义这些的时候一定要注意。  
> - 3.在IE6、7中不区分大小写。  
> - 4.可以直接用元素的ID代表这个元素。（项目中不推荐）  
> - 5.通过ID获取元素的上下文只能是document。为什么上下文必须是document呢，因为getElementById这个方法在Document类的原型上.

- 通过name属性（getElementsByName）

> - 上下文必须是document。内容
> - 必须传参数，参数是是获取元素的name属性。
> - 返回值是一个类数组，没有找到返回空数组。
> - 坑~~坑坑~坑坑~坑坑~：  
> - 1.获取的结果是一个类数组，不是数组。  
> - 2.在IE浏览器中只能获取到表单元素，当然我们一般也只用它获取表单元素，从ie10开始可以不只是表单元素。  
> - 3.上下文只能是document，原因同getElementById。

- 通过标签名（getElementsByTagName）

> - 上下文可以是document，也可以是一个元素，注意这个元素一定要存在。
> - 参数是是获取元素的标签名属性，不区分大小写。
> - 返回值是一个类数组，没有找到返回空数组
> - 坑~~坑坑~坑坑~坑坑~：  
> - 1.获取的结果是一个类数组。  
> - 2.上下文不必须是document了，因为getElementsByTagName方法在不仅在Document类的原型上也在Element类的原型上，所以document和元素都可以使用这个方法

- 通过类名（getElementsByClassName）

> - 上下文可以是document，也可以是一个元素。
> - 参数是元素的类名。
> - 返回值是一个类数组，没有找到返回空数组。
> - 坑~~坑坑~坑坑~坑坑~：  
> - 1.获取的结果是一个类数组。  
> - 2.IE8以及以前版本不兼容。真可惜这么好用的方法不兼容。

- 通过选择器获取一个元素（querySelector）

> - 上下文可以是document，也可以是一个元素。
> - 参数是选择器，如：”div .className”。
> - 返回值只获取到第一个元素。
> - 坑~~坑坑~坑坑~坑坑~：  
> - 这个方法不兼容IE7以及以前版本，现在似乎也没有考虑IE7兼容的公司了。

- 通过选择器获取一组元素（querySelectorAll）
- 获取html的方法（document.documentElement）
- document.documentElement是专门获取html这个标签的
- 获取body的方法（document.body）
- document.body是专门获取body这个标签的。

### 42.深浅拷贝

> 浅拷贝时单层拷贝
>
> 会在栈中开辟另一块空间，并将被拷贝对象的栈内存数据完全拷贝到该块空间中，即基本数据类型的值会被完全拷贝，而引用类型的值则是拷贝了“指向堆内存的地址”。

浅拷贝方法：

- Object.assign()
- 扩展运算符(…)
- Array.concat()
- Array.slice()

> 深拷贝是拷贝多层，每一级别的数据都会拷贝出来

深拷贝方法：

- JSON.parse(JSON.stringify(obj))
- 递归方法
- 函数库 lodash

1. 浅拷贝主要用于你需要拷贝的对象的数据结构只有基础数据类型，并且你不想改变原数据类型或者需要对比操作前后的数据。
2. 深拷贝主要用于你想操作该数据，但是又不想影响到原数据的时候，就可以进行深拷贝。

# Git相关

https://worktile.com/kb/ask/20275.html

### 1.常见命令流程

```shell
#初始化仓库
git init  

#切换到主分支
git checkout master

#获取最新变更
git fetch origin

#基于主分支创建dev分支
git checkout -b dev origin/master

#添加到缓存
git add

#提交到本地仓库
git commit -m "备注"

#获取最新更新
git fetch origin


```

### 2.其他指令

```shell
#查看仓库状态
git status

#将某个工作区的文件添加暂存区
git add filename   或 git add . 全部

#查看工作区和暂存区差异
git diff 分支/id/

#查看历史记录
git log

#代码回滚
git reset HEAD^  

#删除版本库文件
git rm filename

#同步远程仓库
git push -u origin master

#本地仓库推送到远程仓库
git remote add origin git@github.com:username/仓库名.git

#克隆
git clone url

#合并分支
git merge dev

#删除分支
git branch -d dev

#通过二分搜索算法来查找提交历史中的那一次提交引入错误
git bisect
git bisect start 5d14c34b d577ce4

#dev分支开发到一半，但是生产环境有bug，可以使用其暂存切换后再次恢复
git stash
```

### 3.git rebase

![在这里插入图片描述](https://img-blog.csdnimg.cn/36efc2704d174acab598c4b9addd3694.png?)

```shell
#在feature开发一段时间后准备从主干master拉一下最新改动
git checkout feature
git rebase master
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/12b959efcc454da5a15b9fdec493d61b.png?)

当在feature分支上执行git rebase master时，git会从master和featuer的共同祖先B开始提取feature分支上的修改，也就是C和D两个提交，先提取到。然后将feature分支指向master分支的最新提交上，也就是M。最后把提取的C和D接到M后面，注意这里的接法，官方没说清楚，实际是会依次拿M和C、D内容分别比较，处理冲突后生成新的C’和D’。定注意，这里新C’、D’和之前的C、D已经不一样了，是我们处理冲突后的新内容，feature指针自然最后也是指向D’

**如果你的分支不只有你在进行开发，那么`git-rebase`可能会导致提交记录的丢失，但是如果你是在自己的分支上进行开发，那么这无疑是一个很棒的选择。**

### 4.前端工程化：如何保证小组代码风格相同？

- Eslint

> 检查代码质量，如是否有已定义但未使用的变量。
> 检查代码风格，换行，引号，缩进等相关的规范。

问：ESLint 检查与 TypeScript 检查有啥区别？

TypeScript 只会检查类型错误，而 ESLint 会检查风格错误。

```shell
eslint --init
```

```json
{
  "env": {
    "browser": true,
    "es2021": true,
  },
  "extends": [
    "eslint:recommended"
  ],
  "parserOptions": {
    "ecmaVersion": 12,
    "sourceType": "module",
  },
  "rules": {},
};

```

```shell
npx eslint index,js
```

```json
"off" or 0 - 关闭规范
"warn" or 1 - 警告级别规范
"error" or 2 - 错误级别规范

```

- Prettier

```shell
 npm install prettier --save-dev
```

```json
{
  "singleQuote": true, // 是否单引号
  "semi": false, // 声明结尾使用分号(默认true)
  "printWidth": 100, // 一行的字符数，超过会换行（默认80）
  "tabWidth": 2, // 每个tab相当于多少个空格（默认2）
  "useTabs": true, // 是否使用tab进行缩进（默认false）
  "trailingComma": "all", // 多行使用拖尾逗号（默认none）
  "bracketSpacing": true, // 对象字面量的大括号间使用空格（默认true）
  "jsxBracketSameLine": false, // 多行JSX中的>放置在最后一行的结尾，而不是另起一行（默认false）
  "arrowParens": "avoid" // 只有一个参数的箭头函数的参数是否带圆括号（默认avoid）
}

```

```shell
 npx prettier --write index.js
```

- vscode

> 插件：
>
> Eslint
>
> Prettier-Code Formatter

- 命名规范

> 变量命名：下划线user_id
>
> CSS-Class：中划线 user-container
>
> 方法名：小驼峰 userId
>
> JS-Class：大驼峰 UserId
>
> 文件夹：中划线
>
> 文件夹下组件

- 项目结构规范

```js
|-- src
    |-- index.tsx # 入口文件
    |-- assets # 静态资源目录
    |-- components # 公共组件目录
    |   |-- header
    |   |   |-- index.tsx
    |   |   |-- index.less
    |-- stores # 状态管理目录，与 pages 结构对应
    |   |-- admins
    |   |   |-- index.tsx # 状态文件
    |   |   |-- types.ts  # 定义状态类型
    |   |-- index.tsx
    |-- pages # 页面目录，与 stores 结构对应
    |   |-- admins
    |   |   |-- index.tsx
    |   |   |-- index.less
    |-- request
    |   |-- index.ts # axios 实例，全局请求处理
    |-- router
    |   |-- home.tsx
    |   |-- index.tsx
    |   |-- root.tsx
    |-- styles # 全局样式
    |   |-- common.less
    |   |-- index.less
    |-- utils # 工具目录
        |-- index.ts

```



# NodeJS相关

### 1.node流



### 2.node如何写接口？



### 3.express



### 4.node常用模块





# VUE相关

### 1.Vue生命周期

![组件生命周期图示](https://cn.vuejs.org/assets/lifecycle.16e4c08e.png)

- beforeCreate:实例初始化完成，props解析之后，data()和computed等选项处理之前立即调用；此时不能获得DOM结点；
- created：Vue实例已经创建，响应式数据、计算属性、方法和侦听器已经设置完成；但是由于没有挂载，依旧不能获得DOM结点；
- beforeMount：组件内容被渲染拿到页面之前执行的函数，组件已经完成了其响应式状态的设置，但是还没有创建DOM结点；
- mounted：组件渲染之后自动执行，一般异步请求写这里；这个阶段数据和DOM都已经完成渲染；
- beforeUpdate：数据变化的时候执行的函数，此时变化后的数据还未渲染到页面上；
- updated：数据变化以后执行，变化的数据已经渲染到页面上；
- beforeDestroyed：当Vue应用被销毁时，自动执行的函数；
- Destroyed：当vue应用销毁后，且DOM完全销毁之后自动执行；

![img](https://upload-images.jianshu.io/upload_images/24919918-2b75253c04f7b643.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

### 2.路由守卫

- 基础概念
  vue-router提供的导航守卫主要用来跳转或取消守卫导航：全局的、单个路由独享、组件级
- 全局前置守卫

```js
const router=createRouter({
    
})

router.beforeEach((to,from)=>{
    return false
})
```

当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是一步解析执行的，此时导航在所有守卫resolve完之前一直处于等待中。

参数：

```
to:即将进入的目标
from:当前正要离开的路由
```

返回值：

```
false：取消当前导航，如果url改变了会重置到from
/path:如同调用router.push()一样当前导航被中断，进入新导航
```

```js
const router=createRouter({
    
})

router.beforeEach((to,from)=>{
    if(!isAuthenticated && to.name!=='Login'){
        return {name:"Login"}
    }
})
```

可选参数next:

可以向任何导航守卫传递第三个参数，这种情况下，确保next在任何给定的导航守卫中严格调用一次。

```js
router.beforeEach((to,from,next)=>{
    if(to.name!=='Login' && !isAuthenticated){
        next({
            name:"Login"
        })
    }
   else{
        next()
   }
})
```

- 全局解析守卫

每次导航时触发，但是解析守卫刚好会在导航被确认之前，所有组件内守卫和一部路由组件解析之后调用。

```js
router.beforeResolve(async to=>{
	if(to.meta.requiresCamera){
		try{
			awaitt askForCameraPermission()
		}catch(error){
			if(error instanceof NotAllowedError){
				return false
			}else{
				throw error
			}
		}
	}
})
```

- 全局后置钩子

注册全局后置钩子：不会接受next函数也不会改变导航本身

```js
router.afterEach((to,from)=>{
    sendToAnalytics(to,fullpath)
})
```

- 路由独享守卫

直接在路由配置上定义beforeEnter守卫，进入路由时出发==触发

```js
const routes=[
    {
        path:'/users/:id',
        component:UserDetails,
        beforeEnter:(to,from)=>{
            return false
        }
    }
]
```

传递函数数组给breforeEach

```js
function removeQueryParams(to) {
  if (Object.keys(to.query).length)
    return { path: to.path, query: {}, hash: to.hash }
}

function removeHash(to) {
  if (to.hash) return { path: to.path, query: to.query, hash: '' }
}

const routes = [
  {
    path: '/users/:id',
    component: UserDetails,
    beforeEnter: [removeQueryParams, removeHash],
  },
  {
    path: '/about',
    component: UserDetails,
    beforeEnter: [removeQueryParams],
  },
]
```

- 组件内的守卫

```js
const UserDetails={
    template:`...`,
    beforeRouteEnter(to,from){
        
    },
    beforeRouteUpdate(to,from){
        
    },
    beforeRouteLeave(to,from){
        
    },
}
```

- #### 完整的导航解析流程

```
1. 导航被触发。
2. 在失活的组件里调用 `beforeRouteLeave` 守卫。
3. 调用全局的 `beforeEach` 守卫。
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫(2.2+)。
5. 在路由配置里调用 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用 `beforeRouteEnter`。
8. 调用全局的 `beforeResolve` 守卫(2.5+)。
9. 导航被确认。
10. 调用全局的 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。
```

> 项目开发中，每一次页面的跳转或者刷新，都需要判断用户是否登录，后端会进行判断，前端最好也有判断。
>
> vue-router 提供了导航钩子，全局前置导航钩子 beforeEach 和全局后置导航钩子 afterEach，他们会判断路由即将改变前后及进行触发。判断用户登录与否要在 beforeEach 导航钩子判断

#### 参数

- to:即将进入的目标路由对象
- from：当前导航即将离开的路由对象
- next：调用该方法才能进入下一个钩子函数（afterEach）
  - next() //直接进入 to 路由
  - next（false) //中断当前路由
  - next('route') //跳转指定路由
  - next（‘error’） //跳转错误路由

#### 路由配置文件

```js
import Vue from 'vue'
import Router from 'vue-router'
import HelloWorld from '@/components/HelloWorld'
import HomePage from '@/pages/home.vue'
Vue.use(Router)
const router = new Router({
  routes: [
    {
      path: '/',
      name: 'HelloWorld',
      component: HelloWorld,
    },
    {
      path: '/home',
      name: 'home',
      component: HomePage,
    },
    {
      path: '*',
      redirect: '/home',
    },
  ],
})
router.beforeEach((to, from, next) => {
  console.log(to)
  console.log(from)
  next()
})
export default router
```

#### 开发实际应用

- 清除当前组件定时器

> 当一个组件中有一个定时器时, 在路由进行切换的时候, 可使用 beforeRouteLeave 将定时器进行清楚, 以免占用内存

```js
beforeRouteLeave (to, from, next) {
  window.clearInterval(this.timer) //清楚定时器
  next()
}

```

- **当页面中有未关闭的窗口, 或未保存的内容时, 阻止页面跳转**

```js
beforeRouteLeave (to, from, next) {
 //判断是否弹出框的状态和保存信息与否
 if (this.dialogVisibility === true) {
    this.dialogVisibility = false //关闭弹出框
    next(false) //回到当前页面, 阻止页面跳转
  }else if(this.saveMessage === false) {
    alert('请保存信息后退出!') //弹出警告
    next(false) //回到当前页面, 阻止页面跳转
  }else {
    next() //否则允许跳转
  }
}

```

- 保存相关内容到 Vuex 或 Session 中

```js
beforeRouteLeave (to, from, next) {
    localStorage.setItem(name, content); //保存到localStorage中
    next()
}

```



### 3.组件通信有哪些？

https://blog.csdn.net/longfan_/article/details/125324201

> 一般分为如下关系：
>
> 父子间通信；
>
> 非父子间通信（兄弟，隔代）；

- props / $emit

> 父组件通过props的方式向子组件传递数据，而通过$emit子组件可以像父组件通信；
>
> props只可以从上一级组件传递到下一级组件，即所谓的单向数据流，而且props只读，不可被修改，所有修改都会失效并警告；
>

1. 不应该在一个子组件内部改变prop，会破坏单向数据绑定；如果有需要，使用data属性接受或者使用computed进行转换；
2. 如果Prop的是引用类型的数据，在子组件改变这个对象或数组，父组件的状态也会做相应的更新，利用这一点实现父子组件的双向绑定。虽然这样能够节省代码，但是会牺牲诞下给你数据流，令人难以理解，最好不要这样。
3. 实现父子组件的数据双向绑定，可以使用v-model或者sync

使用$emit向父组件传数据，父组件在紫钻及能通过v-on监听函数并接受参数，vue框架在子组件监听了v-on="fn"的事件函数，子组件使用emit触发；

```vue
<!-- 父组件 -->
<template>
  <div class="section">
    <child :msg="articleList" @changMsg="changMsg"></child>
  </div>
</template>
 
<script>
import child from './child.vue'
export default {
  name: 'HelloWorld',
  components: { comArticle },
  data() {
    return {
      msg: '阿离王'
    }
  },
  methods:{
      changMsg(msg) {
          this.msg = msg
      }
  }
}
</script>
```

```vue
<!-- 子组件 child.vue -->
<template>
  <div>
    {{ msg }}
    <button @click="change">改变字符串</button>
  </div>
</template>
 
<script>
export default {
  props: {
      msg: String
  },
  methods: {
      change(){
          this.$emit('changMsg', '阿离王带你学习前端')
      }
  }
}
</script>
```

#### v-model

用来在表单空间或者组件上创建双向绑定，本质是v-bind和v-on的语法糖在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件。

```vue
<!--父组件-->
<template>
    <base-input v-model="inputValue"></base-input>
</template>
<script>
    export default {
        data() {
            return {
                input: ''
            }
        },
    }
</script>
```

```vue
<!--子组件-->
<template>
    <input type="text" :value="currentValue"  @input="handleInput">
</template>
<script>
    export default {
        data() {
            return {
                currentValue: this.value === undefined || this.value === null ? ''
            }
        },
        props: {
            value: [String, Number], // 关键1
        },
        methods: {
            handleInput(event) {
                const value = event.target.value;
                this.$emit('input', value); // 关键2
            },
        },
}
</script>
```

#### sync修饰符

```vue
<text-document v-bind:title.sync="doc.title" />

```

```js
this.$emit('update:title', newTitle)
```

#### provide/inject

> 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效

`provide` 选项应该是

- 一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。

`inject` 选项应该是：

- 一个字符串数组
- 一个对象(详情点击[这里](https://link.juejin.cn/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%3F%23provide-inject))

```js
// 祖先组件 提供foo
//第一种
export default {
  name: "father",
  provide() {
    return {
      foo: 'hello'
    }
  },
}
//第二种
export default {
  name: "father",
  provide: {
    foo:'hello~~~~'
  },
}
```

```js
//后代组件 注入foo, 直接当做this.foo来用
export default {
  inject:['foo'],
}
```

- 如果你只是传一个字符串，像上面的`hello`，那么是没有区别的，后代都能读到。
- 如果你需要`this`对象属性的值（如下所示代码），那么第二种是传不了的，后代组件拿不到数据。所以建议只写第一种

#### provide/inject 实现页面刷新，不闪烁

1. 用`vue-router`重新路由到当前页面，页面是不进行刷新的
2. 采用`window.reload()`，或者`router.go(0)`刷新时，整个浏览器进行了重新加载，闪烁，体验不好

#### ref/refs

> ref:如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果在子组件上，就是指向组件实例；可以通过实例直接调用组件方法或访问数据；

```js
// 子组件 A.vue
 
export default {
  data () {
    return {
      name: 'Vue.js'
    }
  },
  methods: {
    sayHello () {
      console.log('hello')
    }
  }
}
 
```

```vue
// 父组件 app.vue
 
<template>
  <component-a ref="comA"></component-a>
</template>
<script>
  export default {
    mounted () {
      const comA = this.$refs.comA;
      console.log(comA.name);  // Vue.js
      comA.sayHello();  // hello
    }
  }
</script>
 
```

#### eventBus

> 其实就是事件订阅发布，又称事件总线

创建一个event-bus.js

```js
 <button @click="additionHandle">+加法器</button>    
  methods: {
    additionHandle() {
      EventBus.$emit('addition', {
        num: this.num++
      })
    }
  }

```

```js
//接受
import { EventBus } from './event-bus.js'
 mounted() {
    EventBus.$on('addition', param => {
      this.count = this.count + param.num;
    })
  }
```

#### vuex



#### localStorage/sessionStorage

- 通过`window.localStorage.getItem(key)`获取数据
- 通过`window.localStorage.setItem(key,value)`存储数据



#### Slot

> 就是把子组件的数据通过插槽的方式传给父组件使用，然后再插回来

```vue
// Child.vue
<template>
    <div>
        <slot :user="user"></slot>
    </div>
</template>
export default{
    data(){
        return {
            user:{ name:"xxx" }
        }
    }
}
 
// Parent.vue
<template>
    <div>
        <child v-slot="slotProps">
            {{ slotProps.user.name }}
        </child>
    </div>
</template>
```

常见使用场景可以分为三类:

- 父子组件通信: props/$emit、$parent/$children、 provide/inject 、 ref/$refs 、$attrs/$listeners、slot

- 兄弟组件通信: eventBus 、 vuex、 自己实现简单的 Store 模式
- 跨级通信: eventBus、 Vuex、 自己实现简单的 Store 模式、 provide / inject 、 $attrs / $listeners





### 4.v-if与show区别

> 1、渲染方式，v-if是惰性渲染，v-show则是控制元素的显示和隐藏；
>
> 2、初始渲染开销，v-if在初始渲染时，如果条件为假，就不会渲染，可以减少开销，v-show会在初始渲染时就全部渲染；v-show则会在初始渲染时将所有元素都渲染到DOM中，只是通过CSS来控制其显示和隐藏。
>
> 3、切换开销，v-if在条件切换时会有开销，v-show只需要控制元素的显示和隐藏。

#### 使用场景

> 如果需要在条件切换频繁的情况下，可以使用v-show来避免频繁的创建和销毁组件或元素，提高性能。
>
> 如果需要在条件切换较少的情况下，可以使用v-if来在条件为假时减少不必要的渲染，节省内存。



### 5.VUE与React区别

https://blog.csdn.net/yjnain3066/article/details/126751344

#### 相同点

1. 数据驱动视图
2. 组件化
3. 都使用了 Virtual DOM + Diff算法 

#### 不同点

- 核心思想不同：Vue早期开发就尤雨溪大佬，所以定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。这就有了vue的主要特点：灵活易用的渐进式框架，进行数据拦截/代理，它对侦测数据的变化更敏感、更精确。

- React 从一开始的定位就是提出 UI 开发的新思路。背靠大公司Facebook 的React，从开始起就不缺关注和用户，而且React想要做的是用更好的方式去颠覆前端开发方式。所以React推崇函数式编程（纯组件），数据不可变以及单向数据流,当然需要双向的地方也可以手动实现， 比如借助onChange和setState来实现。

- 响应式原理不同：Vue依赖收集，自动优化，数据可变。Vue递归监听data的所有属性,直接修改。当数据改变时，自动找到引用组件重新渲染。                                                react  React基于状态机，手动优化，数据不可变，需要setState驱动新的state替换老的state。当数据改变时，以组件为根目录，默认全部重新渲染, 所以 React 中会需要 shouldComponentUpdate 这个生命周期函数方法来进行控制

- 组件写法差异：React推荐的做法是JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中,即 all in js; Vue 推荐的做法是 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解),即 html,css,JS 写在同一个文件(vue也支持JSX写法)

  这个差异一定程度上也是由于二者核心思想不同而导致的。

- diff算法：vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。

- vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。

- 渲染过程：Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。

  React在应用的状态被改变时，全部子组件都会重新渲染。通过shouldComponentUpdate这个生命周期方法可以进行控制，但Vue将此视为默认的优化。

  如果应用中交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。

- vuex和redux：

  从表面上来说，store注入和使用方式有一些区别。在Vuex中，$store被直接注入到了组件实例中，因此可以比较灵活的使用：使用dispatch、commit提交更新，通过mapState或者直接通过this.$store来读取数据。在Redux中，我们每一个组件都需要显示的用connect把需要的props和dispatch连接起来。另外，Vuex更加灵活一些，组件中既可以dispatch action，也可以commit updates，而Redux中只能进行dispatch，不能直接调用reducer进行修改。

  从实现原理上来说，最大的区别是两点：Redux使用的是不可变数据，而Vuex的数据是可变的，因此，Redux每次都是用新state替换旧state，而Vuex是直接修改。Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter/setter来比较的，这两点的区别，也是因为React和Vue的设计理念不同。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用Vue的感觉。

- 框架：Vue本质是MVVM框架，由MVC发展而来；

  React是前端组件化框架，由后端组件化发展而来。
  


### 6.Vue DIff算法



### 7.Vue如何实现监听？



### 8.VUE权限管理

https://blog.csdn.net/weixin_43995143/article/details/136224400

#### 接口权限

> 接口权限目前一般采用jwt的形式验证，米有的话一般返回401，跳转到登录页面重新进行登录。登陆拿到token将token存起来，通过axios请求拦截器进行拦截，每次请求时头部携带token

#### 路由权限

- 初始化时挂在全部路由，在路由上标记相应的权限信息，每次路由跳转前做校验。

> 缺点：
>
> - 加载所有路由，如果路由过多，存在性能问题；
> - 全局路由守卫里，每次路由跳转都要做权限判断。
> - 菜单信息写死在前端，修改路由信息或权限信息需要重新编译。
> - 需要添加额外信息区分路由和菜单。

- 初始化时先挂在不需要权限的路由，如404/登录页等。如果通过URL强行访问，则会直接进入404；登陆后获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRouts添加路由。

> 缺点：
>
> - 全局路由守卫里，每次跳转都需要判断
> - 菜单信息写死在前端，修改需要重新编译
> - 菜单和路由耦合在一起；

#### 菜单权限

- 菜单与路由分离，菜单由后端返回

#### 按钮权限

- 使用v-if判断，适用于页面不多的情况；
- 自定义指令

```js
{
    path: '/permission',
    component: Layout,
    name: '权限测试',
    meta: {
        btnPermissions: ['admin', 'supper', 'normal']
    },
    //页面需要的权限
    children: [{
        path: 'supper',
        component: _import('system/supper'),
        name: '权限测试页',
        meta: {
            btnPermissions: ['admin', 'supper']
        } //页面需要的权限
    },
    {
        path: 'normal',
        component: _import('system/normal'),
        name: '权限测试页',
        meta: {
            btnPermissions: ['admin']
        } //页面需要的权限
    }]
}
```

```js
import Vue from 'vue'
/**权限指令**/
const has = Vue.directive('has', {
    bind: function (el, binding, vnode) {
        // 获取页面按钮权限
        let btnPermissionsArr = [];
        if(binding.value){
            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。
            btnPermissionsArr = Array.of(binding.value);
        }else{
            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。
            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;
        }
        if (!Vue.prototype.$_has(btnPermissionsArr)) {
            el.parentNode.removeChild(el);
        }
    }
});
// 权限检查方法
Vue.prototype.$_has = function (value) {
    let isExist = false;
    // 获取用户按钮权限
    let btnPermissionsStr = sessionStorage.getItem("btnPermissions");
    if (btnPermissionsStr == undefined || btnPermissionsStr == null) {
        return false;
    }
    if (value.indexOf(btnPermissionsStr) > -1) {
        isExist = true;
    }
    return isExist;
};
export {has}
```

```vue
<el-button @click='editClick' type="primary" v-has>编辑</el-button>

```



### 9.vue为啥返回data(){  return {} }?

- 数据隔离：每一个vue组件都有自己独立的状态和数据，如果data直接是一个对象，那么该对象将成为所有实例共享的引用。这样，当多个组件实例共享同一个数据对象时，一个组件的修改可能会影响其他组件，导致不可预料的错误；将data选项设置为一个函数并在函数中返回一个对象，确保了每个组件实例都有一个独立的数组。
- 响应式原理：vue的响应式原理通过vue在组件实例化时对data进行劫持和代理实现，如果将data设置为一个普通对象，vue无法在实例化时捕获到数据的变化。而通过返回一个函数，vue可以在组件实例化时动态执行该函数，并对其返回的对象劫持，使其成为响应式的。



### 10.vue v-model双向绑定的原理？

> v-model其实是v-bind绑定value和v-on监听input事件的结合，是个语法糖；
>
> 在单向数据绑定的基础上给对应表单元素添加了事件来动态修改model和view；

#### 实现方法

- text/textarea:使用value属性和input事件来实现双向绑定；
- radio/checkbox：使用checked属性和change事件来实现双向绑定；
- select：使用value属性和chang事件来实现双向绑定；

### 11.vue响应式原理？

  	响应式基本原理是基于Object.defineProperty(obj, prop, descriptor), descriptor里面可以定义get和set方法，可以在获取属性值事触发get方法（可以收集依赖），设置属性值时触发set方法（更新依赖）。

​        扩展：上面是vue2.0的响应式基本原理，vue3.0的基本原理是Proxy，可以监听属性的get和set方法，监听属性的添加和删除等等，比Object.defineProperty能力更强，但是不兼容IE11。



### 12.vue组件通信的方式 √

- 父传子：props
- 子传父：this.$emit
- 祖先provide传递，子孙组件inject接收
- 父组件通过`this.$refs`获取子组件数据
- 子组件通过`this.$parent`获取父组件数据
- `$attrs`
- `$listeners`
- 事件总线`event-bus`
- slot作用域传值

```vue
<template>
  <div>
    <aaaChildren>
      <template #default="scope">
        <h1>{{ scope.info.age }}</h1>
      </template>
      <template #text="scope">
        <h2>{{ scope.data }}</h2>
      </template>
    </aaaChildren>
  </div>
</template>

<script>
import aaaChildren from './children/index.vue'

export default {
  name:'aaa',
  components:{
    aaaChildren
  }
}
</script>

```

```vue
<template>
  <div class="aaa_children">
    <slot :info="user"></slot>
    <slot name="text" :data="name"></slot>
  </div>
</template>

<script>
  export default {
    name:'aaaChildren',
    props:[],
    components:{},
    data(){
      return {
        user: {
          age: 18,
          name: '小明'
        },
        name: '卡卡罗特'
      }
    }
  }
</script>

```





# VUE3

https://zhuanlan.zhihu.com/p/646147326

### 1.vue3的computed

computed属性是Vue3中的一个响应式计算属性，它可以根据其他响应式数据的变化而自动更新其自身的值。computed属性可以接收一个计算函数，并在计算函数中使用其他响应式数据的值进行计算。当任何一个参与计算的响应式数据发生变化时，computed属性会自动重新计算其值，并触发相应的依赖更新。

```vue
<template>
  <div>潜在客户：{{ doubleCount }}</div>
  <el-button @click="state.count++">+1</el-button>
</template>

<script setup lang="ts">
import { ref, reactive, computed } from 'vue'

const state = reactive({
  count: 1,
})

const doubleCount = computed(() => state.count * 2)
</script>

<style scoped></style>

```

#### 用处

`computed`属性通常用于处理需要根据其他响应式数据计算得出的值的情况。

- 过滤排序
- 数组计算

#### 原理

在Vue3中，computed属性的原理是使用了一个getter函数和一个setter函数来实现。当我们访问计算属性的值时，会调用getter函数进行计算，并将计算结果缓存起来。当参与计算的响应式数据发生变化时，会触发依赖更新，并自动调用getter函数重新计算计算属性的值。当我们修改计算属性的值时，会调用setter函数进行更新。



### 2.vue3钩子及其用法

- setup() : 开始创建组件之前，在 beforeCreate 和 created 之前执行，创建的是 data 和 method

- onBeforeMount() : 组件挂载到节点上之前执行的函数；当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程。
- onMounted() : 组件挂载完成后执行的函数；
- onBeforeUpdate(): 组件更新之前执行的函数；
- onUpdated(): 组件更新完成之后执行的函数；
- onBeforeUnmount(): 组件卸载之前执行的函数；
- onUnmounted(): 组件卸载完成后执行的函数；
- onActivated(): 被包含在 <keep-alive> 中的组件，会多出两个生命周期钩子函数，被激活时执行；
- onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行；
- onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201214133959913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW1vemlxaWFu,size_16,color_FFFFFF,t_70)



### 3.ref和reactive的区别

#### 从定义数据方面

- ref通常用来定义基本类型数据
- reactive用来定义：对象（或者数组）类型数据
- ref也可以用来定义对象或者数组类型的数据，内部会通过reactive转为[代理对象]

#### 从原理方面

- ref通过[Object.defineProperty](https://so.csdn.net/so/search?q=Object.defineProperty&spm=1001.2101.3001.7020)()的get和set实现数据代理。
- reactive使用Proxy实现数据代理，并且通过Reflect操作源对象内部的数据。

#### 从使用方面

- ref操作数据需要.value，template模板中不需要。
- reactive都不需要.value

```vue
<template>
  <div>潜在客户：{{ doubleCount }} 当前客户数量：{{ currentUser }}</div>
  <el-button @click="state.count++">潜在+1</el-button>+
  <el-button @click="addOneCus">潜在+1</el-button>
</template>

<script setup lang="ts">
import { ref, reactive, computed } from 'vue'

const state = reactive({
  count: 1,
})

const currentUser = ref(0)

const doubleCount = computed(() => state.count * 2)

const addOneCus = () => {
  currentUser.value++
}
</script>

<style scoped></style>

```



### 4.watch用法及watch中使用ref和reactive的区别

#### ref和watch

```js
import { ref, watch } from 'vue';
 
const count = ref(0);
 
watch(count, (newVal, oldVal) => {
  console.log(`count 从 ${oldVal} 变为 ${newVal}`);
});
```

#### reactive和watch

```js
import { reactive, watch } from 'vue';
 
const state = reactive({
  count: 0,
});
 
watch(
  () => state.count,
  (newVal, oldVal) => {
    console.log(`count 从 ${oldVal} 变为 ${newVal}`);
  }
);
```

#### 区别

1.**对单个值的监视：**

- `ref`用于创建单个基本数据类型的响应式数据，可以直接通过`watch`来监视其变化。
- `reactive`用于创建包含多个属性的响应式对象，需要通过`() => state.count`这样的方式来指定要监视的属性。

2.ref 的监听是浅层的：

使用 ref 创建的变量是一个简单的响应式引用，它包裹着基本类型的值或对象的引用。当你通过 ref 创建的变量被用于模板或组件的渲染时，对该变量进行更改会触发视图的重新渲染，因为 Vue 会跟踪对 ref 引用的更改。然而，当 ref 引用的是一个对象时，更改对象内部属性的值不会自动触发视图的重新渲染。你需要手动使用 .value 访问或修改对象属性的值。如果想要监听对象属性，可以使用deep属性，也可以直接监听单个数据

3.reactive 可以深层监听对象属性：

使用 reactive 可以对整个对象进行响应式包装，包括对象内部属性。reactive 会递归地将对象的所有属性转换为响应式属性，使得当任何属性值发生变化时，都能触发相关的依赖更新。对于嵌套对象或数组，它们的内部属性的修改也会被监听到，并触发相应的更新。

> 总结来说，ref 是一种简单的响应式引用，用于包装基本类型的值或对象的引用。它的监听是浅层的，意味着当对 ref 引用的对象的属性进行修改时，变化不会自动触发更新。相比之下，reactive 可以对整个对象进行深层监听，包括对象内部属性的修改。它适用于需要监听对象属性的场景

### 5.provide

![在这里插入图片描述](https://img-blog.csdnimg.cn/bbb3b0c8363e4a14bdcf624169f6c6d1.png#pic_center)

#### 使用方法

Vue3:

- 顶层组件

```js
provide（‘key',data)
```

- 底层组件

```js
const message=inject('key')
```

Vue2:

```vue
<template>
  <!-- 父组件 -->
  <div>
    <Child></Child>
  </div>
</template>

<script>
import Child from "./seed/index";
export default {
  components: {
    Child,
  },
  provide: {
    message: "传给孙组件的值",
  },
  data() {
    return {};
  },
};
</script>

```

```vue
<template>
  <!-- 孙组件 -->
  <div>
    {{message }}
  </div>
</template>

<script>
export default {
  inject: ["message"],
  data() {
    return {};
  },
};
</script>

```

> 传过去的必须是可监听的对象，其他类型都不行。

### 6.vue2/3生命周期

> 1、beforeCreate:
> 在实例初始化之后，但在数据观测和事件配置之前被调用。此时，data和methods等选项尚未初始化，并且无法访问this。
>
> 2、created:
> 实例已经完成数据观测和事件配置，但挂载阶段还未开始。在这个阶段，可以访问data和methods，并且可以进行一些异步操作。
>
> 3、beforeMount:
> 在挂载开始之前被调用。此时，模板编译已经完成，但尚未将模板渲染到DOM中。
>
> 4、mounted:
> 挂载完成时被调用。此时，实例已经将模板渲染到DOM中，并且可以对DOM进行操作。通常在这个阶段进行一些初始化的工作，比如获取远程数据。
>
> 5、beforeUpdate:
> 数据更新时调用，但在DOM重新渲染之前。在这个阶段，可以对数据进行一些处理或做一些其他操作。
>
> 6、updated:
> 数据更新完成时调用。此时，DOM已经重新渲染，可以对更新后的DOM进行操作。
>
> 7、beforeDestroy:
> 实例销毁之前调用。在这个阶段，实例仍然完全可用，可以进行一些清理工作。
>
> 8、destroyed:
> 实例销毁之后调用。在这个阶段，实例已经被销毁，所有的事件监听器和子组件也都被移除。
>
> 两个特殊的生命周期钩子函数
>
> 1、activated:
> 在使用<keep-alive>组件时调用。activated钩子函数在被缓存的组件激活时调用，可以用来执行一些需要在组件被激活时触发的操作。
>
> 2、deactivated:
> 在使用<keep-alive>组件时调用。deactivated钩子函数在被缓存的组件停用时调用，可以用来执行一些需要在组件被停用时触发的操作。
>
> 这两个钩子函数主要用于处理缓存组件（通过<keep-alive>包裹的组件）的状态变化，比如在页面切换时，缓存的组件从激活状态切换到停用状态，或者从停用状态切换到激活状态时，可以在这两个钩子函数中进行一些操作，例如更新数据、发送请求等。

> ```js
> import {onBeforeMount,onMounted,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted} from "vue";
> 
> ```
>
> beforecreate和created(被setup方法所取代)，我们可以在setup方法中访问的API生命周期钩子有9个选项:
> onBeforeMount – 在挂载开始之前被调用：相关的 render 函数首次被调用。
>
> onMounted – 组件挂载时调用
>
> onBeforeUpdate – 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。
>
> onUpdated – 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
>
> onBeforeUnmount – 在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。
>
> onUnmounted – 卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。
>
> onErrorCaptured – 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播
>
> 

### 7.Object.defineProperty与Proxy的区别

> vue2.x Object.definedProperty
>
> vue3.x Proxy

#### Object.defineProperty的问题

- 不能监听数组变化
- 必须遍历对象的每个属性Object.keys()
- 必须深层遍历嵌套对象

#### 关于Proxy

- 针对整个对象
- 解决了无法劫持数组的问题
- 有更多的拦截方法，有助于性能提升

# React相关

### 1.类组件和函数组件

- ##### 函数组件

> 使用JS函数创建的组件；
>
> 首字母大写，React根据此区分组件和HTML元素；
>
> 函数必须有返回值,不渲染内容需要返回null；

```jsx
//普通函数
function Header(){
    return <div>头部组件</div>
}
//箭头函数
const Footer=()=>{
    return <div>Rooter</div>
}


```

- ##### 类组件

> 使用class语法创建的组件；
>
> 首字母大写，必须继承React.Component父类；
>
> 必须有render函数，返回UI结构，可返回null;

##### 状态组件：

- 无状态组件不定义状态，没有组件生命周期，只负责渲染UI，Hooks出现后函数组件也可以有状态；性能较好；
- 有状态组件可以定义自己的状态，拥有生命周期，能力更强；

##### 类组件问题：

- 处理this问题：绑定箭头函数、bind，声明箭头函数

```js
import { Component } from "react";
 
class App extends Component {
  // 状态
  state = {
    count: 0,
  };
  // 事件处理函数
  handleClick(e) {
    console.log(e)
    console.log(this.state.count)
  }
  render() {
    return (
      <>
        <div>计数器：{this.state.count}</div>
        <div>
+          <button onClick={(e)=>this.handleClick(e)}>按钮</button>
        </div>
      </>
    );
  }
}
export default App;
```

```js
import { Component } from "react";
 
class App extends Component {
  // 状态
  state = {
    count: 0,
  };
  // 事件处理函数
  handleClick(e) {
    console.log(e)
    console.log(this.state.count)
  }
  render() {
    return (
      <>
        <div>计数器：{this.state.count}</div>
        <div>
+          <button onClick={this.handleClick.bind(this)}>按钮</button>
        </div>
      </>
    );
  }
}
export default App;
```

```js
import { Component } from "react";
 
class App extends Component {
  // 状态
  state = {
    count: 0,
  };
  // 事件处理函数
+  handleClick = (e) => {
    console.log(e)
    console.log(this.state.count)
  }
  render() {
    return (
      <>
        <div>计数器：{this.state.count}</div>
        <div>
          <button onClick={this.handleClick}>按钮</button>
        </div>
      </>
    );
  }
}
export default App;
```

- setState

```js

  handleClick = () => {
    // 修改数据
    this.setState({
      // key是要修改的数据名称，value是对应的新值
      count: this.state.count + 1,
    });
  };
  updateList = () => {
    // 修改列表
    this.setState({
      list: [...this.state.list, '相机'],
    });
  };
  updateUser = () => {
    // 修改对象
    this.setState({
      user: {
        ...this.state.user,
        name: 'tony',
      },
    });
  };

```

##### 相同点

- 都可以接受属性，返回React元素；

##### 不同点

- 编程思想不同，类组件需要创建实例，基于面向对象的编程方法，而函数式是基于函数式编程；
- 内存占用不用：类组件需要创建并保存实例，会占用一定内存，函数组件不需要创建实例，可以节约内存占用；
- 捕获特性：函数组件具有值捕获特性；
- 状态：类组件有自己的实例，可以定义状态，而且可以修改状态更新组件，函数式组件以前没有状态，现在可以使用 useState 使用状态
- 生命周期：类组件有自己完整的生命周期，可以在生命周期内编写逻辑，函数组件以前没有生命周期，现在可以使用 useEffect 实现类似生命周期的功能
- 逻辑复用：类组件可以通过继承实现逻辑复用，但官方推荐组件优于继承，函数组件可以通过自定义 hooks 实现逻辑的复用
- 跳过更新：类组件可以通过 `shouldComponentUpdate` 和 `PureComponent` 来跳过更新，而函数式组件可以使用 `React.memo` 来跳过更新
- 发展前景：未来函数式组件将会成为主流，因为它可以更好的屏蔽 this 问题、规范和复用逻辑，更好的适合事件分片和并发渲染

### 2.React Hook及其优化策略

> React组件创建方式，一种是类组件，一种是纯函数组件。React团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要直接组合管道即可。

- 纯函数组件没有状态
- 纯函数组件没有生命周期
- 纯函数组件没有this

`==>`函数组件只能做UI展示，涉及到状态的管理与切换，不得不用类组件或者redux

- 简单网页会导致代码很重
- 创建一个类组件需要继承一个React实例

#### ReactHooks

> 以函数的形式替代原来继承类的形式，并且使用预函数的形式管理state，有hooks可以不再使用类的形式定义组件了

##### 优点

- 告别难以理解的Class（this和生命周期痛点）
- 解决业务逻辑难以拆分的问题
- 使得状态逻辑复用变得简单可行
- 函数组件从设计思想上更加契合React的理念

##### 缺点

- 不能完全补齐函数组件类组件的能力
- 将类组件的复杂变成函数组建的轻量
- Hooks在使用层面有严格规则拘束

```js
//类组件实现计数器
import React, {Component} from "react";
class AddCount extends Component {
    constructor(props) {
        super(props);
        this.state = {
            count : 0
        }
    }
    addcount = () => {
        let newCount = this.state.count;
        this.setState({
            count: newCount += 1
        })
    }
    render() {
        return (
            <>
                <p>{ this.state.count }</p>
                <button onClick={ this.addcount }>count++</button>
            </>
        )
    }
}
export default AddCount;

```

#### 常用钩子

- useState()
- useContext()
- useEffect()
- useReducer()
- 钩子（自定义）都要命名为useXXX

#### hook函数

- **useState() :状态钩子**

> 用于为函数组件引入state状态，并进行状态数据的读写操作

```js
//第一个参数为初始化值，第二个为更新状态的函数
const [state,setState]=React.useState(initValue)

//直接指定新的状态值，内部覆盖原来的值
setState(newValue)

//接受原本状态值，返回新状态值
setState(value=>newValue)

```

```js
//React hooks实现计数器
import React,{ useState } from "react";

const NewCount = ()=> {
    const [ count,setCount ] = useState(0)
    addCount = ()=> {
        let newCount = count;
        setCount(newCount +=1)
    }
   return (
       <>
           <p> { count }</p>
           <button onClick={ addCount }>Count++</button>
       </>
   )
}
export default NewCount;

```

- `useContext()`:共享状态钩子

> 做状态的分发，避免React逐层通过Props()传递数据，常用于祖租价和后代组件间通信

```js
//1.创建COntext容器对象
const xxxContext=React.createContext()

//2.渲染子组件时，外面包裹xxxContext.Provider,通过value属性给后代组件传递数据
<xxxContext.Provider value={数据}>
	<子组件/>    
</xxxContext.Provider>

//3.后代组件读取数据
const {}=useContext(xxxContext)
```

```js
import React, { useContext } from "react";
const HookTest = ()=> {
    const AppContext = React.createContext();
    const A = ()=> {
        const { name } = useContext(AppContext)
        return (
            <p>
                我是A组件,我的名字是：{ name }；
                <span>我是A的子标签：{ name }</span>
            </p>
        )
    }
    const B= ()=> {
        const { name } = useContext(AppContext);
        return (
            <p>我是B组件,名字是： { name }</p>
        )
    }
    return (
        <AppContext.Provider value={{ name: '张三'}}>
            <A />
            <B />
        </AppContext.Provider>
    )
}
export default HookTest;

```

## Hooks

### 分类

- 组件状态处理相关：useState、useReducer、useContext
- 处理副作用：useEffect、useLayoutEffect
- 性能优化相关：useMemo、useCallback
- DOM相关：useRef
- redux相关：useSelector、useDispatch、useStore
- 用户自定义hook等

#### useState

> 在函数组件保存数据的主要方法，等同于类组件的 this.state 与 this.setState

```react
  const [count, setCount] = React.useState(0)
```

接受初始值，返回一个state以及更新函数；初始值可以为一个函数，但是其返回需要时数组；



#### useEffect

> 类组件中在生命周期中执行副作用，useEffect的作用是补充函数组件无法正确执行副作用的问题；
>
> 在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。

```react
  const fetchData = () => {
    console.log("fetchData")
  }

  useEffect(() => {
    fetchData()
  }, [])

```

useEffect接受两个参数：

- 被监听的参数发生变化时执行回调函数；
- 被监听的参数

当监听参数发生变化时就会执行回调，这里的空数组只会在初次渲染时执行，等同于`componentDidMount`

useEffect善用参数1、2可以代替大部分生命周期；

1.  componentDidMount 如上面实例，参数为空数组，表示不依赖任何数据，只在初次渲染后触发
2.  同时代替 componentDIdMount 和 componentDidUpdate， 有三种场景

```react
// 没有指定state
React.useEffect(() => {
  console.log('任意state发生变化都会触发, 包括初始化,  componentDIdMount + componentDidUpdate')
})

// 指定 state
React.useEffect(() => {
  console.log("只有当n发生变化才会触发，包括初始化，componentDIdMount + componentDidUpdate")
}, [n])

React.useEffect(() => {
  console.log("只有当 n 或 x 发生变化才会触发，包括初始化，componentDIdMount + componentDidUpdate")
}, [n, x])

// 指定state，回调有返回新的函数
React.useEffect(() => {
  function change n() {}
  SomeAction.subscribe(change, n) // 重新订阅 n
  return () => {
     SomeAction.unSubscribe(change, n) // 取消订阅 n
  }
}, [n]) // 假设 n 和监听器或者定时器等有关联，n 变化后需要重新订阅，或者是重启定时器之类的情况
```

3. 代替componentWillUnmount

```react
React.useEffect(() => {
  console.log('空数组，仅第一次执行，componentDIdMount')
  const onResize = (e) => {}
  window.addEventListener('resize', onResize)
  return ()=>{
    window.removeEventListener('resize', onResize)
    console.log('会在组件卸载调用, componentWillUnmount');
  }
}, [])
```

#### useMemo

> 解决函数组件的性能问题，比如子组件重复执行问题，每次渲染都进行高开销的计算

```react
function Sub(props) {
 console.log("Sub render");
  let { number, onClick } = props
  return (
    <button onClick={onClick}>{number}</button>
  )
}

function Test() {
  let [value, setValue] = React.useState('')
  let [number, setNumber] = React.useState(0)
  const addClick = () => setNumber(number + 1)
  return <>
    <input
      type="text"
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
    <Sub number={number} onClick={addClick} />
  </>
}
```

上面代码，子组件依赖只有number，理想情况下只希望number变化时触发子组件重新渲染，但是实际是在输入框内的值发生变化，子组件也会冲洗你渲染，class组件使用`shoouldComponentUopdate(nextProp,nxtState)`生命周期，在组件更新之前，判断当前组件是否受某个state或prop更改的影响。

> 在函数组件中，不区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部所有逻辑，带来巨大的性能损耗；
>
> useMemo和useCallback都是解决上述性能问题的

#### React.memo

```jsx
import { useState } from 'react'
import { memo } from 'react'
const Child = memo((props) => {
  console.log('Child render')

  return (
    <>
      <div>子组件</div>
    </>
  )
})

export default Child

```

```jsx
  const [p1, setP1] = useState("Hello")
  const [p2, setP2] = useState("World")
  //p4每次在父组件重新渲染的时被重新声明，导致子组件认为更新了；
  const p4 = () => {
    console.log("p1", p1, "p2", p2)
  }
  return (
    <div className="App">
      <div className="mainView">
        <div>我是父组件，count: {count}, p1: {p1}, p2: {p2}</div>
        <MyButton type="primary" text="点击+1" clickFunction={() => setCount(count + 1)} />
        <Child p1={p1} p2={p2} p4={p4} />

      </div>
    </div>
  )

```

使用useCallbck

```jsx
  const [p1, setP1] = useState("Hello")
  const [p2, setP2] = useState("World")

  const p4 = useCallback(() => {
    console.log("p1", p1, "p2", p2)
  }, [p1, p2])
  return (
    <div className="App">
      <div className="mainView">
        <div>我是父组件，count: {count}, p1: {p1}, p2: {p2}</div>
        <MyButton type="primary" text="点击+1" clickFunction={() => setCount(count + 1)} />
        <Child p1={p1} p2={p2} p4={p4} />

      </div>
    </div>
  )
}
```



#### useCallback

> useCallback(fn,deps)相当于useMemo(()=>fn,deps)
>
> useMemo返回一个值，可能是表示数组的对象，useCallback返回一个函数。

所有依赖本地状态或props来创建函数，需要使用到缓存函数的地方，都是useCallback的应用场景

#### useRef

> 类组件中createRef生成DOM节点的引用，在函数组件中也可以使用；

```react
  let [text, setText] = useState('')
  const textRef = useRef()

  useEffect(() => {
    textRef.current = text
    console.log(textRef)
  }, [text])


  <input ref={textRef} value={text} onChange={e => setText(e.target.value)}></input>
        <p>当前内容：{text}</p>
```

#### useContext

> 优化了函数组件context的能力，并进行了写法上的统一；
>
> context 类似于 vue provide的概念，无需将组件传递到每一个组件，跨组件级传递变量，实现共享

#### useReducer

> 类似于状态机，有不同的状态，并且有修改状态的方法；

```js
function countReducer(state, action) {
    switch(action.type) {
        case 'add':
            return state + 1;
        case 'sub':
            return state - 1;
        default: 
            return state;
    }
}
```

useReducer可以增强函数组件中reducer的使用

```react
import './App.css'
import MyButton from './components/Button'
import Modal from './components/Modal'
import { useState, useMemo, useEffect, useRef, useReducer } from 'react'

import { useSelector, useDispatch } from 'react-redux'
import { increment, decrement } from './store/counter'

function App () {
  const [count, dispatch] = useReducer((state, action) => {
    switch (action) {
      case 'increment':
        return state + 1
      case 'decrement':
        return state - 1
      default:
        return state
    }
  }, 0)


  return (
    <div className="App">
      <div className="mainView">
        <p>{count}</p>
        <MyButton clickFunction={() => dispatch('increment')} text={'Increment'} />
        <MyButton clickFunction={() => dispatch('decrement')} text={'Decrement'} />
      </div>


    </div>
  )
}

export default App

```

### 3. React性能优化有哪些方法？

https://blog.csdn.net/weixin_43484007/article/details/124366452

https://zhuanlan.zhihu.com/p/425635864?utm_id=0

> 父子组件重新渲染情况：
>
> - 从同一组件或父组件中调用setState时；
> - 从父级收到的prop的值发生变化；
> - 调用组件中的forceUpdate

#### 性能优化的三个方面

- 前端通用优化
- 减少不必要的组件更新：这类优化是在组件状态发生变更后，通过减少不必要的组件更新来实现，对应到 React 中就是：**减少渲染的节点 、降低组件渲染的复杂度、充分利用缓存避免重新渲染**（利用缓存可以考虑使用PureComponent、React.memo、hook函数useCallback、useMemo等方法）

> PureComponent 是对**类组件**的 Props 和 State 进行浅比较；React.memo 是对**函数组件**的 Props 进行浅比较

- 提交阶段优化：减少提交阶段耗时；

#### 前端通用优化

##### 组件按需加载

- 懒加载

从一个路由跳转到另一个路由，可用于用户操作后才展示的复杂组件；

主要是通过 Webpack 的动态导入和 `React.lazy` 方法。注意，实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。

```react
import { lazy, Suspense, Component } from "react"
import "./styles.css"

// 对加载失败进行容错处理
class ErrorBoundary extends Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    return { hasError: true }
  }

  render() {
    if (this.state.hasError) {
      return <h1>这里处理出错场景</h1>
    }

    return this.props.children
  }
}

const Comp = lazy(() => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        reject(new Error("模拟网络出错"))
      } else {
        resolve(import("./Component"))
      }
    }, 2000)
  })
})

export default function App() {
  return (
    <div className="App">
      <div style={{ marginBottom: 20 }}>
        实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。
      </div>
      <ErrorBoundary>
        <Suspense fallback="Loading...">
          <Comp />
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}
```



- 懒渲染

懒渲染指当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal/Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。

适用于：

1. 页面中多次出现的组件，且组件渲染费时、或者组件中含有接口请求。
2. 需要用户操作后才展示的组件。但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单。

- 虚拟列表

#### 批量更新

在React18中会有并发模式，在并发模式中，将默认以批量更新方式执行 setState。到那时候，或许就不需要这个优化了。



#### 利用debounce、throttle避免重复回调

在搜索组件中，当 input 中内容修改时就触发搜索回调。当组件能很快处理搜索结果时，用户不会感觉到输入延迟。但实际场景中，中后台应用的列表页非常复杂，组件对搜索结果的 Render 会造成页面卡顿，明显影响到用户的输入体验。

```react
import { useState, useEffect } from "react"
import { useDebounce } from "use-debounce"

export default function App() {
  const [text, setText] = useState("Hello")
  const [debouncedValue] = useDebounce(text, 300)

  useEffect(() => {
    // 根据 debouncedValue 进行搜索
  }, [debouncedValue])

  return (
    <div>
      <input
        defaultValue={"Hello"}
        onChange={e => {
          setText(e.target.value)
        }}
      />
      <p>Actual value: {text}</p>
      <p>Debounce value: {debouncedValue}</p>
    </div>
  )
}
```

##### 为什么搜索场景中使用debounce而不是throttle呢？

> **在搜索场景中，只需响应用户最后一次输入，无需响应用户的中间输入值，debounce 更适合使用在该场景中。而 throttle 更适合需要实时响应用户的场景中更适合，如通过拖拽调整尺寸或通过拖拽进行放大缩小（如：window 的 resize 事件）。实时响应用户操作场景中，如果回调耗时小，甚至可以用 requestAnimationFrame 代替 throttle。**

#### 缓存优化

缓存优化往往是最简单有效的优化方式，在 React 组件中常用 useMemo 缓存上次计算的结果。当 useMemo 的依赖未发生改变时，就不会触发重新计算。一般用在「计算派生状态的代码」非常耗时的场景中，如：遍历大列表做统计信息。



#### 跳过不必要的组件更新

##### PureComponent、React.memo

在React工作流中，如果只有父组件发生状态更新，即使父组件传给子组件的所有props都没有修改，也会引起子组件的Render过程。从 React 的声明式设计理念来看，如果子组件的 Props 和 State 都没有改变，那么其生成的 DOM 结构和副作用也不应该发生改变。当子组件符合声明式设计理念时，就可以忽略子组件本次的 Render 过程。

**PureComponent 是对类组件的 Props 和 State 进行浅比较，React.memo 是对函数组件的 Props 进行浅比较**。

##### ShouldComponentUpdate

##### useMemo、useCallback实现稳定的props值

如果传给子组件的派生状态或函数，每次都是新的引用，那么 PureComponent 和 React.memo 优化就会失效。所以需要使用 useMemo 和 useCallback 来生成稳定值，并结合 PureComponent 或 React.memo 避免子组件重新 Render。

> **拓展知识**
> useCallback 是「useMemo 的返回值为函数」时的特殊情况，是 React 提供的便捷方式。在 [React Server Hooks 代码](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fee432635724d5a50301448016caa137ac3c0a7a2%2Fpackages%2Freact-dom%2Fsrc%2Fserver%2FReactPartialRendererHooks.js%23L452) 中，useCallback 就是基于 useMemo 实现的。尽管 React Client Hooks 没有使用同一份代码，但 [useCallback](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fee432635724d5a50301448016caa137ac3c0a7a2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactFiberHooks.new.js%23L1590) 的代码逻辑和 [useMemo](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fee432635724d5a50301448016caa137ac3c0a7a2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactFiberHooks.new.js%23L1613) 的代码逻辑仍是一样的。

##### 使用发布者订阅者模式跳过中间组件Render过程

每次状态的更新都会涉及中间组件的 Render 过程，但中间组件并不关心该状态，它的 Render 过程只负责将该状态再传给子组件。在这种场景下可以将状态用发布者订阅者模式维护，只有关心该状态的组件才去订阅该状态，不再需要中间组件传递该状态。当状态更新时，发布者发布数据更新消息，只有订阅者组件才会触发 Render 过程，中间组件不再执行 Render 过程。

##### 列表项使用key属性

```jsx
<!-- 前一次 Render 结果 -->
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

<!-- 新的 Render 结果 -->
<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

使用key：

```jsx
<!-- 前一次 Render 结果 -->
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<!-- 新的 Render 结果 -->
<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

React Diff 算法会把 key 值为 2015 的虚拟 DOM 进行比较，发现 key 为 2015 的虚拟 DOM 没有发生修改，不用更新。同样，key 值为 2016 的虚拟 DOM 也不需要更新。结果就只需要创建 key 值为 2014 的虚拟 DOM。相比于不使用 key 的代码，使用 key 节省了两次 DOM 更新操作。

[React 官方推荐](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Freactjs.org%2Fdocs%2Flists-and-keys.html%23keys)将每项数据的 ID 作为组件的 key，以达到上述的优化目的。并且不推荐使用*每项的索引*作为 key，因为传索引作为 key 时，就会退化为不使用 key 时的代码。

> 是否在所有列表渲染的场景下，使用 ID 都优于使用索引呢？？
>
> 答案是否定的，在常见的分页列表中，第一页和第二页的列表项 ID 都是不同，假设每页展示三条数据，那么切换页面前后组件 Render 结果如下。
>
> ```jsx
> <!-- 第一页的列表项虚拟 DOM -->
> <li key="a">dataA</li>
> <li key="b">dataB</li>
> <li key="c">dataC</li>
> 
> <!-- 切换到第二页后的虚拟 DOM -->
> <li key="d">dataD</li>
> <li key="e">dataE</li>
> <li key="f">dataF</li>
> ```
>
> 切换到第二页后，由于所有 `<li>` 的 key 值不同，所以 Diff 算法会将第一页的所有 DOM 节点标记为删除，然后将第二页的所有 DOM 节点标记为新增。整个更新过程需要三次 DOM 删除、三次 DOM 创建。如果不使用 key，Diff 算法只会将三个 `<li>` 节点标记为更新，执行三次 DOM 更新。

##### useMemo返回虚拟DOM

利用 useMemo 可以缓存计算结果的特点，如果 useMemo 返回的是组件的虚拟 DOM，则将在 useMemo 依赖不变时，跳过组件的 Render 阶段。



该方式与 React.memo 类似，但与 React.memo 相比有以下优势：

1. 更方便。React.memo 需要对组件进行一次包装，生成新的组件。而 useMemo 只需在存在性能瓶颈的地方使用，不用修改组件。
2. 更灵活。useMemo 不用考虑组件的所有 Props，而只需考虑当前场景中用到的值，也可使用 [useDeepCompareMemo](https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Fsandiiarov%2Fuse-deep-compare%23usedeepcomparememo) 对用到的值进行深比较。

```jsx
import { useEffect, useMemo, useState } from "react"
import "./styles.css"

const renderCntMap = {}

function Comp({ name }) {
  renderCntMap[name] = (renderCntMap[name] || 0) + 1
  return (
    <div>
      组件「{name}」 Render 次数：{renderCntMap[name]}
    </div>
  )
}

export default function App() {
  const setCnt = useState(0)[1]
  useEffect(() => {
    const timer = window.setInterval(() => {
      setCnt(v => v + 1)
    }, 1000)
    return () => clearInterval(timer)
  }, [setCnt])

  const comp = useMemo(() => {
    return <Comp name="使用 useMemo 作为 children" />
  }, [])

  return (
    <div className="App">
      <Comp name="直接作为 children" />
      {comp}
    </div>
  )
}
```

##### 避免创建不必要的外层元素标签

解决方式：使用 `<></>` 代替 `<div></div>`充当组件最外层元素标签



#### 提交阶段优化

React 工作流提交阶段的第二步就是执行提交阶段钩子，它们的执行会阻塞浏览器更新页面。如果在提交阶段钩子函数中更新组件 State，会再次触发组件的更新流程，造成两倍耗时。

##### 避免在didMount,didUpdate中更新组件state



### 4.React.createClass vs extends Component

#### 写法的区别

> `React` 中有两种支持创建组件的方法，你可以通过 `React.createClass` 和 `extends React.Component`，他们实现的目的都是一样的。区别就在于你是否是以 `ES6` 的形式。

```jsx
/使用es6时在constructor中初始化参数
class Children extends React.Component{
    constructor(props)
    super(props)
    this.state={
        
    }
}

//使用createClass需要使用getInitState
const MyComponent=React.createClass({
    getInitState(){
        return {
            /* init state */
        }
    }
})
```

#### 函数this自绑定

> `React.createClass`创建的组件，其每一个成员函数的`this`都有`React`自动绑定，任何时候使用，直接使用`this.method`即可，函数中的`this`会被正确设置。

```jsx
const Contacts = React.createClass({
  handleClick() {
    console.log(this); // React Component instance
  },
  render() {
    return (
      <div onClick={this.handleClick}></div>
    );
  }
});
```

> `React.Component`创建的组件，其成员函数不会自动绑定`this`，需要开发者手动绑定，否则`this`不能获取当前组件实例对象。

```jsx
class Contacts extends React.Component {
  constructor(props) {
    super(props);
  }
  handleClick() {
    console.log(this);
  }
  render() {
    return (
      <div onClick={this.handleClick.bind(this)}></div>
    );
  }
}
```

三种绑定this的方法：

```jsx
/1
constructor(props) {
  super(props);
  this.handleClick = this.handleClick.bind(this); //构造函数中绑定
}

/2
<div onClick={this.handleClick.bind(this)}></div> 
//使用bind来绑定

/3
<div onClick={()=>this.handleClick()}></div> //使用arrow function来绑定

```

#### 组件属性类型propTypes及其默认props属性defaultProps配置不同

> `React.createClass`在创建组件时，有关组件`props`的属性类型及组件默认的属性会作为组件实例的属性来配置，其中`defaultProps`是使用`getDefaultProps`的方法来获取默认组件属性的:

```jsx
const TodoItem = React.createClass({
  propTypes: { // as an object
    name: React.PropTypes.string
  },
  getDefaultProps(){   // return a object
    return {
      name: ''
    }
  }
  render(){
    return <div></div>
  }
})
```

> `React.Component`在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。对应上面配置如下：

```jsx
class TodoItem extends React.Component {
  static propTypes = {//类的静态属性
    name: React.PropTypes.string
  };
 
  static defaultProps = {//类的静态属性
    name: ''
  };
 
  //...
}
```

#### 组件初始状态state配置不同

> `React.createClass`创建的组件，其状态`state`是通过`getInitialState`方法来配置组件相关的状态；
>
> `React.Component`创建的组件，其状态`state`是在`constructor`中像初始化组件属性一样声明的。

```jsx
const TodoItem = React.createClass({
  // return an object
  getInitialState(){
    return {
      isEditing: false
    }
  }
  render(){
    return <div></div>
  }
})
```

```jsx
class TodoItem extends React.Component{
  constructor(props){
    super(props);
    this.state = { // define this.state in constructor
      isEditing: false
    }
  }
  render(){
    return <div></div>
  }
}
```

#### Mixins的支持不同

> `ixins`(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过`Mixins`进该对象来达到代码复用。
>
> `React.createClass`在创建组件时可以使用`mixins`属性，以数组的形式来混合类的集合。

```jsx
var SomeMixin = {
  doSomething() {
 
  }
};
const Contacts = React.createClass({
  mixins: [SomeMixin],
  handleClick() {
    this.doSomething(); // use mixin
  },
  render() {
    return (
      <div onClick={this.handleClick}></div>
    );
  }
});
```

> 但是遗憾的是`React.Component`这种形式并不支持`Mixins`，至今`React`团队还没有给出一个该形式下的官方解决方案；但是`React`开发者社区提供一个全新的方式来取代`Mixins`,那就是`Higher-Order Components`(高阶组件)。

### 5.React事件与HTML的事件有什么区别？

#### 命名方式

原生事件全部为小写，react事件微小驼峰

#### 事件处理函数语法

原生为字符串，react为函数；

```jsx
原生HTML：<button onclick="handleClick()">Click Me</button>
 
React：
class MyComponent extends React.Component {
  handleClick() {
    // 处理点击事件的逻辑
  }
 
  render() {
    return <button onClick={this.handleClick}>Click Me</button>;
  }
}
```

#### 阻止浏览器默认行为

react不能用return false来阻止，而必须调用event.preventDefault()来阻止

#### 相比HTML事件React事件的优点

- 兼容所有浏览器，更好的跨平台
- 将事件统一存放在一个事件池，减少了内存消耗，避免频繁的增删
- 便于react统一管理，提高了事件机制的执行效率；

#### 执行顺序

- 原生先，合成事件后：若原生事件和合成事件混用，会导致合成事件无法执行；

### 6.受控组件和非受控组件

#### 基本概念

> 在HTML中，表单元素的标签：<input>、<textarea>、<select>等元素标签的值改变通常是根据用户输入来进行更新。
> 在React中，可变状态通常保存在组件的状态属性中，并且只能使用 setState() 进行更新，而呈现表单的React组件也控制着在后续用户输入时该表单中发生的情况，以这种由React控制的输入表单元素而改变其值的方式，称为受控组件。
>
> 非受控组件是一种不由React状态控制的组件，表单数据由DOM本身处理。即不受setState()的控制，与传统的HTML表单输入相似，input输入值即显示最新值。
>
> 在非受控组件中，可以使用一个ref来从DOM获得表单值。

#### 受控组件更新state的流程

1. 先通过初始state声明数据通过value属性来绑定为表单的默认值
2. 每当表单值发生变化的时候，调用onChange事件处理器
3. 事件处理器通过事件对象event拿到改变后的状态，并更新组件的state
4. 一旦setState方法更新state，就会重新渲染视图，完成表单组件的更新

#### 应用场景

> 1、受控组件使用场景：
> ①. 当需要对组件的值进行验证和处理时。例如，当您需要确保文本框的值仅包含数字时，您可以使用受控组件来验证文本框的值，并更新React状态以反映验证结果。
>
> ②.当需要确保组件的值与应用程序的状态同步时。例如，当您需要确保文本框的值与应用程序的状态同步时，您可以使用受控组件来更新React状态，并确保组件的值与应用程序的状态同步。
>
> 2、非受控组件使用场景：
> ①.当需要高速更新组件的值时。例如，当您需要实现实时搜索框时，您可以使用非受控组件来快速更新文本框的值，并更新搜索结果。
>
> ②.当组件的值不需要与应用程序的状态同步时。例如，当您需要实现一个单选按钮组时，您可以使用非受控组件来更新单选按钮的值，并且不需要将其与应用程序的状态同步。
>
> 

#### 优缺点

- 受控组件

> 优点：
>
> 1. 容易进行验证和处理：由于组件的值由React状态控制，就可以轻松地验证和处理组件的值。例如，可以使用onChange事件验证组件的值是否满足特定的条件，更新React状态反映验证结果。
>
> 2. 有更好的可预测性：由于组件的值由React状态控制，因此组件的行为更容易预测。例如，当组件的值发生变化时，它将始终更新React状态并重新渲染，这使得应用程序更加可预测。
>
> 缺点:
>
> 1. 更多的代码：由于组件的值由React状态控制，因此需要编写更多的代码来管理组件的值。这可能会导致代码更难以维护和理解。
> 2. 性能问题：由于每次组件的值发生变化时，它都会更新React状态并重新渲染，这可能会影响性能。如果您在处理大量数据时使用受控组件，则可能会遇到性能问题。

- 非受控组件

> 优点：
>
> 1. 更快的更新：由于组件的值由DOM节点控制，因此非受控组件可以更快地更新。这使得非受控组件适用于需要高速更新的场景，例如实时搜索框。
> 2. 更少的代码：由于组件的值不由React状态控制，因此需要编写更少的代码来管理组件的值。这使得代码更易于维护和理解。
>
> 缺点：
>
> 1. 难以进行验证和处理：因为组件的值不由React状态控制，难以对其进行验证和处理。
> 2. 更少的可预测性：组件的值由DOM节点控制，因此组件的行为更难以预测。例如，当组件的值发生变化时，它不会更新React状态并重新渲染，这可能会导致应用程序的行为更加不可预测。

### useState使用数组而非对象？

```react
cosnt [count,setCount]=useSate(0)
```

```jsx
const [value,setValue]=useState(0)

//数组解构
const foo=[1,2,3]
const [one,two,three]=foo
console.log(one,two,three);

//对象解构
const user={
    id:1,
    name:"martin"
}

const [id,name]=user

console.log(id,name);
```

#### 数据解构更加灵活

可以自由地命名你的状态变量和更新函数，而不是被迫使用像 `this.state` 和 `this.setState` 这样的命名。

```js
const [count, setCount] = useState(0);
```

如果 `useState` 返回一个对象，你就必须使用对象的解构赋值并且记住键的名称，这会增加记忆负担。例如，如果 `useState` 返回 `{ state, setState }`，那么你必须这样使用它：

```js
const { state: count, setState: setCount } = useState(0);
```

### 7.React refs

Refs提供了一种方式，允许我们访问DOM节点或在render方法中创建的React元素。

#### 何时使用Refs

1、管理焦点，文本选择或媒体播放。

2、触发强制动画。

3、集成第三方DOM库。

#### 使用方式

- 字符串形式的refs

```jsx
class Demo extends Component{
    constructor(props){
        super(props)
    }
    showData=()=>{
       console.log(this.refs.input1)//拿到标签为input1的真实DOM
       console.log(this.refs.input1.value)
    }
    render(){
        return(
            <div>
                <input ref='input1' type="text" placeholder='点击按钮提示数据'/>&nbsp;
                <button onClick={this.showData}>点我提示左侧数据</button>
            </div>
        )
    }
}
```

- 回调形式的refs

```jsx
class Demo extends Component{
    constructor(props){
        super(props)
    }
    showData=()=>{
       console.log(this.input1)//ref中的回调函数将自身节点放在了组件节点自身上，取名为input1
       console.log(this.input1.value)
    }
    render(){
        return(
            <div>
                <input ref={(currentNode)=>{this.input1=currentNode}} type="text" placeholder='点击按钮提示数据'></input>&nbsp;
                <button onClick={this.showData}>点我提示左侧数据</button>
            </div>
        )
    }
}
```

- createRef的使用

```jsx
class Demo extends Component{
    constructor(props){
        super(props)
        // React.creatRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点
        this.myRef=React.createRef()
    }
    showData=()=>{
       console.log(this.myRef)//输出myRef容器
       console.log(this.myRef.current)//输出input节点
       console.log(this.myRef.current.value)//输出input中的值
    }
    render(){ 
        return(
            <div>
                <input ref={this.myRef} type="text" placeholder='点击按钮提示数据'></input>&nbsp;
                <button onClick={this.showData}>点我提示左侧数据</button>
            </div>
        )
    }
}
```

### 8.为什么要使用hooks？

#### 复杂组件

> componentDidMount componentDidupdate componentWillUnmount
>
> addEventListener,removeEventListener
>
> 两个方法针对同一个事件，但是要放在两个生命周期中去执行；不符合高内聚低耦合的理念；
>
> useEffect(()=>()=>{},[])

#### 更好的状态复用

在 `class` 组件模式下，状态逻辑的复用是一件困难的事情。

#### 更好的代码组织

![img](https://pic.rmb.bdstatic.com/bjh/down/8fa6d5f45cc1c3473a884001f1947d12.png@s_0,w_2000)

无论是 `vue` 还是 `react`, 通过 `Hooks` 写法都能做到，将“分散在各种声明周期里的代码块”，通过 `Hooks` 的方式将相关的内容聚合到一起。

这样带来的好处是显而易见的：**“高度聚合，可阅读性提升”**。伴随而来的便是 **“效率提升，bug变少”**。

按照“物理学”里的理论来说，这种代码组织方式，就算是“熵减”了。

#### 比Class组件更容易理解

在 `react` 的 `class` 写法中，随处可见各种各样的 `.bind(this)`。（甚至官方文档里也有专门的章节描述了“为什么绑定是必要的？”这一问题）

`vue` 玩家别笑，`computed: { a: () => { this } }` 里的 `this` 也是 `undefined`。

很显然，绑定虽然“必要”，但并不是“优点”，反而是“故障高发”地段。

但在`Hooks` 写法中，你就完全不必担心 `this` 的问题了。

`Hooks` 写法直接告别了 `this`，从“函数”来，到“函数”去。

妈妈再也不用担心我忘记写 `bind` 了。

#### 版本需求

- vue>=2.6 + 插件   vue3.x
- react>=16.8.0

### 9.错误边界Error Boundary

UI的某一部分抛错不应该导致整个App都崩掉，[React](https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020) 16由此提出一个新概念叫“error boundary”，错误边界

“error boundary”是什么呢，是一个React组件。error boundary能捕获子组件树中发生的任何错误，然后打日志，返回fallback UI。

#### 错误范围

- render里
- 生命周期方法
- 子组件树的constructor

#### 不能捕获的范围

- 事件处理程序的错
- 异步代码的错
- SSR的错
- Error Boundary自己的错



### 10. React代码分割

对代码进行分割能够“懒加载”当前用户所需要的内容，能够显著提高应用的性能。尽管并没有减少应用的整体代码体积，但可以避免加载用户永远不需要的代码，并在初始加载的时候可以减少所需加载的代码量。

#### import

```jsx
import { add } from './math'

console.log(add(5, 10));


//动态导入
import('./math').then((math) => {
	console.log(math.add(5, 10))
})
```

当 Webpack 解析到该语法时，会自动进行代码分割。如果是使用 Create React App 创建的 React 应用，import 功能已开箱即用。

#### react.lazy

React.lazy 方法可以让我们动态加载组件，有助于缩减打包后 bundle 的体积，并延迟加载在初次渲染时未用到的组件。

React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 export default 的 React 组件。

```jsx
const AsyncComponent = React.lazy(() => import('./OtherComponent'));
```

React.lazy 返回的是一个异步组件 不能单独使用，需要配合 React.Suspense 使用。当这个异步组件的状态是 pending 时显示的是 Suspense 中 fallback 的内容，只有 resolve 时才会显示加载好的组件。如此使得我们可以在使用 lazy 组件时做优雅降级（如在 fallback添加 loading 效果等）。

```jsx
import React, { Suspense } from 'react';

const AsyncComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <AsyncComponent />
      </Suspense>
    </div>
  );
}
```

### 11.Fragments

React Fragment 是 React 中的一个特性，它允许你对一组子元素进行分组，而无需向 DOM 添加额外的节点，从而允许你从 React 组件中返回多个元素。

要从 React 组件返回多个元素，需要将元素封装在根元素中。这种方法效率不高，在某些情况下可能会引起问题。如：

```jsx
function TableData () {
  return  (
    <div>
      <td>Eat</td>
      <td>Learn</td>
      <td>Code</td>
    </div>
  );
}

function Table () {
  return (
    <table>
      <tr>
        <TableData />
      </tr>
    </table>
  );
}

```

生成一下代码：

```jsx
<table>
  <tr>
    <div>
      <td>Eat</td>
      <td>Learn</td>
      <td>Code</td>
    </div>
  </tr>
</table>

```

在 `div` 元素中包装 `<td>` 标签打破了表的父子关系。为了按照预期工作，`<td>` 标签必须单独呈现，而不将它们包装在 `div` 元素中。在这种情况下，最好使用 React Fragment。

```html
<>
	<div></div>
	<div></div>
	
</>

/或者
<React.Fragment>
	<div>1</div>
	<div>2</div>
</React.Fragment>



{
	props.items.map((item)=>
<React.Fragment key={item.id}>
	<div>1</div>
	<div>2</div>
</React.Fragment>)
}

```

使用 React Fragments，我们可以创建更清晰、更容易阅读的代码。它渲染组件更快，使用的内存更少。每个元素都按预期呈现。而 `div` 会扩展 DOM，因为当你的网站上有太多的 HTML 标签时，会出现长嵌套节点。

[原型链](https://so.csdn.net/so/search?q=原型链&spm=1001.2101.3001.7020)像 `HTMLDivElement -> HTMLElement -> Element -> Node -> EventTarget`，而 React Fragments 有较少的方法与原型链`DocumentFragment -> Node -> EventTarget`。

#### 使用Div出现的问题

- `div` 元素展开 HTML DOM，导致浏览器消耗比预期更多的资源。
- 当 DOM 太大时，它会消耗大量内存，导致页面在浏览器中加载缓慢。
- 随着 DOM 变得越来越大、越来越嵌套，调试和跟踪额外节点的来源变得越来越困难。
- 使用 `div` 来呈现组件可能会阻塞 HTML 导致性能问题。

#### Fragment的优势

- React Fragment 的代码可读性更高。

- 因为React Fragment 有一个更小的DOM，它们渲染更快，使用更少的内存。
- React Fragment 允许按预期呈现 React 组件，而不会引起任何父子关系问题。
- Fragment 允许返回多个 JSX 元素，这解决了 react 应用程序中由每个组件只能返回一个元素的约束引起的无效 HTML标记的问题。

#### 简写<></>

这种方法有一些缺点。例如，不能实现 `key prop` ，因为简写符号 `<></>` 在这里不起作用。毕竟，它不能接受一个属性。



### 12.React设计思想

#### 组件化-开闭原则

- 封闭：组件内部状态自身维护，只处理内部渲染逻辑
- 开放：组件通信，不同组件props单项数据流进行交互

#### 数据驱动视图

$$
UI=f(data)
$$

不能直接操作DOM，而是通过修改数据state、props达到数据驱动视图更新；

#### 虚拟DOM

DOM操作非常消耗性能，所以借用虚拟DOM，作为真是DOM的映射；

更新时进行新旧虚拟DOM的比较；

### 13.JSX是什么？和JS有什么区别？

JSX是react的语法糖，它允许在html中写JS，它不能被浏览器直接识别，需要通过webpack、babel之类的编译工具转换为JS执行

#### 区别

1. JS可以被打包工具直接编译，不需要额外转换，jsx需要通过babel编译，它是React.createElement的语法糖，使用jsx等价于React.createElement
2. jsx是js的语法扩展，允许在html中写JS；JS是原生写法，需要通过script标签引入

#### 注意

- **为什么在文件中没有使用react，也要在文件顶部import React from “react”**

只要使用了jsx，就需要引用react，因为jsx本质就是React.createElement

- **为什么React自定义组件首字母要大写**

jsx通过babel转义时，调用了React.createElement函数，它接收三个参数，分别是type元素类型，props元素属性，children子元素。
$$
jsx=> vdom => dom
$$
如果小写，会被当成字符串传递。会被当成一个变量去传递；

```js
//小写
<app>Hello code</app>

React.createElement('app',null,'hello Code')

//大写
<App>Hello code</App>

React.createElement(App,null,'hello Code')

```

### 14.React组件为什么不能返回多个元素？（为什么只有一个根元素？）

#### render函数

函数只能返回一个值

一个组件不能返回多个元素，就像一个函数不能返回多个值一样（除非它们被包装在一个数组中，这是一个单一的值）。

#### vdom根节点只有一个

#### 如何返回多个组件？

- HOC高阶函数
- React.fragment :加入分组而不创建额外节点

#### React元素和组件的区别



### 15.React生命周期

函数组件没有生命周期，class组件有

![img](https://img.jbzj.com/file_images/article/202206/202206280920478.jpg)

#### 初始化

- getDefaultProps()：设置默认的props，也可以使用defaultProps设置组件默认属性

- getInitialState():在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props

- componentWillMount():组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。在渲染前调用,在客户端也在服务端。

- render():react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。

- componentDidMount():组件渲染之后调用，只调用一次。在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。

  

  #### 更新

- componentWillReceiveProps(nextProps):组件初始化时不调用，组件接受新的props时调用。使用componentWillReceiveProps的时候，不要去向上分发，调用父组件的相关setState方法，否则会成为死循环在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。

- shouldCoponentUpdate(nextProps,nextState):react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。

- componentWillUpdate(nextProps,nextState):组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state

- render():组件渲染

- **componentDidUpdate()**:组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。

#### 卸载

- componentWillUnmount():组件将要卸载时调用，一些事件监听和定时器需要在此时清除。

![img](https://img.jbzj.com/file_images/article/202206/202206280920479.png)

### 16.React常用组件

#### Portal

`React Portals`提供了一种将子节点渲染到父组件以外的`DOM`节点的解决方案，即允许将`JSX`作为`children`渲染至`DOM`的不同部分，最常见用例是子组件需要从视觉上脱离父容器，例如对话框、浮动工具栏、提示信息等。

```jsx
<div>
  <SomeComponent />
  {createPortal(children, domNode, key?)}
</div>

```

#### Fragment

包裹子列表，而不产生额外的DOM节点的方法；



#### Context

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a4627c812c754f6a856047649507707c.png)

- 主题
- 当前账户
- 路由
- 还有一些状态会被远程组件用到或修改



#### Transition

React18 并发特性，允许操作被中断



### 17.React-redux工作原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200223145232769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dyZWVuaGFuZF9CTg==,size_16,color_FFFFFF,t_70)

- React Component —— 页面上的组件 (借书的用户)
- Store —— 存储数据的公共区域(相当于图书馆的管理员)
- Action Creators —— 数据传递的过程：改变状态的唯一方法
- Reducers —— 一个纯函数，根据就state和props更新新state

```jsx
import { createStore } from 'redux'; // 引入创建store的方法
import reducer from './reducer';    

const store = createStore(reducer);

export default store;

```



### 19.React-router工作原理

#### 为什么需要前端路由？

- 最开始的网页是多页面的，后来出现了 Ajax 之后，才慢慢有了 SPA，SPA应用指的是应用只有一个主页面，通过动态替换DOM内容并同步修改url地址，来模拟多页应用的效果，切换页面的功能直接由前台脚本来完成，而不是由后端渲染完毕后前端只负责显示。
- AJAX局部刷新，导致浏览器的URL不会发生任何变化而完成了请求，从而破坏了用户浏览体验。同时本次浏览的页面内容在用户下次使用URL访问时将无法重新呈现，使用路由可以很好地解决这个问题。

#### 前端路由

1. 刷新页面：根据URL对资源进行重定向
2. 不同URL映射到不同内容
3. 拦截用户的刷新操作，感知URL变化



#### 实现方式

- hash模式：修改URL中的hash值，触发hashChange事件去渲染不同的内容
- history模式：利用history API实现URL地址改变，触发popsstate事件渲染不同的内容



#### hash模式原理

> 使用window.location.hash属性以及窗口的onhashchange可以监听浏览器地址hash值变化，执行加载相应内容；

##### 什么是hash值？

1. hash指的是地址中#号以及后面的字符，也称为[散列](https://so.csdn.net/so/search?q=散列&spm=1001.2101.3001.7020)值。hash也称作锚点，本身是用来做页面跳转定位的。如`http://localhost/index.html#abc`，这里的#abc就是hash；
2. hash值不会发送到服务器：hash值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；
3. 监听hashchange事件



#### history模式原理

> - history对象存储了当前窗口访问过的所有页面地址，当history对象发生变化时，智慧改变页面的路径，不会刷新页面；
> - 当history对象出现变化时，就会触发popstate事件

##### history对象

HTML5的History API为浏览器的全局history对象增加的拓展方法，一般用来解决akax请求无法通过回退按钮返回到请求前状态的问题；

由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。

浏览器工具栏的“前进”和“后退”按钮，其实就是对 `History` 对象进行操作。

##### 改变路由的方法

在 history 路由中，我们一定会使用window.history中的方法，常见的操作有：

- back()：后退到上一个路由；

- forward()：前进到下一个路由，如果有的话；
- go(number)：进入到任意一个路由，正数为前进，负数为后退；
- pushState(obj, title, url)：前进到指定的 URL，不刷新页面；
- replaceState(obj, title, url)：用 url 替换当前的，不刷新页面；

### 20.数据如何在React组件中流动？

https://bgmbk.blog.csdn.net/article/details/124765323?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124765323-blog-127762468.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124765323-blog-127762468.235%5Ev43%5Epc_blog_bottom_relevance_base6&utm_relevant_index=2

#### 基于props的单向数据流

> 适用于简单得父子组件、子父组件和兄弟组件之间得通信；



#### 利用“发布-订阅”模式驱动数据流

使用发布-订阅模式的优点在于，**监听事件的位置和触发事件的位置是不受限的**，就算相隔十万八千里，只要它们在同一个上下文里，就能够彼此感知。这个特性，太适合用来应对“任意组件通信”这种场景了。

#### Context



#### React-redux



### 21.React-hooks













# Webpack相关

### 1.Webpack配置

https://blog.csdn.net/Kotoba209_/article/details/117155284

### 2.loader执行顺序

https://cloud.tencent.com/developer/article/1548657

> webpack是支持loader的链式调用的，即一个文件可以经多个loader处理。当一个文件使用多个loader处理时，他的处理顺序是倒序，即传入loader数组的从右到左执行。 
>

### 3.html webpack plugin的作用

HtmlWebpackPlugin是webpack 的插件，用到该插件的两个主要作用：

```
    1、为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题

    2、可以生成创建html入口文件，比如单页面可以生成一个html文件入口，配置N个html-webpack-plugin可以生成N个页面入口
```

也就是说，插件的基本作用就是生成html文件，不用手动生成。



### 4.Webpack 和 Vite 的区别？

- 开发模式不同

> *Webpack在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而Vite则采用了基于ES Module的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。*

- 打包效率不同

> *Webpack在打包时，会把所有的模块打包成一个bundle，这会导致初次加载速度较慢；而Vite则利用了浏览器对ES Module的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。*

- 插件生态不同

> *Webpack的插件生态非常丰富，有大量社区和官方插件可以选择，覆盖了前端开发的各个方面；而Vite的插件生态尽管在不断发展，但相比Webpack来说还显得较为稀少。*

- 配置复杂度不同

> *Webpack的配置相对复杂，对新手不够友好；而Vite在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。*

- 热更新机制不同

> *Webpack的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite的热更新则只会针对改动的模块进行更新，提高了更新速度。*

### 5.Tree Shaking

> 当引入一个模块的时候，不引入这个模块的所有代码，只引入需要的代码。
>
> 这需要借助 webpack 的 Tree Shaking 功能实现；
>
> 本质就是消除无用的 JS 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）

在 Production 模式下不用在 webpack.config.js 中配置

```js
mode:"production",
optimization:{
usedExports:true,
}
```

在 Development 模式下配置时：

```js
//HtmlWebpackPlugin
//当我们整个打包过程结束的时候，自动生成一个html文件，
//并把打包生成的自动引入到html这个文件中；

var HtmlWebpackPlugin = require('html-webpack-plugin')
const path = require('path')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const webpack = require('webpack')
module.exports = {
  //打包模式，当为‘production’，打包后的文件会被压缩，
  //当为‘development’时打包后的文件不会被压缩,按照开发环境进行打包
  mode: 'development', //在开发者模式中SourceMap默认已经被配置在项目里了。
  // devtool: 'none', //关闭SourceMap
  //cheap：在生成SourceMap的时候，可以不带列信息，只带行信息,不要包含loader里面的SourceMap的生成，
  //只对业务代码进行SourceMap的生成
  //module:对loader里面的代码也进行一个SourceMap的生成
  //eval：eval是一种执行方式
  devtool: 'cheap-module-eval-source-map', //打开SourceMap
  // devtool: 'cheap-module-source-map', //要线上的代码可以映射
  // 打包的入口文件
  entry: './src/index2.js',
  // entry: {
  //     main: './src/index2.js'
  // },
  devServer: {
    contentBase: './dist', //我们要在哪一个目录下去启动这个服务器
    open: true, //会自动的打开一个浏览器，然后自动访问服务器的地址（localhost:8080）
    hot: true, //指是否支持热更新（hmr）
    hotOnly: true, //即使不支持hmr或者hmr有问题,也不刷新浏览器
    proxy: {
      '/api': {
        //当访问localhost:8080/api的时，它会直接帮你转发到http://localhost:3000
        target: 'http://localhost:3000',
        pathRewrite: { '^/api': '' },
      },
    },
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
      },
      {
        test: /\.(png|jpg|gif)$/,
        use: {
          loader: 'url-loader',
          options: {
            //url-loader会把图片转化成一个base64的字符串，
            //然后直接放到bundle.js里，而不是单独生成一个图片文件，
            //好处：不用再额外的请求图片的地址，省了一次http请求；
            //缺点：如果图片特别大过大，打包生成的js文件就会很大，
            //那么加载js文件的时间就会很长，所以在一开始很长的时间里，页面上什么都显示不出来；
            //所以，url-loader最佳的使用方式：加一个limit
            //如果图片小于limit的值就把图片变为一个base64的字符串放到打包好的js中，
            //若大于limit的值，就以file-loader的生成一个图片放到dist目录下。
            limit: 8192, //好处是可以对小图片的http请求数减少，提升网页加载数度
            name: 'images/[name].[hash].[ext]',
          },
        },
      },
      {
        test: /\.(css|scss|less)$/,

        //"css-loader":会帮我们分析出几个css文件之间的关系，最终把这些css文件合并成一段css;
        //"style-loader":会把‘css-loader’生成的内容挂在到页面的head部分
        //在webpack的配置中，loader是有先后执行顺序的，
        //loader的执行顺序是从下到上，从右到左；
        //“sass-loader”会先对sass代码进行翻译，翻译为css代码后给到css-loader,
        //都处理好了之后再交给‘style-loader’挂在到页面上
        //postcss-loader会自动添加css3的厂商前缀；比如：  transform: translate(100px, 100px)
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              importLoaders: 2,
              modules: true, //使得css模块化，
            },
          },
          'postcss-loader',
          'sass-loader',
        ],
      },
      {
        // 可以打包字体文件
        test: /\.(eot|ttf|svg)$/,
        use: {
          loader: 'file-loader',
        },
      },
    ],
  },

  // 打包的出口文件
  output: {
    // 打包后的文件名
    // filename: 'bundle.js',
    filename: '[name].js', //name就是entry值的key:'main','sub'
    // 打包后的文件目录为'dist'
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/', //表示的是我所有的打包生成的文件之间的引用前面都加一个根路径
  },
  //plugin可以在webpack运行到某个时刻的时候，帮你做一些事情(类似生命周期函数)
  plugins: [
    // CleanWebpackPlugin可以在每次打包的时候帮我们对dist目录做一个清空
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      //HtmlWebpackPlugin帮我们自动的生成一个dist目录下的html文件
      template: './src/index.html',
    }),
    //HotModuleReplacementPlugin帮我们实现HMR
    new webpack.HotModuleReplacementPlugin(),
  ],
  //在开发模式下配置 tree shakeing
  optimization: {
    usedExports: true,
  },
}
```

package.json

```json
{
  "name": "webpack-demo",
  //@babel/polyfill和css文件不使用tree shaking
  "sideEffects": ["@babel/polyfill", "*.css"],
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "bundle": "webpack",
    "watch": "webpack --watch",
    "start": "webpack-dev-server",
    "server": "node server.js"
  },
  "author": "susie",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.5.4",
    "@babel/plugin-transform-runtime": "^7.5.0",
    "@babel/preset-env": "^7.5.4",
    "@babel/preset-react": "^7.0.0",
    "autoprefixer": "^9.6.1",
    "babel-loader": "^8.0.6",
    "clean-webpack-plugin": "^3.0.0",
    "css-loader": "^3.0.0",
    "file-loader": "^4.0.0",
    "html-webpack-plugin": "^3.2.0",
    "node-sass": "^4.12.0",
    "postcss-loader": "^3.0.0",
    "sass-loader": "^7.1.0",
    "style-loader": "^0.23.1",
    "url-loader": "^2.0.1",
    "webpack": "^4.35.3",
    "webpack-cli": "^3.3.5",
    "webpack-dev-server": "^3.7.2"
  },
  "dependencies": {
    "@babel/polyfill": "^7.4.4",
    "@babel/runtime": "^7.5.4",
    "@babel/runtime-corejs2": "^7.5.4",
    "react": "^16.8.6",
    "react-dom": "^16.8.6"
  }
}
```

为什么某些引入模块不希望进行 Tree Shaking？

> 因为 css 模块如果使用 tree shaking，但是没有导出任何模块，就有可能被打包的时候 shake 掉。
>
> Tree shaking 只支持 ES Module

```json
{
  "sideEffects": ["*.css"]
}
```

> 在前端的性能优化中，es6 推出了tree shaking机制，tree shaking就是当我们在项目中引入其他模块时，他会自动将我们用不到的代码，或者永远不会执行的代码摇掉，在Uglify阶段查出，不打包到bundle中。
>
> 只支持ES6 Module代码。在production 环境默认开启

#### 只支持ES Module的引入方式，不支持CommonJS

- ESM: export + import
- Common JS: module.exports + require

提示：如果想要做到tree shaking，在引入模块时就应该避免将全部引入，应该引入局部才可以触发tree shaking机制

```js
// Import everything (not tree-shaking)
import lodash from 'lodash';

// Import named export (can be tree-shaking)
import { debounce } from 'lodash';

// Import the item directly (can be tree-shaking)
import debounce from 'lodash/lib/debounce';
```



1. 项目描述具体说说
2. 先讲架构，更希望听到差距；维度：网状结构，项目体量，服务端了解；手动细节；css比较不熟悉，多学习；







### 6.webpack性能优化

#### Tree shaking

对代码中无用的代码进行去除。（限于function，class不行）
无用的代码有三种：

1. 无法到达的代码
2. 代码的执行结果用不到
3. 代码只会影响死变量（只写不读）

webpack处于生产模式的时候就会自动开启。

#### 优化loader编译范围

通过设置loader的对于哪些文件进行编译或者不对哪些文件进行编译（include，exclude）。
如：babel-loader处理js的ES6语法转换时比较耗时，如果减少文件的编译也会因此减少时间。

#### 压缩JS

webpack内置UglifyJS插件、ParallelUglifyPlugin插件

```js
const UgilyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');

module.exports = {
    plugins: [
        new UglifyJsPlugin({
            compress: {
                warnings: false, // 删除无用代码时不输出警告
                drop_console: true, // 删除所有console语句
                collapse_vars: true, // 内嵌已定义但只使用一次的变量
                reduce_vars: true // 提取使用多次但没定义的静态值到变量
            },
            output: {
                beautify: false, // 最紧凑的输出
                comments: false // 删除所有注释
            }
        })
    ]
}

```

#### 压缩css

css-loader?minimize、PurifyCSSPlugin插件

`css-loader`内置了`cssnano`，只需要使用`css-loader?minimize`就可以开启`cssnano`压缩。
另外一种压缩`CSS`的方式是使用`PurifyCSSPlugin`，需要配合`extract-text-webpack-plugin`使用，它主要的作用是可以去除没有用到的`CSS`代码。

#### 优化网络加速请求

`CDN`通过将资源部署到世界各地，使得用户可以就近访问资源，加快访问速度。要接入`CDN`，需要把网页的静态资源上传到`CDN`服务上，在访问这些资源时，使用`CDN`服务提供的`URL`。

#### 依赖公共代码提取



### 7.SourceMap

https://blog.csdn.net/m0_67403076/article/details/124346503

https://zhuanlan.zhihu.com/p/475964893

Sourcemap（源代码映射）用于将生产环境中的压缩代码映射回原始的源代码。在前端开发过程中，JavaScript、CSS 和其他文件通常会被压缩和混淆，以减小文件大小和提高网站加载速度。然而，这会让调试和错误定位变得困难，因为生产环境中的代码难以阅读和理解。

简单来说，Sourcemap 就是一个信息文件，它里面存储着代码转换前后的对应位置信息，也就是转换压缩后的代码所对应的转换前的源代码位置，是源代码和生产代码的映射， Sourcemap 解决了在打包过程中，代码经过压缩，去空格以及 babel 编译转化后，由于代码之间差异性过大，debug 困难的问题

大家的项目在开发完进行build后，在打包文件夹里除了有js，css，图片等资源，一定还见过 .js.map文件，这种就是sourcemap文件.

### 8.ES6语法、vue语法是怎么转换成JS文件的

https://blog.csdn.net/laplacepoisson/article/details/120984743

#### Vue-loader

##### vue-loader 是如何工作的?

vue-loader 的工作原理是

它会将 .vue 文件中的每个部分（template、script、style）提取出来，然后分别交给相应的 webpack loader 处理，例如 vue-template-loader、babel-loader、style-loader 等。

这样，每个部分都可以使用不同的语言或工具，例如在 template 中使用 Pug，在 script 中使用 TypeScript，在 style 中使用 Sass 等。

最后，vue-loader 会将这些处理后的部分重新组合成一个可以在浏览器中运行的 js 文件，其中包含了 Vue 组件的定义和渲染函数。

#### Babel-loader

##### 解析

当 Babel 接收到源代码时，将会调用一个叫做解析器的工具，用于将源代码转换为抽象语法树（AST）。在这个过程中，解析器会识别代码中的语法结构，并将其转换为对应的节点类型。
例如，当解析器遇到一个变量声明语句时，它将会创建一个 “VariableDeclaration” 节点，并将该节点的信息存储在 AST 中。AST 是一个以节点为基础组成的树形结构，每个节点都有相应的类型、属性和子节点等信息。

##### 转换

一旦 AST 被创建，Babel 将遍历整个树形结构，对每个节点进行转换。这些转换可以是插件、预设或手动创建的。转换器会检查 AST 中的每个节点，然后对其进行相应的修改或替换，以将新语法转换为旧语法。
例如，如果 Babel 遇到一个包含箭头函数的节点，而你已经启用了转换插件，该插件将会将箭头函数转换为其等效的体函数。代码转换后，Babel 将会生成一个新的 AST。

##### 生产

最后，Babel 将基于转换后的 AST 生成代码文本。在这个步骤中，Babel 将遍历转换后的 AST，并创建对应的代码字符串，并将这些字符串组合成一个完整的 JavaScript 文件。如果启用了代码压缩，Babel 还可以将生成的代码进行压缩。

总结来说，Babel 的原理就是将 JavaScript 源代码转换为抽象语法树（AST），然后对 AST 进行转换，生成与源代码功能相同但向后兼容的代码。Babel 提供了一个强大的生态系统，使得开发者可以轻松扩展并自定义转换器，实现自己的功能需求。

https://blog.csdn.net/formylovetm/article/details/126126060



### 9.webpack有那些用处？

> Webpack是一个**前端模块打包工具**。它可以将多个模块按照依赖关系进行静态分析，并生成一个或多个打包后的文件。

#### 模块打包

将项目中的所有模块（JavaScript、CSS、图片等）当作一个整体，通过依赖关系将它们打包成一个或多个静态资源文件。

#### 依赖管理

Webpack可以分析模块之间的依赖关系，根据配置的入口文件找出所有依赖的模块，并将其整合到打包结果中。

#### 文件转换

`Webpack`本身只能处理`JavaScript`模块，但通过`加载器（Loader）`的使用，可以将其他类型的文件（如CSS、LESS、图片等）转换为有效的模块，使其能够被打包到最终的结果中。

#### 代码拆分

Webpack支持将代码拆分成多个模块，按需加载，实现按需加载和提升应用性能。

#### 插件系统

Webpack提供了丰富的插件系统，可以通过插件实现各种功能的扩展，例如压缩代码、自动生成HTML文件等。



### 10.Webpack的核心概念是什么？请解释entry、output、loader和plugin

> Webpack的核心概念包括entry（入口）、output（输出）、loader（加载器）和plugin（插件）。

1. **Entry（入口）**：Webpack将从指定的入口文件开始分析和构建依赖关系树。**入口可以是单个文件或多个文件**，Webpack会根据入口配置找出所有的依赖模块。
2. **Output（输出）**：指定Webpack打包后的文件输出的路径和文件名。可以通过配置`output`选项来指定输出文件的路径、名称和格式等。
3. **Loader（加载器）**：`Webpack`本身只能处理`JavaScript`模块，但通过`Loader`的使用，可以处理其他类型的文件（如CSS、LESS、图片等）。Loader的作用是在模块加载时对其进行转换和处理。
4. **Plugin（插件）**：插件用于扩展Webpack的功能。它可以在打包的不同阶段执行特定的任务。例如，可以使用插件来压缩代码、拆分代码、生成HTML文件等。插件通过在Webpack配置中引入并实例化，然后将其添加到plugins数组中。

综上所述，Webpack的核心概念包括`entry、output、load`

### 11. 什么是Webpack的loader？请提供一些常用的loader，并解释它们的作用。

**Webpack的loader是用于处理模块文件的转换工具**。

> 它们可以将不同类型的文件（如CSS、LESS、图片等）转换为可以被Webpack处理的有效模块，以便将其包含在最终的打包结果中。

- babel-loader:将ES6+代码转换为ES5
- style-loader和css-loader：用于处理CSS文件。css-loader主要负责处理样式文件中的`import`和`url`语句，而style-loader将转换后的CSS模块直接注入到HTML页面中。
- file-loader和url-loader:用于处理图片和其他资源文件。file-loader会为每一个文件生成一个对应的文件，而url-loader将小于设定大小的文件转换为base64编码的URL，减少HTTP请求。
- sass-loader和less-loader:用于处理Sass和Less预处理器。它们将Sass和Less代码转换为普通的CSS代码。
- postcss-loader:用于为CSS代码添加浏览器兼容性前缀，以确保在不同浏览器上的一致性。

### 12.什么是Webpack的plugin？请提供一些常用的plugin，并解释它们的作用。

在Webpack中，插件（plugin）是**用来扩展和定制构建过程的工具**，可以用于处理和优化资源、自动化任务、注入变量等。

> 插件一般是一个具有apply方法的JavaScript对象，通过在Webpack的配置中配置插件，可以在构建过程中执行额外的操作。

- `HtmlWebpackPlugin`:用于自动生成HTML文件，并将打包生成的所有资源（如CSS、JS文件）自动注入到生成的HTML文件中。
- `MiniCssExtractPlugin`:用于将CSS代码从打包生成的JS文件中提取出来，创建一个单独的CSS文件，可以实现CSS的异步加载和浏览器缓存优化。
- `TerserWebpackPlugin`:用于对JS代码进行压缩和混淆，减小文件体积，提高加载速度。
- `OptimizeCSSAssetsWebpackPlugin`:用于对提取出的CSS进行压缩和优化。
- `CleanWebpackPlugin`:用于在构建之前清空输出目录，避免旧文件的干扰。
- `CopyWebpackPlugin`:用于将静态文件从源目录复制到输出目录，例如将图片、字体等文件复制到打包后的文件夹中。
- `HotModuleReplacementPlugin`:用于启用模块热更新，实现在开发过程中无需刷新页面即可看到最新变更的效果。
- `ProvidePlugin`:用于自动加载模块，当代码中使用到某个模块时，会自动将模块引入，无需手动import。
- `CompressionWebpackPlugin`:用于对打包生成的文件进行gzip压缩，减小文件体积，提升网络传输速度。

### 13.在Webpack中，什么是代码分离（code splitting）和懒加载（lazy loading）？它们有什么区别？

**代码分离（code splitting）和懒加载（lazy loading）是Webpack中用于优化资源加载的两种技术。**

> 代码分离是将打包生成的代码文件拆分成多个较小的文件，而不是将所有代码打包到一个文件中。

- 提高初始加载速度，并减小每个页面加载所需的数据量。

**懒加载是指在需要时才加载某个模块，而不是在初始加载时就将所有代码一次性加载完毕**。通过懒加载，可以将页面分成多个模块，并根据需要动态地加载模块。这可以减少初始加载时间，只加载目前需要的模块，在用户与页面进行交互时再根据需要进行加载，提高了页面的性能和加载速度。

### 14.如何配置Webpack的开发环境和生产环境的不同配置？

##### 开发环境

```js
const webpack = require('webpack');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  devServer: {
    port: 3000,
    hot: true,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
    }),
  ],
};
```

#### 生产环境

```js
const webpack = require('webpack');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const TerserWebpackPlugin = require('terser-webpack-plugin');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  optimization: {
    minimizer: [new TerserWebpackPlugin()],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
      minify: {
        collapseWhitespace: true,
        removeComments: true,
        removeRedundantAttributes: true,
        useShortDoctype: true,
      },
    }),
    new MiniCssExtractPlugin({
      filename: 'styles.css',
    }),
  ],
};
```

### 15.Webpack中的热重载（Hot Module Replacement）是什么？如何配置实现热更新？

**热重载（Hot Module Replacement，HMR）是Webpack提供的一项功能，它允许在开发过程中，无需刷新整个页面，即可实时更新修改的模块。**

> 通过热重载，可以提高开发效率，快速查看代码变化的结果，并保持应用的状态（如表单数据）。

#### 开启方式

-  **在Webpack配置文件中启用热模块替换。可通过配置`devServer.hot`选项为`true`来启用HMR**

```js
module.exports = {
  // ...
  devServer: {
    hot: true,
  },
};
```

- **在入口文件中添加对HMR的支持。在入口文件中，需要添加HMR的逻辑以监听模块的变化，并告诉Webpack如何处理更新。**

```js
// index.js

if (module.hot) {
  module.hot.accept();
}
```

- 配置webpack插件

```js
// webpack.config.js
const webpack = require('webpack');

module.exports = {
  // ...
  plugins: [
    new webpack.HotModuleReplacementPlugin(),
    // ...其他插件
  ],
};
```

请注意，**热重载只适用于开发环境，并不能直接用于生产环境**。在生产环境中，需要使用Webpack生成的静态文件进行部署。

### 16.解释一下Webpack的文件指纹（file fingerprint）和缓存（caching）机制。

**Webpack的文件指纹（file fingerprint）机制是指在打包生成静态资源时，为每个文件生成唯一的标识码**。这个标识码通常是通过对文件内容进行 `hash` 计算得到的。一旦文件内容发生改变，其文件指纹也会发生改变，从而防止浏览器在缓存过期前使用旧的文件。

- `Hash`：每次打包时，Webpack 会给每个输出的文件生成一个 hash 值。只要文件内容发生变化，其 hash 值也会发生变化。
- `Chunkhash`：根据不同的入口文件进行依赖关系解析后，Webpack 会为每个 chunk 生成一个 hash 值。只有当前 chunk 内容发生变化时，其 hash 值才会发生变化。
- `Contenthash`：采用文件内容的 hash 值作为文件指纹，只有文件内容发生变化时，其 hash 值才会发生变化。适用于样式文件、图片文件等。

**缓存机制是指浏览器在加载页面时，会将静态资源（如 JS、CSS、图片等）保存在本地，以便下次加载相同资源时可以直接使用缓存副本，从而提高网页加载速度。缓存机制分为强缓存和协商缓存两种方式。**

### 17.如何在Webpack中处理不同类型的资源文件，例如图片、CSS和字体文件？

#### 图片文件

```shell
npm install file-loader 
npm install url-loader
```

```js
module: {
  rules: [
    {
      test: /\.(png|jpg|gif)$/,
      use: [
        {
          loader: 'file-loader',
          options: {
            name: '[name].[hash].[ext]', // 文件指纹配置
            outputPath: 'images/', // 输出目录
          }
        }
      ]
    }
  ]
}
```

#### CSS文件

```shell
npm install style-loader css-loader
```

```js
module: {
  rules: [
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader']
    }
  ]
}
```

### 16.Webpack的Tree Shaking是什么？如何配置实现代码的无用代码剔除？

**Webpack的Tree Shaking是一个用于删除代码中未被引用的未使用代码的优化技术。**

> 它可以显著减小打包后的文件体积，提高网页加载速度。

#### 使用步骤

1. 确保你的代码是使用ES6模块语法编写的，而不是CommonJS（require）语法。因为Tree Shaking只对ES6模块有效。
2. 在Webpack配置文件中，通过设置`mode`为`production`，启用Webpack的生产模式，此时Tree Shaking功能会默认开启。
3. 确保你的`package.json`文件中的`sideEffects`字段被正确配置。`sideEffects`字段告诉Webpack哪些文件是没有副作用的，可以进行Tree Shaking。如果你的应用是纯粹的JavaScript应用，可以将`sideEffects`设置为`"sideEffects": false`。如果你的应用使用了一些有副作用的模块（例如CSS文件），你需要将这些模块添加到`sideEffects`字段中。这样Webpack就不会将这些有副作用的模块进行Tree Shaking。

需要注意的是，**Tree Shaking只适用于ES6模块语法，并且只能剔除未引用的代码，不能剔除被动态引用的代码**（例如通过字符串拼接生成模块路径）。另外，一些特定的代码结构可能会导致Tree Shaking失效，例如使用`eval`、`with`等特殊语法。





# 计算机网络相关

### 1.CDN的理解

https://baijiahao.baidu.com/s?id=1781784937514739682&wfr=spider&for=pc



### 2.跨域问题：什么是跨域？如何解决？

> 跨域问题指的是不同站点之间，使用 ajax 无法相互调用的问题。**跨域问题本质是浏览器的一种保护机制，它的初衷是为了保证用户的安全，防止恶意网站窃取数据。** 但这个保护机制也带来了新的问题，它的问题是给不同站点之间的正常调用，也带来的阻碍
>
> 跨域请求：
>
> 1. 协议不同 http/https
> 2. 域名不同
> 3. 端口不通

#### 解决方案

- Jsonp：利用script标签可以跨域的原理实现

> 1. 需要服务的支持
> 2. 只能发起Get请求
>
> js跨域请求数据是不可以的，但是js跨域请求js脚本是可以的。可以把数据封装成一个js语句，做一个方法的调用。跨域请求js脚本可以得到此脚本。得到js脚本之后会立即执行。可以把数据做为参数传递到方法中。就可以获得数据。从而解决跨域问题。

- nginx反向代理

> 1. 利用nginx把跨域反向代理为不跨域，支持各种请求方式
> 2. 缺点：需要在nginx进行额外配置，语义不清晰

```python
前端server的域名为：fe.server.com
后端服务的域名为：dev.server.com
现在我在fe.server.com对dev.server.com发起请求一定会出现跨域。
现在我们只需要启动一个nginx服务器，将server_name设置为fe.server.com,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回dev.server.com。如下面的配置：
server {
        listen       80;
        server_name  fe.server.com;
        location / {
                proxy_pass dev.server.com;
        }
}
这样就可以完美绕过浏览器的同源策略了。
fe.server.com访问nginx的fe.server.com属于同源访问，而nginx对服务端转发的请求不会触发浏览器的同源策略。

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/810addecfd8d40b29c35ab613425619b.png)

- CORS

> 规范化的跨域请求解决方案，安全可靠；
>
> 优势：
>
> 1. 在服务端进行控制是否允许跨域，可自定义规则
> 2. 支持各种请求方式
>
> 缺点：
>
> 1. 会产生额外的请求（预检）

> CORS为W3C标准，全称为“跨域资源共享”
>
> **CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。**
>
> 浏览器端：不用考虑
> 	目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。
> 服务端：进行相关设置
> 	CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。

原理： 跨域请求在正式通信之前，增加一次HTTP查询请求，称为预检请求；

```
如果服务器允许跨域，需要在返回的响应头中携带下面信息：

Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名）
Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true
Access-Control-Allow-Methods：允许访问的方式
Access-Control-Allow-Headers：允许携带的头
Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了

```

- Web Socket

> 它是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。

#### vue如何解决？

- 代理服务器：开发环境中，可以配置一个代理服务器转发API请求；

```js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
}
```



### 3.节流与防抖





### 4.TCP和UDP区别

> 传输控制协议（TCP）是 Internet 一个重要的传输层协议.TCP 提供面向连接、可靠、有序、字节流传输服务。应用程序在使用 TCP 之前，必须先建立 TCP 连接；TCP 通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。

https://zhuanlan.zhihu.com/p/471415273



### 5.http和https

> HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
>
> HTTPS：是以安全为目标的HTTP通道，简单讲就是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

#### 区别

1、HTTPS协议需要到CA申请证书，一般免费的证书比较少，因而需要一定费用。

2、HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议。

3、HTTP和HTTPS使用的是完全不同的链接方式，用的端口也不一样，前者是80端口，后者是443端口。

4、HTTP的链接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。



### 6. URL格式

```http
协议：//主机：端口/路径名称？搜索条件#哈希值
```



### 7.Chrome有那些进程？

- GPU
- 渲染
- 插件



### 8.输入 URL 到渲染的整个流程？

https://blog.csdn.net/weixin_45811256/article/details/130316442

> 1. 浏览器接收 url 并开启一个新进程（这一部分可以展开浏览器的进程与线程的关系）
> 2. 浏览器解析输入的 URL，提取出其中的协议、域名和路径等信息。（这部分涉及 URL 组成部分）
> 3. 浏览器向 DNS 服务器发送请求，DNS 服务器通过 多层查询 将该 域名 解析为对应的 IP 地址 ，然后将请求发送到该 IP 地址上，与 服务器 建立连接和交换数据。（这部分涉及 DNS 查询）
> 4. 浏览器与服务器建立 TCP 连接。（这部分涉及 TCP 三次握手/四次挥手/5 层网络协议）
> 5. 浏览器向服务器发送 HTTP 请求，包含请求头和请求体。（4,5,6,7 包含 http 头部、响应码、报文结构、cookie 等知识）
> 6. 服务器接收并处理请求，并返回响应数据，包含状态码、响应头和响应体。
> 7. 浏览器接收到响应数据，解析响应头和响应体，并根据状态码判断是否成功。
> 8. 如果响应成功，浏览器接收到 http 数据包后的解析流程（这部分涉及到 html - 词法分析，解析成 DOM 树，解析 CSS 生成 CSSOM 树（样式树），合并生成 render 渲染树（样式计算）。然后 layout 布局，分层，调用 GPU 绘制等，再显示在屏幕上。这个过程会发生回流和重绘）。
> 9. 连接结束 -> 断开 TCP 连接 四次挥手

### 9.浏览器缓存

> 缓存的好处：
>
> 1. 使网页加载和呈现速度更快
> 2. 减少不必要的数据传输，节省流量和宽带，减少服务器负担

> 缓存位置分类：
>
> 1. 内存缓存
> 2. 硬盘缓存
> 3. service worker

> 缓存策略分类：
>
> 1. 强缓存
> 2. 协商缓存

![img](https://upload-images.jianshu.io/upload_images/15528678-04ce67084f2e9d1e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1163/format/webp)

![在这里插入图片描述](https://img-blog.csdnimg.cn/74230e82554a4388afcd19571806b3ef.png)

#### 缓存过程

- 第一次请求数据时，浏览器缓存没有对应的缓存数据，因此需要请求服务器，浏览器把响应的数据存储在缓存数据库中；
- 如果浏览器中存在缓存数据，则可以根据是否需要向服务器发送请求，将缓存类型分为：强制缓存和协商缓存；

##### 强制缓存

> 如果命中强缓存，则不向服务器请求，直接从本地获取资源，返回 200 状态码，提示`from disk cache`或者`from memory cache`

> 强制缓存的`response header`中会有两个字段：`Expires/Cache-control`
>
> `Expires`为服务器返回的到期时间，下一次请求之前，请求时间小于过期时间则直接使用缓存数据；适用于 http1.0，现在基本是 1.1；1.1 版本使用`cache-control`替代
>
> `cache-control` 常见的值有`private`,`public`,`no-cache`,`max-age`
>
> 因为 Expires 过期时间采用绝对时间，容易造成差错；cache-control 采用相对时间，不会出错

##### 协商缓存

> 用户请求资源时，浏览器向服务器发送请求，协商对比服务端和本地资源，验证本地资源是否失效；

> 一般使用`if-modifired-since`,`Last-Modifird`,`if-none-match/Etag`由服务器决定浏览器缓存是否可用；
>
> Last-Modified：服务器响应请求时，告诉浏览器资源最后的修改时间。
>
> If-Modified-Since：浏览器再次请求资源时，浏览器通知服务器，上次请求时，返回的资源最后修改时间。
>
> 若最后修改时间小于等于 If-Modified-Since，则 response header 返回 304，告知浏览器继续使用所保存的 cache。若大于 If-Modified-Since，则说明资源被改动过，返回状态码 200；
>
> Etag：服务器响应请求时，告诉浏览器当前资源在浏览器的唯一标识（生成规则由服务器确定）
>
> If-None-Match：再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。服务器收到请求后发现有 If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码 200；相同，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用所保存的 cache。

1.在精确度上，Etag 优于 Last-Modified。Last-Modified 精确到 s，如果 1s 内，资源多次改变，Etag 是可以判断出来并返回最新的资源。

2.在性能上，Last-Modified 优于 Etag，因为 Last-Modified 只需要记录时间，而 Etag 需要服务器重新生成 hash 值，所以性能上略差。

3.在优先级上，Etag 优于 Last-Modified，Etag 和 Last-Modified 可同时存在。

#### 浏览器缓存废弃更新策略

服务器下发资源以后，就对其失去了控制权。

- HTML：缓存有效时间 0s，页面加载时强制每次向服务器确认数据
- CSS：改动频率较低，允许使用本地缓存，且存在强制缓存时间；失效进行协商缓存
- JS：运行本地缓存，且存在强制缓存时间，各个 JS 文件不同；失效进行协商缓存
- Image：图片更改率低，允许使用本地缓存，且存在强制缓存时间；失效进行协商缓存
- Gif：gif 主要存在于 banner 轮播，因此确保时效性，使用 no-cache，不允许缓存，强制每次向源服务器确认数据。

> 对于基本不常变化的资源，采用强制缓存的处理，设置 Cache-Control: max-age=xxx 一个比较大的数，让其从客户端缓存中获取.
>
> 对于变动更改频繁的文件，采取协议缓存的处理设置 Cache-Control: no-cache,通过 Etag 的值来判断当前缓存是否可用.

### 10.现已知 https 对前端性能影响很大, 如何提升其性能以减少 tls 层耗时？

HTTPS=HTTP over SSL (Http +SSL/TLS)

产生性能损耗的两个环节：

- TLS协议握手过程；
- 握手后的对称加密报文传输；

如何提升：

- 升级TLS：TLS1.3握手只需要1 RTT
- 硬件优化
- 协议优化：RSA的密钥交换算法不仅慢，安全性也不高，尽量选择ECDHE密钥交换；
- 对称加密算法优化：选用ARS-128-GCM密钥更短

### 11.HTTP 1.0 2.0 3.0

![img](https://img-blog.csdnimg.cn/cefbded175644c95b861c66bb0eb6d18.png)

#### HTTP 0.9

> 只有 GET 命令，TCP 建立链接后请求资源，协议规定只能返回 HTML 格式的字符串

#### HTTP 1.0

> - 可以发送任何格式的内容，包括图像，视频，二进制；
> - 引入 POST，HEAD 命令，丰富了 C/S 交互的手段；
> - HTTP 请求和响应的格式变了，除了数据部分，每次通信都必须包括头信息，用来描述元数据

> 缺点：每一个 TCP 请求只能发送一次请求，发送完数据就断开连接，需要获得其他数据必须新建 TCP 链接；

![img](https://img-blog.csdnimg.cn/f0cca5fab08e43d5a68a6876fd0cd413.png)

```http
GET /index.html

User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)

Accept: */*

响应：

HTTP/1.0 200 OK

Content-Type: text/plain

Content-Length: 137582

Expires: Thu, 05 Dec 1997 16:00:00 GMT

Last-Modified: Wed, 5 August 1996 15:55:28 GMT

Server: Apache 0.84

<html>   <body>Hello World</body> </html>

```

#### HTTP 1.1

> - 持久连接
> - 管道机制：同一个 TCP 连接里，客户端可以发送多个请求，进一步改进了 HTTP 协议的效率。
>
> 举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。

> 缺点：服务器处理响应是一个个处理的，容易发生队头堵塞的情况；
>
> 解决方案：
>
> 1. 减少请求数：合并 JS，CSS，雪碧图
> 2. 同时多开持久连接，资源放在多个域名下面；

#### HTTP 2.0

> 主要解决 1.1 版本对头阻塞的问题；
>
> - 二级制协议：http2 采用二进制传输数据，而非 1 版本的文本格式；请求响应数据被分割为二进制编码的帧；
>
>   将数据包切开成一片一片的，然后每一片可以乱序传输；浏览器接受到所有的片后，按照片所带的序号，整合为一个完整的数据包
>
>   ![img](https://img-blog.csdnimg.cn/40fd0ca5568d4a3a9e6eaf02342c036b.png)
>
> - 多路复用：所有的请求，都复用一个 tcp 连接
>
> - 头压缩：在同一个 HTTP 页面中，许多资源的 Header 是高度相似的，但是在 HTTP2 之前都是不会对其进行压缩的，这使得在多次传输中白白浪费了资源来进行重复无谓的操作
>
> - 服务器推送：
>
> - HTTP2 还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）

> 缺点：
>
> 1. 虽然解决了应用层的对头阻塞，但是没有解决传输层的对头组设；
> 2. 因为是基于 tcp，所以建立连接会经过三次握手四次挥手

#### HTTP 3.0

![img](https://img-blog.csdnimg.cn/0d1496da681c4828806f5e56a6e41ade.png)

> 基于 UDP 协议的“QUIC”协议。
>
> 通常来说 QUIC 是一种通用传输协议，与 TCP 非常相似。为什么要打造一套新的协议呢？这是因为现有的 TCP 协议扩展起来非常困难，因为已经有太多太多的设备使用了各种不同的 TCP 协议的版本，如果想直接在现有的 TCP 协议上进行扩展非常困难，因为需要给这么多台设备进行升级几乎是不可能完成的任务。
>
> 所以 QUIC 在选择在 UDP 协议之上进行构建。QUIC 使用 UDP，主要是因为希望能让 HTTP/3 更容易部署，因为它已经被互联网上的所有设备所知并已实现.
>
> QUIC 实际上就是在 UDP 的基础上重写了 TCP 功能，但是又比 TCP 更加智能；
>
> - 无需三次握手，四次挥手
> - 队头阻塞：UDP 是无序的，无需等待；

> 1. 使用 UDP 如何保证可靠性？
>
>    http 数据包中加入 packet header，实现了可靠连接。通过 packet number 来实现报文重传；
>
> 2. 没有了三次握手，四次挥手？
>
>    使用 1RTT 或者 0RTT，使用 DH 密钥交换算法；

![img](https://img-blog.csdnimg.cn/0a5f5340d6194e78b38bf09f11c73d27.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamF2YeiQjOaWsOWHjA==,size_20,color_FFFFFF,t_70,g_se,x_16)

https://blog.csdn.net/weixin_47667221/article/details/127861656?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-127861656-blog-123592573.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-127861656-blog-123592573.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=5

### 12.跨域问题

> 前后端分离的开发模式逐渐成为主流，这种模式下，前端和后端分别独立开发，前后端通信多为使用 Ajax 发送 HTTP 请求，然而，由于浏览器的安全策略限制，可能会出现跨域问题，导致请求失败；
>
> 跨域问题是指在 web 程序中，由于同源策略的限制导致浏览器无法发送跨域请求，也无法获取跨域响应的问题。同源策略是一种安全策略（会导致 CSRF），要求 web 应用程序只能访问与当前页面具有相同协议、主机名、端口号的资源；
>
> 如果需要访问不同源的资源，就会出现跨域问题；

#### 解决方案

- 浏览器插件
- web 服务器软件

Nginx 代理

```shell
location / {
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';

    if ($request_method = 'OPTIONS') {
        return 204;
    }
}

```

- 后端框架操作：通过 CORS 解决跨域，在响应头中添加

```
Access-Control-Allow-Origin:<origin>
```

前端即可通过 axios 跨域访问该 API

- 前端框架操作：proxy

```js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
      },
    },
  },
}
```

这样前端请求 '/api' 会被代理到 '[http://localhost:8080](http://localhost:8080/)',实现跨域。

###  13.session,webStorage说一下有啥区别

> Session和Cookie是用于跟踪用户会话的技术，但它们在存储位置、使用方式、安全性等方面存在显著差异。
>
> Cookie存储在浏览器中，可以设置过期时间，而Session存储在服务器端，关闭浏览器后自动失效。
>
> Session相对于Cookie更安全，但仍然存在安全风险。
>
> Session可以存储任意类型的数据，而Cookie有大小限制。
>
> 选择Session或Cookie应考虑应用场景和安全性要求。

![img](https://pics3.baidu.com/feed/9c16fdfaaf51f3de74cbb7d5ab45a7123b2979ba.jpeg@f_auto?token=6dad926753290dc8fae849e4f2200467)

### 14.get请求与post请求的区别，传参格式和传参位置有什么区别？

![在这里插入图片描述](https://img-blog.csdnimg.cn/8a360bba62f2495e813aebc204551663.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASmVycnlMZWV1cA==,size_19,color_FFFFFF,t_70,g_se,x_16)

#### 传参

- 一般情况下，params在get请求中使用，data、json在post请求中使用；

### 15.http和https介绍一下

#### HTTP

HTTP 超文本传输下而已，是应用层协议，用于客户端和服务器之间传输超文本数据，如文字，图片，音视频等。

基于请求响应模型C/S

HTTP默认使用TCP/IP作为传输协议，是一种可靠的、面向连接的协议，可以保证数据有序、完整的到达目的地，使用80端口进行通信。端口用来区分不同的服务和应用。

HTTP协议的一个特点是它是明文传输数据的协议，也就是说，HTTP请求和响应中的数据都是没有加密的，任何人都可以在传输过程中窥探或篡改数据。这样就会导致一些安全性问题，比如账号密码、银行卡信息等敏感数据被泄露或盗用。

#### HTTPS

HTTPS协议（Hypertext Transfer Protocol Secure） 在HTTP的基础上增加了SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对数据进行加密和身份验证，保证数据的安全性和完整性。

SSL/TLS协议是一种加密通信协议，它可以在客户端和服务器之间建立一个安全连接，并通过公钥加密和私钥解密的方式对数据进行加密和解密。公钥和私钥是一对匹配的密钥，公钥可以公开给任何人使用，私钥则只能由持有者保管。使用公钥加密的数据只能用私钥解密，反之亦然。

SSL/TLS协议还使用数字证书对服务器的身份进行验证，防止中间人攻击。数字证书是由第三方机构颁发的一种电子文件，它包含了服务器的公钥和相关信息，并经过数字签名进行认证。客户端在访问服务器时，会先获取并验证服务器的数字证书，确认服务器的真实身份后再进行通信。

HTTPS协议默认使用443端口进行通信，与HTTP协议不同。网站的URL通常以"https://"开头表示使用HTTPS协议。

#### 使用场景

- HTTP适用于不敏感数据传输，HTTPS适用于需要保护用户敏感数据的场景。
- 由于HTTPS使用了非对称加密，所以存在一些性能上的损耗。

![在这里插入图片描述](https://img-blog.csdnimg.cn/53c4a3bd449341ca9cf842131e07c162.png#pic_center)



### 16.get和post方法有什么区别？

1、传送方式：get通过地址栏传输，post通过报文传输。

2、传送长度：get参数有长度限制（受限于url长度），而post无限制

3、GET和POST还有一个重大区别，简单的说：

GET产生一个TCP数据包；POST产生两个TCP数据包

4、缓存：get请求可以缓存，post请求不可以缓存。

5、后退：get请求页面后退时不产生影响。post请求页面后退时，会重新提交请求；

建议：

1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；

2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；

案例：一般情况下，登录的时候都是用的POST传输，涉及到密码传输，而页面查询的时候，如文章id查询文章，用get 地址栏的链接为：article.php?id=11，用post查询地址栏链接为：article.php， 不会将传输的数据展现出来。



### 17.cookie、sessionStorage、localStorage的区别  √

#### （1）cookie

> cooie是客户端与服务器端进行会话使用的一个能够在浏览器本地化存储的技术；
>
> cookie以字符串的形式存储，以key=value的形式存储，以；分割

http是无状态协议，为了让服务器能够识别客户端，客户端使用cookie，服务端使用session。当浏览器首次发送请求时，服务端会产生唯一的编号sessionId,响应时，把sessionId发送给浏览器端，浏览器端把sessionId保存到cookie中，下次请求时，带上sessionId，服务器根据不同的sessionId来区分不同客户端；

- 会话状态管理（用户登录状态，购物车）
- 个性化设置（保存用户设置的样式等）
- 浏览器行为跟踪（分析用户行为）

cookie可以在F12 Application中看到

#### （2）webStorage

> webstorage是HTML5新增的存储数据的方案，比使用cookie更加直观，提供了访问特定域名下的会话存储或者本地存储的功能；如果是会话存储则使用sessionStorage；如果是本地存储，使用localStorage；

- LocalStorage

> localStorage的生命周期是永久，除非手动清除，否则永远存在；存储大小是5MB，仅在客户端浏览器上存储，不参与服务器的通信；

```js
localStorage.setItem('username','Admin')
localStorage.getIte,('username')
localStorage.removeItem('username')
localStorage.clear()
```

- sessionStorage

> sessionStorage在同源的同窗口中，始终存在的数据，只要浏览器不关闭，即使是刷新或者进入另一个页面，数据任在；关闭窗口后sessionStorage就会销毁

```js
sessionStorage.setItem('sessionName','coco')
sessinStorage.getItem('sessionName')
sessinStorage.removeItem('username')
sessinStorage.clear()
```

异同：

https://blog.csdn.net/weixin_40381947/article/details/130059266

# 操作系统

### 1.线程、进程

线程是一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。进程是一个正在执行的程序的实例，包括程序计数器、寄存器和程序变量的当前值。

> - 进程依赖于程序运行而存在，进程是动态的，程序是静态的；
> - 进程是操作系统进行资源分配和调度的一个独立单位（CPU 除外，线程是处理器任务调度和执行的基本单位）；
> - 每个进程拥有独立的地址空间，地址空间包括代码区、数据区和堆栈区，进程之间的地址空间是隔离的，互不影响。

> 进程的创建、销毁与切换存在着较大的时空开销，因此人们急需一种轻型的进程技术来减少开销。在 80 年代，线程的概念开始出现，线程被设计成进程的一个执行路径，同一个进程中的线程共享进程的资源，因此系统对线程的调度所需的成本远远小于进程。

![img](https://pic1.zhimg.com/80/v2-579ef3f193e8027150590d7b9496e36c_720w.webp)

> - **本质区别：**进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
> - **包含关系：**一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
> - **资源开销：**每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
> - **影响关系：**一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。

https://zhuanlan.zhihu.com/p/519803985

https://zhuanlan.zhihu.com/p/556004836

#### 进程

- 进程是具有一定独立功能的程序关于某个[数据集合](https://www.zhihu.com/search?q=数据集合&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2868711843})上的一次运行活动
- 进程是系统进行资源分配和调度的一个独立单位
- 每个进程都有自己的独立内存空间，不同进程通过[进程间通信](https://www.zhihu.com/search?q=进程间通信&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2868711843})来通信
- 由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、[文件句柄](https://www.zhihu.com/search?q=文件句柄&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2868711843})等）比较大，但相对比较稳定安全。

#### 线程

- 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位
- 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如[程序计数器](https://www.zhihu.com/search?q=程序计数器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2868711843}),一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源
- 线程间通信主要通过共享内存，[上下文切换](https://www.zhihu.com/search?q=上下文切换&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2868711843})很快，资源开销较少，但[相⽐进程](https://www.zhihu.com/search?q=相⽐进程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2868711843})不够稳定容易丢失数据。

#### 应用场景

- 多进程：密集CPU任务，如大量并行计算。
- 多线程：密集IO



### 17.浏览器是多线程还是多进程还是单进程？

> 浏览器是多进程的

#### Boswer进程

是浏览器的主进程，负责主控，协调，只有一个，可以看做是浏览器的大脑。

- 负责下载页面的网络文件
- 负责将renderer进程得到的存在内存中的位图渲染（显示）到页面上
- 负责创建和销毁tab进程（renderer进程）
- 负责与用户的交互

#### GPU进程（1个）

- 负责3D绘制，只有当该页面使用了硬件加速才会使用它，来渲染（显示）页面。否则的话，不使用这个进程，而是用Browser进程来渲染（显示）页面

#### 渲染进程（浏览器内核）

每个tab页面对应一个独立的renderer进程，内部有多个线程。

- 负责脚本执行，位图绘制，事件触发，任务队列轮询等

##### js引擎线程

- 也称js内核，解析js脚本，执行代码
- 与GUI线程互斥，即当js引擎线程运行时，GUI线程会被挂起，当js引擎线程结束运行时，才会继续运行GUI线程
- 由一个主线程和多个web worker线程组成，由于web worker是附属于主线程，无法操作dom等，所以js还是单线程语言（在主线程运行js代码）

##### GUI渲染线程

- 用于解析html为DOM树，解析css为CSSOM树，布局layout，绘制paint
- 当页面需要重排reflow，重绘repaint时，使用该线程
- 与js引擎线程互斥

##### 事件触发线程

- 当对应事件触发（不论是WebAPIs完成事件触发，还是页面交互事件触发）时，该线程会将事件对应的回调函数放入callback queue（任务队列）中，等待js引擎线程的处理

##### 定时触发线程

- 对应于setTimeout，setInterval API，由该线程来计时，当计时结束，将事件对应的回调函数放入任务队列中
- 当setTimeout的定时的时间小于4ms，一律按4ms来算

##### http请求线程

- 每有一个http请求就开一个该线程
- 当检测到状态变更的话，就会产生一个状态变更事件，如果该状态变更事件对应有回调函数的话，则放入任务队列中

##### 任务队列轮询线程

- 用于轮询监听任务队列，以知道任务队列是否为空

#### 第三方插件进程

> 每种类型的插件对应一个进程（只有插件在使用时）



# 网络安全相关

### 1.DDOS





### 2.Web相关漏洞原理



### 3.XSS



#### 作用

- 获取页面数据
- 获取Cookies
- 劫持前端逻辑
- 发送请求到攻击者自己的网站实现资料的盗取
- 偷取网站任意数据
- 偷取用户密码和登陆状态
- 改变按钮的逻辑

#### 类型

- 反射型：这种类型的XSS攻击通常涉及攻击者构建一个含有恶意脚本的URL，当用户访问这个链接时，浏览器会将恶意脚本执行。这种攻击的特点是每次触发时都需要在用户端重新加载恶意脚本，因此对同一用户的后续访问影响不大。*

```url
http://localhost:1521/?from=<script>alert(1)</script>bing
```

- 存储型：**存储到DB后读取时注入（危害很大）**

> 存储型XSS又称持久型XSS，攻击脚本存储在目标服务器的数据库中，具有更强的隐蔽性。
> 攻击者在论坛、博客、留言板中，发帖的过程中嵌入XSS攻击代码，帖子被目标服务器存储在数据库中。当用户进行正常访问时，触发XSS代码。

- DOM型(DOM-based XSS)：DOM型XSS与前两种不同，它不依赖于服务器端的数据。攻击者通过用户输入的恶意脚本，在客户端直接修改网页的DOM结构，从而执行攻击。这种攻击方式通常需要用户直接输入包含恶意脚本的数据，如在搜索栏或登录表单中

#### 防御方法

1. 输入合法性验证：在服务端对用户输入的数据进行合法性验证，如检查输入是否符合指定格式，排除恶意字符等。

2. 转义特殊字符：在网页中用户输入的内容需要使用转义字符，例如将 < 转义成 <，将 > 转义成 >，避免浏览器将这些字符误解为标签等。

3. 设置HTTP头部：设置HTTP头部，包括Content-Security-Policy、X-Content-Type-Options、X-XSS-Protection等，来使浏览器拦截来自第三方资源的恶意脚本。

4. 使用脚本过滤器：使用脚本过滤器，如Google的Closure Library和jQuery库等，能够对来自用户的数据进行过滤和检查。

5. 限制cookie：限制cookie只能在HTTPS连接下使用，并使用HttpOnly标识确保cookie不能通过JavaScript代码访问。

### 4.CSRF











# 算法相关

> **//写一个方法，传入一个对象，输出对象的所有属性，以字典的顺序排序；**
>
> **//写一个函数，将一个深度嵌套的对象，将其扁平化，指定一个深度，扁平化到指定深度；**
>
> **//柯里化（我说我忘了换了下一题）**
>
> **//翻转链表：反转单向链表；**

- 数据拍平

```js
let obj = {
    Company: "xyz",
    Address: "aaa",
    contact: 0987654,
    mentor: {
        HTML: "A",
        CSS: "B",
        JavaScript: "C",
        Frame: {
            React: "D",
            Angular: "E",
            Vue: "F"
        }
    },
    abc: [1, 2, 3]
}
const flatten1 = (ob) => {
    let result = {}
    for (const key in ob) {
        if ((typeof ob[key]) === 'object' && !Array.isArray(ob[key])) {
            const temp = flatten1(ob[key])
            for (const subKey in temp) {
                result[subKey] = temp[subKey]
            }
        }
        else {
            result[key] = ob[key]
        }
    }
    return result
}

console.log("3", flatten1(obj))
```

- 柯里化

柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数的技术。这种技术通常用于创建一个参数接收器，或者用于提前确定某些参数。

```js
function curry (fn) {
    return function curried (...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args)
        } else {
            return function (...moreArgs) {
                return curried.apply(this, args.concat(moreArgs))
            }
        }
    }
}

// 使用 curry 函数的示例
function add (a, b) {
    return a + b
}

const curriedAdd = curry(add)
const add5 = curriedAdd(5)
console.log(add5(3))
console.log(curriedAdd(5, 3))
console.log(curriedAdd(5)(3))
```



# Linux相关

### 1.linux常用命令

- 修改文件夹权限

```shell
chmod  
chown
```



# 项目相关

### 1.项目上线如何捕获异常？





### 2.项目加载头花



### 3.服务端渲染为什么有利于SEO？非服务端渲染能做嘛？



### 4.网站线上性能有哪些指标判断？



### 5.npm，yarn依赖管理原理



### 6.拖动

https://zh.javascript.info/mouse-drag-and-drop

https://zh.javascript.info/coordinates



### 7.绘图功能做过嘛？画曲线的库有俩结果嘛？

#### 贝塞尔曲线

- 控制点

1. **控制点不总是在曲线上**这是非常正常的，稍后我们将看到曲线是如何构建的。
2. **曲线的阶次等于控制点的数量减一**。 对于两个点我们能得到一条线性曲线（直线），三个点 — 一条二阶曲线，四个点 — 一条三阶曲线。
3. **曲线总是在控制点的[凸包](https://en.wikipedia.org/wiki/Convex_hull)内部：*

![](https://s3.bmp.ovh/imgs/2024/03/12/e4c46e8b8a7c0b14.png)

- 数学：贝塞尔曲线可以使用数学方程式来描述

​	给定控制点 `Pi` 的坐标：第一个控制点的坐标为 `P1 = (x1, y1)`，第二个控制点的坐标为 `P2 = (x2, y2)`，以此类推，曲线坐标由方程式描述，这个方程式依赖属于区间 `[0,1]` 的参数 `t`。

![](https://s3.bmp.ovh/imgs/2024/03/12/233c01b12cd02d65.png)

1. 使用数学方程式。
2. 使用绘图过程：德卡斯特里奥算法

用途：

- 在计算机图形学，建模，矢量图形编辑器中。字体由贝塞尔曲线描述。
- 在 Web 开发中 — 用于 Canvas 上的图形和 SVG 格式。顺便说一下，上面的“实时”示例是用 SVG 编写的。它们实际上是一个 SVG 文档，被赋予不同的控制点做参数。你可以在单独的窗口中打开它并查源码：[demo.svg](https://zh.javascript.info/article/bezier-curve/demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1)。
- 在 CSS 动画中描述动画的路径和速度。



### 8.微前端中的应用隔离是什么？

> 分为主应用JS隔离、css隔离

#### css隔离

- cssmodule或者命名空间的方式，添加特定前缀 postcss插件，打包添加特定前缀
- 微应用之间css隔离：link style 打标
- shadow dom

#### js隔离

- window全局事件：沙箱sandbox进行隔离
- with、window.Proxy实现浏览器的沙箱



> 1.框架底层实现，SPA 了解底层实现方法；
>
> 2.事件绑定；
>
> 3.缓存，性能优化；

1.sessionStorage,localStorage

2.项目亮点

3.前端性能优化

4.vue-router底层实现原理

5.如何父组件调用子组件方法
